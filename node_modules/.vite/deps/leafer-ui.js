import "./chunk-5WRI5ZAA.js";

// node_modules/@leafer/core/lib/core.esm.js
var Platform = {
  toURL(text, fileType2) {
    let url = encodeURIComponent(text);
    if (fileType2 === "text")
      url = "data:text/plain;charset=utf-8," + url;
    else if (fileType2 === "svg")
      url = "data:image/svg+xml," + url;
    return url;
  },
  image: {
    hitCanvasSize: 100,
    maxCacheSize: 2560 * 1600,
    maxPatternSize: 4096 * 2160,
    crossOrigin: "anonymous",
    getRealURL(url) {
      const { prefix, suffix } = Platform.image;
      if (suffix && !url.startsWith("data:") && !url.startsWith("blob:"))
        url += (url.includes("?") ? "&" : "?") + suffix;
      if (prefix && url[0] === "/")
        url = prefix + url;
      return url;
    }
  }
};
var Creator = {};
var IncrementId = {
  RUNTIME: "runtime",
  LEAF: "leaf",
  TASK: "task",
  CNAVAS: "canvas",
  IMAGE: "image",
  types: {},
  create(typeName) {
    const { types } = I$1;
    if (types[typeName]) {
      return types[typeName]++;
    } else {
      types[typeName] = 1;
      return 0;
    }
  }
};
var I$1 = IncrementId;
var { round, pow: pow$1, PI: PI$2 } = Math;
var MathHelper = {
  within(value, min2, max) {
    if (typeof min2 === "object")
      max = min2.max, min2 = min2.min;
    if (min2 !== void 0 && value < min2)
      value = min2;
    if (max !== void 0 && value > max)
      value = max;
    return value;
  },
  fourNumber(num, maxValue) {
    let data;
    if (num instanceof Array) {
      switch (num.length) {
        case 4:
          data = maxValue === void 0 ? num : [...num];
          break;
        case 2:
          data = [num[0], num[1], num[0], num[1]];
          break;
        case 3:
          data = [num[0], num[1], num[2], num[1]];
          break;
        case 1:
          num = num[0];
          break;
        default:
          num = 0;
      }
    }
    if (!data)
      data = [num, num, num, num];
    if (maxValue) {
      for (let i = 0; i < 4; i++)
        if (data[i] > maxValue)
          data[i] = maxValue;
    }
    return data;
  },
  formatRotation(rotation, unsign) {
    rotation %= 360;
    if (unsign) {
      if (rotation < 0)
        rotation += 360;
    } else {
      if (rotation > 180)
        rotation -= 360;
      if (rotation < -180)
        rotation += 360;
    }
    return MathHelper.float(rotation);
  },
  getGapRotation(addRotation, gap, oldRotation = 0) {
    let rotation = addRotation + oldRotation;
    if (gap > 1) {
      const r = Math.abs(rotation % gap);
      if (r < 1 || r > gap - 1)
        rotation = Math.round(rotation / gap) * gap;
    }
    return rotation - oldRotation;
  },
  float(num, maxLength) {
    const a2 = maxLength !== void 0 ? pow$1(10, maxLength) : 1e12;
    num = round(num * a2) / a2;
    return num === -0 ? 0 : num;
  },
  getScaleData(scale2, size, originSize, scaleData) {
    if (!scaleData)
      scaleData = {};
    if (size) {
      scaleData.scaleX = (typeof size === "number" ? size : size.width) / originSize.width;
      scaleData.scaleY = (typeof size === "number" ? size : size.height) / originSize.height;
    } else if (scale2)
      MathHelper.assignScale(scaleData, scale2);
    return scaleData;
  },
  assignScale(scaleData, scale2) {
    if (typeof scale2 === "number") {
      scaleData.scaleX = scaleData.scaleY = scale2;
    } else {
      scaleData.scaleX = scale2.x;
      scaleData.scaleY = scale2.y;
    }
  }
};
var OneRadian = PI$2 / 180;
var PI2 = PI$2 * 2;
var PI_2 = PI$2 / 2;
function getPointData() {
  return { x: 0, y: 0 };
}
function getBoundsData() {
  return { x: 0, y: 0, width: 0, height: 0 };
}
function getMatrixData() {
  return { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0 };
}
var { sin: sin$3, cos: cos$3, acos, sqrt: sqrt$3 } = Math;
var { float: float$1 } = MathHelper;
var tempPoint$3 = {};
function getWorld() {
  return Object.assign(Object.assign(Object.assign({}, getMatrixData()), getBoundsData()), { scaleX: 1, scaleY: 1, rotation: 0, skewX: 0, skewY: 0 });
}
var MatrixHelper = {
  defaultMatrix: getMatrixData(),
  defaultWorld: getWorld(),
  tempMatrix: {},
  set(t2, a2 = 1, b = 0, c2 = 0, d = 1, e = 0, f = 0) {
    t2.a = a2;
    t2.b = b;
    t2.c = c2;
    t2.d = d;
    t2.e = e;
    t2.f = f;
  },
  get: getMatrixData,
  getWorld,
  copy(t2, matrix3) {
    t2.a = matrix3.a;
    t2.b = matrix3.b;
    t2.c = matrix3.c;
    t2.d = matrix3.d;
    t2.e = matrix3.e;
    t2.f = matrix3.f;
  },
  translate(t2, x, y) {
    t2.e += x;
    t2.f += y;
  },
  translateInner(t2, x, y, hasOrigin) {
    t2.e += t2.a * x + t2.c * y;
    t2.f += t2.b * x + t2.d * y;
    if (hasOrigin)
      t2.e -= x, t2.f -= y;
  },
  scale(t2, scaleX, scaleY = scaleX) {
    t2.a *= scaleX;
    t2.b *= scaleX;
    t2.c *= scaleY;
    t2.d *= scaleY;
  },
  scaleOfOuter(t2, origin2, scaleX, scaleY) {
    M$6.toInnerPoint(t2, origin2, tempPoint$3);
    M$6.scaleOfInner(t2, tempPoint$3, scaleX, scaleY);
  },
  scaleOfInner(t2, origin2, scaleX, scaleY = scaleX) {
    M$6.translateInner(t2, origin2.x, origin2.y);
    M$6.scale(t2, scaleX, scaleY);
    M$6.translateInner(t2, -origin2.x, -origin2.y);
  },
  rotate(t2, rotation) {
    const { a: a2, b, c: c2, d } = t2;
    rotation *= OneRadian;
    const cosR = cos$3(rotation);
    const sinR = sin$3(rotation);
    t2.a = a2 * cosR - b * sinR;
    t2.b = a2 * sinR + b * cosR;
    t2.c = c2 * cosR - d * sinR;
    t2.d = c2 * sinR + d * cosR;
  },
  rotateOfOuter(t2, origin2, rotation) {
    M$6.toInnerPoint(t2, origin2, tempPoint$3);
    M$6.rotateOfInner(t2, tempPoint$3, rotation);
  },
  rotateOfInner(t2, origin2, rotation) {
    M$6.translateInner(t2, origin2.x, origin2.y);
    M$6.rotate(t2, rotation);
    M$6.translateInner(t2, -origin2.x, -origin2.y);
  },
  skew(t2, skewX, skewY) {
    const { a: a2, b, c: c2, d } = t2;
    if (skewY) {
      skewY *= OneRadian;
      t2.a = a2 + c2 * skewY;
      t2.b = b + d * skewY;
    }
    if (skewX) {
      skewX *= OneRadian;
      t2.c = c2 + a2 * skewX;
      t2.d = d + b * skewX;
    }
  },
  skewOfOuter(t2, origin2, skewX, skewY) {
    M$6.toInnerPoint(t2, origin2, tempPoint$3);
    M$6.skewOfInner(t2, tempPoint$3, skewX, skewY);
  },
  skewOfInner(t2, origin2, skewX, skewY = 0) {
    M$6.translateInner(t2, origin2.x, origin2.y);
    M$6.skew(t2, skewX, skewY);
    M$6.translateInner(t2, -origin2.x, -origin2.y);
  },
  multiply(t2, child) {
    const { a: a2, b, c: c2, d, e, f } = t2;
    t2.a = child.a * a2 + child.b * c2;
    t2.b = child.a * b + child.b * d;
    t2.c = child.c * a2 + child.d * c2;
    t2.d = child.c * b + child.d * d;
    t2.e = child.e * a2 + child.f * c2 + e;
    t2.f = child.e * b + child.f * d + f;
  },
  multiplyParent(t2, parent, to, abcdChanged, childScaleData, scrollData) {
    let { e, f } = t2;
    if (scrollData)
      e += scrollData.scrollX, f += scrollData.scrollY;
    to || (to = t2);
    if (abcdChanged === void 0)
      abcdChanged = t2.a !== 1 || t2.b || t2.c || t2.d !== 1;
    if (abcdChanged) {
      const { a: a2, b, c: c2, d } = t2;
      to.a = a2 * parent.a + b * parent.c;
      to.b = a2 * parent.b + b * parent.d;
      to.c = c2 * parent.a + d * parent.c;
      to.d = c2 * parent.b + d * parent.d;
      if (childScaleData) {
        to.scaleX = parent.scaleX * childScaleData.scaleX;
        to.scaleY = parent.scaleY * childScaleData.scaleY;
      }
    } else {
      to.a = parent.a;
      to.b = parent.b;
      to.c = parent.c;
      to.d = parent.d;
      if (childScaleData) {
        to.scaleX = parent.scaleX;
        to.scaleY = parent.scaleY;
      }
    }
    to.e = e * parent.a + f * parent.c + parent.e;
    to.f = e * parent.b + f * parent.d + parent.f;
  },
  divide(t2, child) {
    M$6.multiply(t2, M$6.tempInvert(child));
  },
  divideParent(t2, parent) {
    M$6.multiplyParent(t2, M$6.tempInvert(parent));
  },
  tempInvert(t2) {
    const { tempMatrix: tempMatrix2 } = M$6;
    M$6.copy(tempMatrix2, t2);
    M$6.invert(tempMatrix2);
    return tempMatrix2;
  },
  invert(t2) {
    const { a: a2, b, c: c2, d, e, f } = t2;
    if (!b && !c2) {
      if (a2 === 1 && d === 1) {
        t2.e = -e;
        t2.f = -f;
      } else {
        const s2 = 1 / (a2 * d);
        t2.a = d * s2;
        t2.d = a2 * s2;
        t2.e = -e * d * s2;
        t2.f = -f * a2 * s2;
      }
    } else {
      const s2 = 1 / (a2 * d - b * c2);
      t2.a = d * s2;
      t2.b = -b * s2;
      t2.c = -c2 * s2;
      t2.d = a2 * s2;
      t2.e = -(e * d - f * c2) * s2;
      t2.f = -(f * a2 - e * b) * s2;
    }
  },
  toOuterPoint(t2, inner2, to, distance) {
    const { x, y } = inner2;
    to || (to = inner2);
    to.x = x * t2.a + y * t2.c;
    to.y = x * t2.b + y * t2.d;
    if (!distance) {
      to.x += t2.e;
      to.y += t2.f;
    }
  },
  toInnerPoint(t2, outer, to, distance) {
    const { a: a2, b, c: c2, d } = t2;
    const s2 = 1 / (a2 * d - b * c2);
    const { x, y } = outer;
    to || (to = outer);
    to.x = (x * d - y * c2) * s2;
    to.y = (y * a2 - x * b) * s2;
    if (!distance) {
      const { e, f } = t2;
      to.x -= (e * d - f * c2) * s2;
      to.y -= (f * a2 - e * b) * s2;
    }
  },
  setLayout(t2, layout, origin2, around, bcChanged) {
    const { x, y, scaleX, scaleY } = layout;
    if (bcChanged === void 0)
      bcChanged = layout.rotation || layout.skewX || layout.skewY;
    if (bcChanged) {
      const { rotation, skewX, skewY } = layout;
      const r = rotation * OneRadian;
      const cosR = cos$3(r);
      const sinR = sin$3(r);
      if (skewX || skewY) {
        const sx = skewX * OneRadian;
        const sy = skewY * OneRadian;
        t2.a = (cosR + sy * -sinR) * scaleX;
        t2.b = (sinR + sy * cosR) * scaleX;
        t2.c = (-sinR + sx * cosR) * scaleY;
        t2.d = (cosR + sx * sinR) * scaleY;
      } else {
        t2.a = cosR * scaleX;
        t2.b = sinR * scaleX;
        t2.c = -sinR * scaleY;
        t2.d = cosR * scaleY;
      }
    } else {
      t2.a = scaleX;
      t2.b = 0;
      t2.c = 0;
      t2.d = scaleY;
    }
    t2.e = x;
    t2.f = y;
    if (origin2 = origin2 || around)
      M$6.translateInner(t2, -origin2.x, -origin2.y, !around);
  },
  getLayout(t2, origin2, around, firstSkewY) {
    const { a: a2, b, c: c2, d, e, f } = t2;
    let x = e, y = f, scaleX, scaleY, rotation, skewX, skewY;
    if (b || c2) {
      const s2 = a2 * d - b * c2;
      if (c2 && !firstSkewY) {
        scaleX = sqrt$3(a2 * a2 + b * b);
        scaleY = s2 / scaleX;
        const cosR2 = a2 / scaleX;
        rotation = b > 0 ? acos(cosR2) : -acos(cosR2);
      } else {
        scaleY = sqrt$3(c2 * c2 + d * d);
        scaleX = s2 / scaleY;
        const cosR2 = c2 / scaleY;
        rotation = PI_2 - (d > 0 ? acos(-cosR2) : -acos(cosR2));
      }
      const cosR = float$1(cos$3(rotation));
      const sinR = sin$3(rotation);
      scaleX = float$1(scaleX), scaleY = float$1(scaleY);
      skewX = cosR ? float$1((c2 / scaleY + sinR) / cosR / OneRadian, 9) : 0;
      skewY = cosR ? float$1((b / scaleX - sinR) / cosR / OneRadian, 9) : 0;
      rotation = float$1(rotation / OneRadian);
    } else {
      scaleX = a2;
      scaleY = d;
      rotation = skewX = skewY = 0;
    }
    if (origin2 = around || origin2) {
      x += origin2.x * a2 + origin2.y * c2;
      y += origin2.x * b + origin2.y * d;
      if (!around)
        x -= origin2.x, y -= origin2.y;
    }
    return { x, y, scaleX, scaleY, rotation, skewX, skewY };
  },
  withScale(t2, scaleX, scaleY = scaleX) {
    const world = t2;
    if (!scaleX || !scaleY) {
      const { a: a2, b, c: c2, d } = t2;
      if (b || c2) {
        scaleX = sqrt$3(a2 * a2 + b * b);
        scaleY = (a2 * d - b * c2) / scaleX;
      } else {
        scaleX = a2;
        scaleY = d;
      }
    }
    world.scaleX = scaleX;
    world.scaleY = scaleY;
    return world;
  },
  reset(t2) {
    M$6.set(t2);
  }
};
var M$6 = MatrixHelper;
var { toInnerPoint: toInnerPoint$2, toOuterPoint: toOuterPoint$3 } = MatrixHelper;
var { sin: sin$2, cos: cos$2, abs: abs$2, sqrt: sqrt$2, atan2: atan2$2, min: min$1, PI: PI$1 } = Math;
var PointHelper = {
  defaultPoint: getPointData(),
  tempPoint: {},
  tempRadiusPoint: {},
  set(t2, x = 0, y = 0) {
    t2.x = x;
    t2.y = y;
  },
  setRadius(t2, x, y) {
    t2.radiusX = x;
    t2.radiusY = y === void 0 ? x : y;
  },
  copy(t2, point2) {
    t2.x = point2.x;
    t2.y = point2.y;
  },
  copyFrom(t2, x, y) {
    t2.x = x;
    t2.y = y;
  },
  move(t2, x, y) {
    t2.x += x;
    t2.y += y;
  },
  scale(t2, scaleX, scaleY = scaleX) {
    if (t2.x)
      t2.x *= scaleX;
    if (t2.y)
      t2.y *= scaleY;
  },
  scaleOf(t2, origin2, scaleX, scaleY = scaleX) {
    t2.x += (t2.x - origin2.x) * (scaleX - 1);
    t2.y += (t2.y - origin2.y) * (scaleY - 1);
  },
  rotate(t2, rotation, origin2) {
    if (!origin2)
      origin2 = P$5.defaultPoint;
    rotation *= OneRadian;
    const cosR = cos$2(rotation);
    const sinR = sin$2(rotation);
    const rx = t2.x - origin2.x;
    const ry = t2.y - origin2.y;
    t2.x = origin2.x + rx * cosR - ry * sinR;
    t2.y = origin2.y + rx * sinR + ry * cosR;
  },
  tempToInnerOf(t2, matrix3) {
    const { tempPoint: temp } = P$5;
    copy$7(temp, t2);
    toInnerPoint$2(matrix3, temp, temp);
    return temp;
  },
  tempToOuterOf(t2, matrix3) {
    const { tempPoint: temp } = P$5;
    copy$7(temp, t2);
    toOuterPoint$3(matrix3, temp, temp);
    return temp;
  },
  tempToInnerRadiusPointOf(t2, matrix3) {
    const { tempRadiusPoint: temp } = P$5;
    copy$7(temp, t2);
    P$5.toInnerRadiusPointOf(t2, matrix3, temp);
    return temp;
  },
  toInnerRadiusPointOf(t2, matrix3, to) {
    to || (to = t2);
    toInnerPoint$2(matrix3, t2, to);
    to.radiusX = Math.abs(t2.radiusX / matrix3.scaleX);
    to.radiusY = Math.abs(t2.radiusY / matrix3.scaleY);
  },
  toInnerOf(t2, matrix3, to) {
    toInnerPoint$2(matrix3, t2, to);
  },
  toOuterOf(t2, matrix3, to) {
    toOuterPoint$3(matrix3, t2, to);
  },
  getCenter(t2, to) {
    return { x: t2.x + (to.x - t2.x) / 2, y: t2.y + (to.y - t2.y) / 2 };
  },
  getCenterX(x1, x2) {
    return x1 + (x2 - x1) / 2;
  },
  getCenterY(y1, y2) {
    return y1 + (y2 - y1) / 2;
  },
  getDistance(t2, point2) {
    return getDistanceFrom(t2.x, t2.y, point2.x, point2.y);
  },
  getDistanceFrom(x1, y1, x2, y2) {
    const x = abs$2(x2 - x1);
    const y = abs$2(y2 - y1);
    return sqrt$2(x * x + y * y);
  },
  getMinDistanceFrom(x1, y1, x2, y2, x3, y3) {
    return min$1(getDistanceFrom(x1, y1, x2, y2), getDistanceFrom(x2, y2, x3, y3));
  },
  getAngle(t2, to) {
    return getAtan2(t2, to) / OneRadian;
  },
  getRotation(t2, origin2, to, toOrigin) {
    if (!toOrigin)
      toOrigin = origin2;
    return P$5.getRadianFrom(t2.x, t2.y, origin2.x, origin2.y, to.x, to.y, toOrigin.x, toOrigin.y) / OneRadian;
  },
  getRadianFrom(fromX, fromY, originX, originY, toX, toY, toOriginX, toOriginY) {
    if (toOriginX === void 0)
      toOriginX = originX, toOriginY = originY;
    let fromAngle = atan2$2(fromY - originY, fromX - originX);
    let toAngle = atan2$2(toY - toOriginY, toX - toOriginX);
    const radian = toAngle - fromAngle;
    return radian < -PI$1 ? radian + PI2 : radian;
  },
  getAtan2(t2, to) {
    return atan2$2(to.y - t2.y, to.x - t2.x);
  },
  getDistancePoint(t2, to, distance, changeTo) {
    const r = getAtan2(t2, to);
    to = changeTo ? to : {};
    to.x = t2.x + cos$2(r) * distance;
    to.y = t2.y + sin$2(r) * distance;
    return to;
  },
  toNumberPoints(originPoints) {
    let points = originPoints;
    if (typeof originPoints[0] === "object")
      points = [], originPoints.forEach((p) => points.push(p.x, p.y));
    return points;
  },
  reset(t2) {
    P$5.reset(t2);
  }
};
var P$5 = PointHelper;
var { getDistanceFrom, copy: copy$7, getAtan2 } = P$5;
var Point = class _Point {
  constructor(x, y) {
    this.set(x, y);
  }
  set(x, y) {
    typeof x === "object" ? PointHelper.copy(this, x) : PointHelper.set(this, x, y);
    return this;
  }
  get() {
    const { x, y } = this;
    return { x, y };
  }
  clone() {
    return new _Point(this);
  }
  move(x, y) {
    PointHelper.move(this, x, y);
    return this;
  }
  scale(scaleX, scaleY) {
    PointHelper.scale(this, scaleX, scaleY);
    return this;
  }
  scaleOf(origin2, scaleX, scaleY) {
    PointHelper.scaleOf(this, origin2, scaleX, scaleY);
    return this;
  }
  rotate(rotation, origin2) {
    PointHelper.rotate(this, rotation, origin2);
    return this;
  }
  rotateOf(origin2, rotation) {
    PointHelper.rotate(this, rotation, origin2);
    return this;
  }
  getRotation(origin2, to, toOrigin) {
    return PointHelper.getRotation(this, origin2, to, toOrigin);
  }
  toInnerOf(matrix3, to) {
    PointHelper.toInnerOf(this, matrix3, to);
    return this;
  }
  toOuterOf(matrix3, to) {
    PointHelper.toOuterOf(this, matrix3, to);
    return this;
  }
  getCenter(to) {
    return new _Point(PointHelper.getCenter(this, to));
  }
  getDistance(to) {
    return PointHelper.getDistance(this, to);
  }
  getDistancePoint(to, distance, changeTo) {
    return new _Point(PointHelper.getDistancePoint(this, to, distance, changeTo));
  }
  getAngle(to) {
    return PointHelper.getAngle(this, to);
  }
  getAtan2(to) {
    return PointHelper.getAtan2(this, to);
  }
  reset() {
    PointHelper.reset(this);
    return this;
  }
};
var tempPoint$2 = new Point();
var Matrix = class _Matrix {
  constructor(a2, b, c2, d, e, f) {
    this.set(a2, b, c2, d, e, f);
  }
  set(a2, b, c2, d, e, f) {
    typeof a2 === "object" ? MatrixHelper.copy(this, a2) : MatrixHelper.set(this, a2, b, c2, d, e, f);
    return this;
  }
  setWith(dataWithScale) {
    MatrixHelper.copy(this, dataWithScale);
    this.scaleX = dataWithScale.scaleX;
    this.scaleY = dataWithScale.scaleY;
    return this;
  }
  get() {
    const { a: a2, b, c: c2, d, e, f } = this;
    return { a: a2, b, c: c2, d, e, f };
  }
  clone() {
    return new _Matrix(this);
  }
  translate(x, y) {
    MatrixHelper.translate(this, x, y);
    return this;
  }
  translateInner(x, y) {
    MatrixHelper.translateInner(this, x, y);
    return this;
  }
  scale(x, y) {
    MatrixHelper.scale(this, x, y);
    return this;
  }
  scaleWith(x, y) {
    MatrixHelper.scale(this, x, y);
    this.scaleX *= x;
    this.scaleY *= y || x;
    return this;
  }
  scaleOfOuter(origin2, x, y) {
    MatrixHelper.scaleOfOuter(this, origin2, x, y);
    return this;
  }
  scaleOfInner(origin2, x, y) {
    MatrixHelper.scaleOfInner(this, origin2, x, y);
    return this;
  }
  rotate(angle) {
    MatrixHelper.rotate(this, angle);
    return this;
  }
  rotateOfOuter(origin2, angle) {
    MatrixHelper.rotateOfOuter(this, origin2, angle);
    return this;
  }
  rotateOfInner(origin2, angle) {
    MatrixHelper.rotateOfInner(this, origin2, angle);
    return this;
  }
  skew(x, y) {
    MatrixHelper.skew(this, x, y);
    return this;
  }
  skewOfOuter(origin2, x, y) {
    MatrixHelper.skewOfOuter(this, origin2, x, y);
    return this;
  }
  skewOfInner(origin2, x, y) {
    MatrixHelper.skewOfInner(this, origin2, x, y);
    return this;
  }
  multiply(child) {
    MatrixHelper.multiply(this, child);
    return this;
  }
  multiplyParent(parent) {
    MatrixHelper.multiplyParent(this, parent);
    return this;
  }
  divide(child) {
    MatrixHelper.divide(this, child);
    return this;
  }
  divideParent(parent) {
    MatrixHelper.divideParent(this, parent);
    return this;
  }
  invert() {
    MatrixHelper.invert(this);
    return this;
  }
  invertWith() {
    MatrixHelper.invert(this);
    this.scaleX = 1 / this.scaleX;
    this.scaleY = 1 / this.scaleY;
    return this;
  }
  toOuterPoint(inner2, to, distance) {
    MatrixHelper.toOuterPoint(this, inner2, to, distance);
  }
  toInnerPoint(outer, to, distance) {
    MatrixHelper.toInnerPoint(this, outer, to, distance);
  }
  setLayout(data, origin2, around) {
    MatrixHelper.setLayout(this, data, origin2, around);
    return this;
  }
  getLayout(origin2, around, firstSkewY) {
    return MatrixHelper.getLayout(this, origin2, around, firstSkewY);
  }
  withScale(scaleX, scaleY) {
    return MatrixHelper.withScale(this, scaleX, scaleY);
  }
  reset() {
    MatrixHelper.reset(this);
  }
};
var tempMatrix = new Matrix();
var TwoPointBoundsHelper = {
  tempPointBounds: {},
  setPoint(t2, minX, minY) {
    t2.minX = t2.maxX = minX;
    t2.minY = t2.maxY = minY;
  },
  addPoint(t2, x, y) {
    t2.minX = x < t2.minX ? x : t2.minX;
    t2.minY = y < t2.minY ? y : t2.minY;
    t2.maxX = x > t2.maxX ? x : t2.maxX;
    t2.maxY = y > t2.maxY ? y : t2.maxY;
  },
  addBounds(t2, x, y, width, height) {
    addPoint$3(t2, x, y);
    addPoint$3(t2, x + width, y + height);
  },
  copy(t2, pb) {
    t2.minX = pb.minX;
    t2.minY = pb.minY;
    t2.maxX = pb.maxX;
    t2.maxY = pb.maxY;
  },
  addPointBounds(t2, pb) {
    t2.minX = pb.minX < t2.minX ? pb.minX : t2.minX;
    t2.minY = pb.minY < t2.minY ? pb.minY : t2.minY;
    t2.maxX = pb.maxX > t2.maxX ? pb.maxX : t2.maxX;
    t2.maxY = pb.maxY > t2.maxY ? pb.maxY : t2.maxY;
  },
  toBounds(t2, setBounds) {
    setBounds.x = t2.minX;
    setBounds.y = t2.minY;
    setBounds.width = t2.maxX - t2.minX;
    setBounds.height = t2.maxY - t2.minY;
  }
};
var { addPoint: addPoint$3 } = TwoPointBoundsHelper;
var { tempPointBounds: tempPointBounds$1, setPoint: setPoint$2, addPoint: addPoint$2, toBounds: toBounds$2 } = TwoPointBoundsHelper;
var { toOuterPoint: toOuterPoint$2 } = MatrixHelper;
var { float, fourNumber } = MathHelper;
var { floor, ceil: ceil$1 } = Math;
var right;
var bottom;
var boundsRight;
var boundsBottom;
var point = {};
var toPoint$2 = {};
var BoundsHelper = {
  tempBounds: {},
  set(t2, x = 0, y = 0, width = 0, height = 0) {
    t2.x = x;
    t2.y = y;
    t2.width = width;
    t2.height = height;
  },
  copy(t2, bounds2) {
    t2.x = bounds2.x;
    t2.y = bounds2.y;
    t2.width = bounds2.width;
    t2.height = bounds2.height;
  },
  copyAndSpread(t2, bounds2, spread2, isShrink, side) {
    const { x, y, width, height } = bounds2;
    if (spread2 instanceof Array) {
      const four = fourNumber(spread2);
      isShrink ? B.set(t2, x + four[3], y + four[0], width - four[1] - four[3], height - four[2] - four[0]) : B.set(t2, x - four[3], y - four[0], width + four[1] + four[3], height + four[2] + four[0]);
    } else {
      if (isShrink)
        spread2 = -spread2;
      B.set(t2, x - spread2, y - spread2, width + spread2 * 2, height + spread2 * 2);
    }
    if (side) {
      if (side === "width")
        t2.y = y, t2.height = height;
      else
        t2.x = x, t2.width = width;
    }
  },
  minX(t2) {
    return t2.width > 0 ? t2.x : t2.x + t2.width;
  },
  minY(t2) {
    return t2.height > 0 ? t2.y : t2.y + t2.height;
  },
  maxX(t2) {
    return t2.width > 0 ? t2.x + t2.width : t2.x;
  },
  maxY(t2) {
    return t2.height > 0 ? t2.y + t2.height : t2.y;
  },
  move(t2, x, y) {
    t2.x += x;
    t2.y += y;
  },
  getByMove(t2, x, y) {
    t2 = Object.assign({}, t2);
    B.move(t2, x, y);
    return t2;
  },
  toOffsetOutBounds(t2, to, parent) {
    if (!to) {
      to = t2;
    } else {
      copy$6(to, t2);
    }
    if (parent) {
      to.offsetX = -(B.maxX(parent) - t2.x);
      to.offsetY = -(B.maxY(parent) - t2.y);
    } else {
      to.offsetX = t2.x + t2.width;
      to.offsetY = t2.y + t2.height;
    }
    B.move(to, -to.offsetX, -to.offsetY);
  },
  scale(t2, scaleX, scaleY = scaleX) {
    PointHelper.scale(t2, scaleX, scaleY);
    t2.width *= scaleX;
    t2.height *= scaleY;
  },
  scaleOf(t2, origin2, scaleX, scaleY = scaleX) {
    PointHelper.scaleOf(t2, origin2, scaleX, scaleY);
    t2.width *= scaleX;
    t2.height *= scaleY;
  },
  tempToOuterOf(t2, matrix3) {
    B.copy(B.tempBounds, t2);
    B.toOuterOf(B.tempBounds, matrix3);
    return B.tempBounds;
  },
  getOuterOf(t2, matrix3) {
    t2 = Object.assign({}, t2);
    B.toOuterOf(t2, matrix3);
    return t2;
  },
  toOuterOf(t2, matrix3, to) {
    to || (to = t2);
    if (matrix3.b === 0 && matrix3.c === 0) {
      const { a: a2, d } = matrix3;
      if (a2 > 0) {
        to.width = t2.width * a2;
        to.x = matrix3.e + t2.x * a2;
      } else {
        to.width = t2.width * -a2;
        to.x = matrix3.e + t2.x * a2 - to.width;
      }
      if (d > 0) {
        to.height = t2.height * d;
        to.y = matrix3.f + t2.y * d;
      } else {
        to.height = t2.height * -d;
        to.y = matrix3.f + t2.y * d - to.height;
      }
    } else {
      point.x = t2.x;
      point.y = t2.y;
      toOuterPoint$2(matrix3, point, toPoint$2);
      setPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      point.x = t2.x + t2.width;
      toOuterPoint$2(matrix3, point, toPoint$2);
      addPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      point.y = t2.y + t2.height;
      toOuterPoint$2(matrix3, point, toPoint$2);
      addPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      point.x = t2.x;
      toOuterPoint$2(matrix3, point, toPoint$2);
      addPoint$2(tempPointBounds$1, toPoint$2.x, toPoint$2.y);
      toBounds$2(tempPointBounds$1, to);
    }
  },
  toInnerOf(t2, matrix3, to) {
    to || (to = t2);
    B.move(to, -matrix3.e, -matrix3.f);
    B.scale(to, 1 / matrix3.a, 1 / matrix3.d);
  },
  getFitMatrix(t2, put, baseScale = 1) {
    const scale2 = Math.min(baseScale, Math.min(t2.width / put.width, t2.height / put.height));
    return new Matrix(scale2, 0, 0, scale2, -put.x * scale2, -put.y * scale2);
  },
  getSpread(t2, spread2, side) {
    const n = {};
    B.copyAndSpread(n, t2, spread2, false, side);
    return n;
  },
  spread(t2, spread2, side) {
    B.copyAndSpread(t2, t2, spread2, false, side);
  },
  shrink(t2, shrink, side) {
    B.copyAndSpread(t2, t2, shrink, true, side);
  },
  ceil(t2) {
    const { x, y } = t2;
    t2.x = floor(t2.x);
    t2.y = floor(t2.y);
    t2.width = x > t2.x ? ceil$1(t2.width + x - t2.x) : ceil$1(t2.width);
    t2.height = y > t2.y ? ceil$1(t2.height + y - t2.y) : ceil$1(t2.height);
  },
  unsign(t2) {
    if (t2.width < 0) {
      t2.x += t2.width;
      t2.width = -t2.width;
    }
    if (t2.height < 0) {
      t2.y += t2.height;
      t2.height = -t2.height;
    }
  },
  float(t2, maxLength) {
    t2.x = float(t2.x, maxLength);
    t2.y = float(t2.y, maxLength);
    t2.width = float(t2.width, maxLength);
    t2.height = float(t2.height, maxLength);
  },
  add(t2, bounds2, isPoint) {
    right = t2.x + t2.width;
    bottom = t2.y + t2.height;
    boundsRight = bounds2.x;
    boundsBottom = bounds2.y;
    if (!isPoint) {
      boundsRight += bounds2.width;
      boundsBottom += bounds2.height;
    }
    right = right > boundsRight ? right : boundsRight;
    bottom = bottom > boundsBottom ? bottom : boundsBottom;
    t2.x = t2.x < bounds2.x ? t2.x : bounds2.x;
    t2.y = t2.y < bounds2.y ? t2.y : bounds2.y;
    t2.width = right - t2.x;
    t2.height = bottom - t2.y;
  },
  addList(t2, list3) {
    B.setListWithFn(t2, list3, void 0, true);
  },
  setList(t2, list3, addMode = false) {
    B.setListWithFn(t2, list3, void 0, addMode);
  },
  addListWithFn(t2, list3, boundsDataFn) {
    B.setListWithFn(t2, list3, boundsDataFn, true);
  },
  setListWithFn(t2, list3, boundsDataFn, addMode = false) {
    let bounds2, first = true;
    for (let i = 0, len = list3.length; i < len; i++) {
      bounds2 = boundsDataFn ? boundsDataFn(list3[i]) : list3[i];
      if (bounds2 && (bounds2.width || bounds2.height)) {
        if (first) {
          first = false;
          if (!addMode)
            copy$6(t2, bounds2);
        } else {
          add(t2, bounds2);
        }
      }
    }
    if (first)
      B.reset(t2);
  },
  setPoints(t2, points) {
    points.forEach((point2, index) => index === 0 ? setPoint$2(tempPointBounds$1, point2.x, point2.y) : addPoint$2(tempPointBounds$1, point2.x, point2.y));
    toBounds$2(tempPointBounds$1, t2);
  },
  setPoint(t2, point2) {
    B.set(t2, point2.x, point2.y);
  },
  addPoint(t2, point2) {
    add(t2, point2, true);
  },
  getPoints(t2) {
    const { x, y, width, height } = t2;
    return [
      { x, y },
      { x: x + width, y },
      { x: x + width, y: y + height },
      { x, y: y + height }
    ];
  },
  hitRadiusPoint(t2, point2, pointMatrix) {
    if (pointMatrix)
      point2 = PointHelper.tempToInnerRadiusPointOf(point2, pointMatrix);
    return point2.x >= t2.x - point2.radiusX && point2.x <= t2.x + t2.width + point2.radiusX && (point2.y >= t2.y - point2.radiusY && point2.y <= t2.y + t2.height + point2.radiusY);
  },
  hitPoint(t2, point2, pointMatrix) {
    if (pointMatrix)
      point2 = PointHelper.tempToInnerOf(point2, pointMatrix);
    return point2.x >= t2.x && point2.x <= t2.x + t2.width && (point2.y >= t2.y && point2.y <= t2.y + t2.height);
  },
  hit(t2, other, otherMatrix) {
    if (otherMatrix)
      other = B.tempToOuterOf(other, otherMatrix);
    return !(t2.y + t2.height < other.y || other.y + other.height < t2.y || t2.x + t2.width < other.x || other.x + other.width < t2.x);
  },
  includes(t2, other, otherMatrix) {
    if (otherMatrix)
      other = B.tempToOuterOf(other, otherMatrix);
    return t2.x <= other.x && t2.y <= other.y && t2.x + t2.width >= other.x + other.width && t2.y + t2.height >= other.y + other.height;
  },
  getIntersectData(t2, other, otherMatrix) {
    if (otherMatrix)
      other = B.tempToOuterOf(other, otherMatrix);
    if (!B.hit(t2, other))
      return getBoundsData();
    let { x, y, width, height } = other;
    right = x + width;
    bottom = y + height;
    boundsRight = t2.x + t2.width;
    boundsBottom = t2.y + t2.height;
    x = x > t2.x ? x : t2.x;
    y = y > t2.y ? y : t2.y;
    right = right < boundsRight ? right : boundsRight;
    bottom = bottom < boundsBottom ? bottom : boundsBottom;
    width = right - x;
    height = bottom - y;
    return { x, y, width, height };
  },
  intersect(t2, other, otherMatrix) {
    B.copy(t2, B.getIntersectData(t2, other, otherMatrix));
  },
  isSame(t2, bounds2) {
    return t2.x === bounds2.x && t2.y === bounds2.y && t2.width === bounds2.width && t2.height === bounds2.height;
  },
  isEmpty(t2) {
    return t2.x === 0 && t2.y === 0 && t2.width === 0 && t2.height === 0;
  },
  reset(t2) {
    B.set(t2);
  }
};
var B = BoundsHelper;
var { add, copy: copy$6 } = B;
var Bounds = class _Bounds {
  get minX() {
    return BoundsHelper.minX(this);
  }
  get minY() {
    return BoundsHelper.minY(this);
  }
  get maxX() {
    return BoundsHelper.maxX(this);
  }
  get maxY() {
    return BoundsHelper.maxY(this);
  }
  constructor(x, y, width, height) {
    this.set(x, y, width, height);
  }
  set(x, y, width, height) {
    typeof x === "object" ? BoundsHelper.copy(this, x) : BoundsHelper.set(this, x, y, width, height);
    return this;
  }
  get() {
    const { x, y, width, height } = this;
    return { x, y, width, height };
  }
  clone() {
    return new _Bounds(this);
  }
  move(x, y) {
    BoundsHelper.move(this, x, y);
    return this;
  }
  scale(scaleX, scaleY) {
    BoundsHelper.scale(this, scaleX, scaleY);
    return this;
  }
  scaleOf(origin2, scaleX, scaleY) {
    BoundsHelper.scaleOf(this, origin2, scaleX, scaleY);
    return this;
  }
  toOuterOf(matrix3, to) {
    BoundsHelper.toOuterOf(this, matrix3, to);
    return this;
  }
  toInnerOf(matrix3, to) {
    BoundsHelper.toInnerOf(this, matrix3, to);
    return this;
  }
  getFitMatrix(put, baseScale) {
    return BoundsHelper.getFitMatrix(this, put, baseScale);
  }
  spread(fourNumber2, side) {
    BoundsHelper.spread(this, fourNumber2, side);
    return this;
  }
  shrink(fourNumber2, side) {
    BoundsHelper.shrink(this, fourNumber2, side);
    return this;
  }
  ceil() {
    BoundsHelper.ceil(this);
    return this;
  }
  unsign() {
    BoundsHelper.unsign(this);
    return this;
  }
  float(maxLength) {
    BoundsHelper.float(this, maxLength);
    return this;
  }
  add(bounds2) {
    BoundsHelper.add(this, bounds2);
    return this;
  }
  addList(boundsList) {
    BoundsHelper.setList(this, boundsList, true);
    return this;
  }
  setList(boundsList) {
    BoundsHelper.setList(this, boundsList);
    return this;
  }
  addListWithFn(list3, boundsDataFn) {
    BoundsHelper.setListWithFn(this, list3, boundsDataFn, true);
    return this;
  }
  setListWithFn(list3, boundsDataFn) {
    BoundsHelper.setListWithFn(this, list3, boundsDataFn);
    return this;
  }
  setPoint(point2) {
    BoundsHelper.setPoint(this, point2);
    return this;
  }
  setPoints(points) {
    BoundsHelper.setPoints(this, points);
    return this;
  }
  addPoint(point2) {
    BoundsHelper.addPoint(this, point2);
    return this;
  }
  getPoints() {
    return BoundsHelper.getPoints(this);
  }
  hitPoint(point2, pointMatrix) {
    return BoundsHelper.hitPoint(this, point2, pointMatrix);
  }
  hitRadiusPoint(point2, pointMatrix) {
    return BoundsHelper.hitRadiusPoint(this, point2, pointMatrix);
  }
  hit(bounds2, boundsMatrix) {
    return BoundsHelper.hit(this, bounds2, boundsMatrix);
  }
  includes(bounds2, boundsMatrix) {
    return BoundsHelper.includes(this, bounds2, boundsMatrix);
  }
  intersect(bounds2, boundsMatrix) {
    BoundsHelper.intersect(this, bounds2, boundsMatrix);
    return this;
  }
  getIntersect(bounds2, boundsMatrix) {
    return new _Bounds(BoundsHelper.getIntersectData(this, bounds2, boundsMatrix));
  }
  isSame(bounds2) {
    return BoundsHelper.isSame(this, bounds2);
  }
  isEmpty() {
    return BoundsHelper.isEmpty(this);
  }
  reset() {
    BoundsHelper.reset(this);
  }
};
var tempBounds = new Bounds();
var AutoBounds = class {
  constructor(top2, right3, bottom3, left2, width, height) {
    typeof top2 === "object" ? this.copy(top2) : this.set(top2, right3, bottom3, left2, width, height);
  }
  set(top2 = 0, right3 = 0, bottom3 = 0, left2 = 0, width = 0, height = 0) {
    this.top = top2;
    this.right = right3;
    this.bottom = bottom3;
    this.left = left2;
    this.width = width;
    this.height = height;
  }
  copy(autoSize) {
    const { top: top2, right: right3, bottom: bottom3, left: left2, width, height } = autoSize;
    this.set(top2, right3, bottom3, left2, width, height);
  }
  getBoundsFrom(parent) {
    const { top: top2, right: right3, bottom: bottom3, left: left2, width, height } = this;
    return new Bounds(left2, top2, width ? width : parent.width - left2 - right3, height ? height : parent.height - top2 - bottom3);
  }
};
var Direction4;
(function(Direction42) {
  Direction42[Direction42["top"] = 0] = "top";
  Direction42[Direction42["right"] = 1] = "right";
  Direction42[Direction42["bottom"] = 2] = "bottom";
  Direction42[Direction42["left"] = 3] = "left";
})(Direction4 || (Direction4 = {}));
var Direction9;
(function(Direction92) {
  Direction92[Direction92["topLeft"] = 0] = "topLeft";
  Direction92[Direction92["top"] = 1] = "top";
  Direction92[Direction92["topRight"] = 2] = "topRight";
  Direction92[Direction92["right"] = 3] = "right";
  Direction92[Direction92["bottomRight"] = 4] = "bottomRight";
  Direction92[Direction92["bottom"] = 5] = "bottom";
  Direction92[Direction92["bottomLeft"] = 6] = "bottomLeft";
  Direction92[Direction92["left"] = 7] = "left";
  Direction92[Direction92["center"] = 8] = "center";
  Direction92[Direction92["top-left"] = 0] = "top-left";
  Direction92[Direction92["top-right"] = 2] = "top-right";
  Direction92[Direction92["bottom-right"] = 4] = "bottom-right";
  Direction92[Direction92["bottom-left"] = 6] = "bottom-left";
})(Direction9 || (Direction9 = {}));
var directionData = [
  { x: 0, y: 0 },
  { x: 0.5, y: 0 },
  { x: 1, y: 0 },
  { x: 1, y: 0.5 },
  { x: 1, y: 1 },
  { x: 0.5, y: 1 },
  { x: 0, y: 1 },
  { x: 0, y: 0.5 },
  { x: 0.5, y: 0.5 }
];
directionData.forEach((item) => item.type = "percent");
var AroundHelper = {
  directionData,
  tempPoint: {},
  get,
  toPoint(around, bounds2, to, onlySize, pointBounds) {
    const point2 = get(around);
    to.x = point2.x;
    to.y = point2.y;
    if (point2.type === "percent") {
      to.x *= bounds2.width;
      to.y *= bounds2.height;
      if (pointBounds) {
        to.x -= pointBounds.x;
        to.y -= pointBounds.y;
        if (point2.x)
          to.x -= point2.x === 1 ? pointBounds.width : point2.x === 0.5 ? point2.x * pointBounds.width : 0;
        if (point2.y)
          to.y -= point2.y === 1 ? pointBounds.height : point2.y === 0.5 ? point2.y * pointBounds.height : 0;
      }
    }
    if (!onlySize) {
      to.x += bounds2.x;
      to.y += bounds2.y;
    }
  }
};
function get(around) {
  return typeof around === "string" ? directionData[Direction9[around]] : around;
}
var { toPoint: toPoint$1 } = AroundHelper;
var AlignHelper = {
  toPoint(align, contentBounds, bounds2, to, onlySize) {
    toPoint$1(align, bounds2, to, onlySize, contentBounds);
  }
};
var StringNumberMap = {
  "0": 1,
  "1": 1,
  "2": 1,
  "3": 1,
  "4": 1,
  "5": 1,
  "6": 1,
  "7": 1,
  "8": 1,
  "9": 1,
  ".": 1,
  "e": 1,
  "E": 1
};
var Debug = class _Debug {
  constructor(name) {
    this.repeatMap = {};
    this.name = name;
  }
  static get(name) {
    return new _Debug(name);
  }
  static set filter(name) {
    this.filterList = getNameList(name);
  }
  static set exclude(name) {
    this.excludeList = getNameList(name);
  }
  log(...messages) {
    if (D$4.enable) {
      if (D$4.filterList.length && D$4.filterList.every((name) => name !== this.name))
        return;
      if (D$4.excludeList.length && D$4.excludeList.some((name) => name === this.name))
        return;
      console.log("%c" + this.name, "color:#21ae62", ...messages);
    }
  }
  tip(...messages) {
    if (D$4.enable)
      this.warn(...messages);
  }
  warn(...messages) {
    if (D$4.showWarn)
      console.warn(this.name, ...messages);
  }
  repeat(name, ...messages) {
    if (!this.repeatMap[name]) {
      this.warn("repeat:" + name, ...messages);
      this.repeatMap[name] = true;
    }
  }
  error(...messages) {
    try {
      throw new Error();
    } catch (e) {
      console.error(this.name, ...messages, e);
    }
  }
};
Debug.filterList = [];
Debug.excludeList = [];
Debug.showWarn = true;
function getNameList(name) {
  if (!name)
    name = [];
  else if (typeof name === "string")
    name = [name];
  return name;
}
var D$4 = Debug;
var debug$8 = Debug.get("RunTime");
var Run = {
  currentId: 0,
  currentName: "",
  idMap: {},
  nameMap: {},
  nameToIdMap: {},
  start(name, microsecond) {
    const id = IncrementId.create(IncrementId.RUNTIME);
    R.currentId = R.idMap[id] = microsecond ? performance.now() : Date.now();
    R.currentName = R.nameMap[id] = name;
    R.nameToIdMap[name] = id;
    return id;
  },
  end(id, microsecond) {
    const time = R.idMap[id], name = R.nameMap[id];
    const duration = microsecond ? (performance.now() - time) / 1e3 : Date.now() - time;
    R.idMap[id] = R.nameMap[id] = R.nameToIdMap[name] = void 0;
    debug$8.log(name, duration, "ms");
  },
  endOfName(name, microsecond) {
    const id = R.nameToIdMap[name];
    if (id !== void 0)
      R.end(id, microsecond);
  }
};
var R = Run;
function needPlugin(name) {
  console.error("need plugin: @leafer-in/" + name);
}
var debug$7 = Debug.get("UICreator");
var UICreator = {
  list: {},
  register(UI3) {
    const { __tag: tag } = UI3.prototype;
    if (list$1[tag])
      debug$7.repeat(tag);
    list$1[tag] = UI3;
  },
  get(tag, data, x, y, width, height) {
    if (!list$1[tag])
      debug$7.error("not register " + tag);
    const ui2 = new list$1[tag](data);
    if (x !== void 0) {
      ui2.x = x;
      if (y)
        ui2.y = y;
      if (width)
        ui2.width = width;
      if (height)
        ui2.height = height;
    }
    return ui2;
  }
};
var { list: list$1 } = UICreator;
var debug$6 = Debug.get("EventCreator");
var EventCreator = {
  nameList: {},
  register(Event2) {
    let name;
    Object.keys(Event2).forEach((key) => {
      name = Event2[key];
      if (typeof name === "string")
        nameList[name] && debug$6.repeat(name), nameList[name] = Event2;
    });
  },
  changeName(oldName, newName) {
    const Event2 = nameList[oldName];
    if (Event2) {
      const constName = Object.keys(Event2).find((key) => Event2[key] === oldName);
      if (constName) {
        Event2[constName] = newName;
        nameList[newName] = Event2;
      }
    }
  },
  has(type) {
    return !!this.nameList[type];
  },
  get(type, ...params) {
    return new nameList[type](...params);
  }
};
var { nameList } = EventCreator;
var CanvasManager = class {
  constructor() {
    this.list = [];
  }
  add(canvas3) {
    canvas3.manager = this;
    this.list.push(canvas3);
  }
  get(size) {
    let old;
    const { list: list3 } = this;
    for (let i = 0, len = list3.length; i < len; i++) {
      old = list3[i];
      if (old.recycled && old.isSameSize(size)) {
        old.recycled = false;
        old.manager || (old.manager = this);
        return old;
      }
    }
    const canvas3 = Creator.canvas(size);
    this.add(canvas3);
    return canvas3;
  }
  recycle(old) {
    old.recycled = true;
  }
  clearRecycled() {
    let canvas3;
    const filter = [];
    for (let i = 0, len = this.list.length; i < len; i++) {
      canvas3 = this.list[i];
      canvas3.recycled ? canvas3.destroy() : filter.push(canvas3);
    }
    this.list = filter;
  }
  clear() {
    this.list.forEach((item) => {
      item.destroy();
    });
    this.list.length = 0;
  }
  destroy() {
    this.clear();
  }
};
var DataHelper = {
  default(t2, defaultData) {
    assign(defaultData, t2);
    assign(t2, defaultData);
    return t2;
  },
  assign(t2, merge) {
    let value;
    Object.keys(merge).forEach((key) => {
      var _a;
      value = merge[key];
      if ((value === null || value === void 0 ? void 0 : value.constructor) === Object) {
        ((_a = t2[key]) === null || _a === void 0 ? void 0 : _a.constructor) === Object ? assign(t2[key], merge[key]) : t2[key] = merge[key];
      } else {
        t2[key] = merge[key];
      }
    });
  },
  copyAttrs(t2, from, include) {
    include.forEach((key) => {
      if (from[key] !== void 0)
        t2[key] = from[key];
    });
    return t2;
  },
  clone(data) {
    return JSON.parse(JSON.stringify(data));
  },
  toMap(list3) {
    const map = {};
    for (let i = 0, len = list3.length; i < len; i++)
      map[list3[i]] = true;
    return map;
  }
};
var { assign } = DataHelper;
var LeafData = class {
  get __useNaturalRatio() {
    return true;
  }
  get __isLinePath() {
    const { path } = this;
    return path && path.length === 6 && path[0] === 1;
  }
  get __blendMode() {
    if (this.eraser && this.eraser !== "path")
      return "destination-out";
    const { blendMode } = this;
    return blendMode === "pass-through" ? null : blendMode;
  }
  constructor(leaf2) {
    this.__leaf = leaf2;
  }
  __get(name) {
    if (this.__input) {
      const value = this.__input[name];
      if (value !== void 0)
        return value;
    }
    return this[name];
  }
  __getData() {
    const data = { tag: this.__leaf.tag }, { __input } = this;
    let inputValue;
    for (let key in this) {
      if (key[0] !== "_") {
        inputValue = __input ? __input[key] : void 0;
        data[key] = inputValue === void 0 ? this[key] : inputValue;
      }
    }
    return data;
  }
  __setInput(name, value) {
    this.__input || (this.__input = {});
    this.__input[name] = value;
  }
  __getInput(name) {
    if (this.__input) {
      const value = this.__input[name];
      if (value !== void 0)
        return value;
    }
    if (name === "path" && !this.__pathInputed)
      return;
    return this["_" + name];
  }
  __removeInput(name) {
    if (this.__input && this.__input[name] !== void 0)
      this.__input[name] = void 0;
  }
  __getInputData(names, options) {
    const data = {};
    if (names) {
      if (names instanceof Array) {
        for (let name of names)
          data[name] = this.__getInput(name);
      } else {
        for (let name in names)
          data[name] = this.__getInput(name);
      }
    } else {
      let value, inputValue, { __input } = this;
      data.tag = this.__leaf.tag;
      for (let key in this) {
        if (key[0] !== "_") {
          value = this["_" + key];
          if (value !== void 0) {
            if (key === "path" && !this.__pathInputed)
              continue;
            inputValue = __input ? __input[key] : void 0;
            data[key] = inputValue === void 0 ? value : inputValue;
          }
        }
      }
    }
    if (options) {
      if (options.matrix) {
        const { a: a2, b, c: c2, d, e, f } = this.__leaf.__localMatrix;
        data.matrix = { a: a2, b, c: c2, d, e, f };
      }
    }
    return data;
  }
  __setMiddle(name, value) {
    this.__middle || (this.__middle = {});
    this.__middle[name] = value;
  }
  __getMiddle(name) {
    return this.__middle && this.__middle[name];
  }
  __checkSingle() {
    const t2 = this;
    if (t2.blendMode === "pass-through") {
      const leaf2 = this.__leaf;
      if (t2.opacity < 1 && (leaf2.isBranch || t2.__hasMultiPaint) || leaf2.__hasEraser || t2.eraser) {
        t2.__single = true;
      } else if (t2.__single) {
        t2.__single = false;
      }
    } else {
      t2.__single = true;
    }
  }
  __removeNaturalSize() {
    this.__naturalWidth = this.__naturalHeight = void 0;
  }
  destroy() {
    this.__input = this.__middle = null;
  }
};
var Answer;
(function(Answer2) {
  Answer2[Answer2["No"] = 0] = "No";
  Answer2[Answer2["Yes"] = 1] = "Yes";
  Answer2[Answer2["NoAndSkip"] = 2] = "NoAndSkip";
  Answer2[Answer2["YesAndSkip"] = 3] = "YesAndSkip";
})(Answer || (Answer = {}));
var emptyData = {};
function isNull(value) {
  return value === void 0 || value === null;
}
function __decorate(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function contextAttr(realName) {
  return (target, key) => {
    if (!realName)
      realName = key;
    Object.defineProperty(target, key, {
      get() {
        return this.context[realName];
      },
      set(value) {
        this.context[realName] = value;
      }
    });
  };
}
var contextMethodNameList = [];
function contextMethod() {
  return (_target, key) => {
    contextMethodNameList.push(key);
  };
}
var emptyArray = [];
var Canvas = class {
  set blendMode(value) {
    if (value === "normal")
      value = "source-over";
    this.context.globalCompositeOperation = value;
  }
  get blendMode() {
    return this.context.globalCompositeOperation;
  }
  set dashPattern(value) {
    this.context.setLineDash(value || emptyArray);
  }
  get dashPattern() {
    return this.context.getLineDash();
  }
  __bindContext() {
    let method;
    contextMethodNameList.forEach((name) => {
      method = this.context[name];
      if (method)
        this[name] = method.bind(this.context);
    });
    this.textBaseline = "alphabetic";
  }
  setTransform(_a, _b, _c, _d, _e, _f) {
  }
  resetTransform() {
  }
  getTransform() {
    return void 0;
  }
  save() {
  }
  restore() {
  }
  transform(a2, b, c2, d, e, f) {
    if (typeof a2 === "object") {
      this.context.transform(a2.a, a2.b, a2.c, a2.d, a2.e, a2.f);
    } else {
      this.context.transform(a2, b, c2, d, e, f);
    }
  }
  translate(_x, _y) {
  }
  scale(_x, _y) {
  }
  rotate(_angle) {
  }
  fill(_path2d, _rule) {
  }
  stroke(_path2d) {
  }
  clip(_path2d, _rule) {
  }
  fillRect(_x, _y, _width, _height) {
  }
  strokeRect(_x, _y, _width, _height) {
  }
  clearRect(_x, _y, _width, _height) {
  }
  drawImage(image2, sx, sy, sw, sh, dx, dy, dw, dh) {
    switch (arguments.length) {
      case 9:
        if (sx < 0) {
          const d = -sx / sw * dw;
          sw += sx;
          sx = 0;
          dx += d;
          dw -= d;
        }
        if (sy < 0) {
          const d = -sy / sh * dh;
          sh += sy;
          sy = 0;
          dy += d;
          dh -= d;
        }
        this.context.drawImage(image2, sx, sy, sw, sh, dx, dy, dw, dh);
        break;
      case 5:
        this.context.drawImage(image2, sx, sy, sw, sh);
        break;
      case 3:
        this.context.drawImage(image2, sx, sy);
    }
  }
  beginPath() {
  }
  moveTo(_x, _y) {
  }
  lineTo(_x, _y) {
  }
  bezierCurveTo(_cp1x, _cp1y, _cp2x, _cp2y, _x, _y) {
  }
  quadraticCurveTo(_cpx, _cpy, _x, _y) {
  }
  closePath() {
  }
  arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {
  }
  arcTo(_x1, _y1, _x2, _y2, _radius) {
  }
  ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {
  }
  rect(_x, _y, _width, _height) {
  }
  roundRect(_x, _y, _width, _height, _radius) {
  }
  createConicGradient(_startAngle, _x, _y) {
    return void 0;
  }
  createLinearGradient(_x0, _y0, _x1, _y1) {
    return void 0;
  }
  createPattern(_image, _repetition) {
    return void 0;
  }
  createRadialGradient(_x0, _y0, _r0, _x1, _y1, _r1) {
    return void 0;
  }
  fillText(_text, _x, _y, _maxWidth) {
  }
  measureText(_text) {
    return void 0;
  }
  strokeText(_text, _x, _y, _maxWidth) {
  }
  destroy() {
    this.context = null;
  }
};
__decorate([
  contextAttr("imageSmoothingEnabled")
], Canvas.prototype, "smooth", void 0);
__decorate([
  contextAttr("imageSmoothingQuality")
], Canvas.prototype, "smoothLevel", void 0);
__decorate([
  contextAttr("globalAlpha")
], Canvas.prototype, "opacity", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fillStyle", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "strokeStyle", void 0);
__decorate([
  contextAttr("lineWidth")
], Canvas.prototype, "strokeWidth", void 0);
__decorate([
  contextAttr("lineCap")
], Canvas.prototype, "strokeCap", void 0);
__decorate([
  contextAttr("lineJoin")
], Canvas.prototype, "strokeJoin", void 0);
__decorate([
  contextAttr("lineDashOffset")
], Canvas.prototype, "dashOffset", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "miterLimit", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowBlur", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowColor", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowOffsetX", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "shadowOffsetY", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "filter", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "font", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fontKerning", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fontStretch", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "fontVariantCaps", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "textAlign", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "textBaseline", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "textRendering", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "wordSpacing", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "letterSpacing", void 0);
__decorate([
  contextAttr()
], Canvas.prototype, "direction", void 0);
__decorate([
  contextMethod()
], Canvas.prototype, "setTransform", null);
__decorate([
  contextMethod()
], Canvas.prototype, "resetTransform", null);
__decorate([
  contextMethod()
], Canvas.prototype, "getTransform", null);
__decorate([
  contextMethod()
], Canvas.prototype, "save", null);
__decorate([
  contextMethod()
], Canvas.prototype, "restore", null);
__decorate([
  contextMethod()
], Canvas.prototype, "translate", null);
__decorate([
  contextMethod()
], Canvas.prototype, "scale", null);
__decorate([
  contextMethod()
], Canvas.prototype, "rotate", null);
__decorate([
  contextMethod()
], Canvas.prototype, "fill", null);
__decorate([
  contextMethod()
], Canvas.prototype, "stroke", null);
__decorate([
  contextMethod()
], Canvas.prototype, "clip", null);
__decorate([
  contextMethod()
], Canvas.prototype, "fillRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "strokeRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "clearRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "beginPath", null);
__decorate([
  contextMethod()
], Canvas.prototype, "moveTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "lineTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "bezierCurveTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "quadraticCurveTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "closePath", null);
__decorate([
  contextMethod()
], Canvas.prototype, "arc", null);
__decorate([
  contextMethod()
], Canvas.prototype, "arcTo", null);
__decorate([
  contextMethod()
], Canvas.prototype, "ellipse", null);
__decorate([
  contextMethod()
], Canvas.prototype, "rect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "roundRect", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createConicGradient", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createLinearGradient", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createPattern", null);
__decorate([
  contextMethod()
], Canvas.prototype, "createRadialGradient", null);
__decorate([
  contextMethod()
], Canvas.prototype, "fillText", null);
__decorate([
  contextMethod()
], Canvas.prototype, "measureText", null);
__decorate([
  contextMethod()
], Canvas.prototype, "strokeText", null);
var { copy: copy$5 } = MatrixHelper;
var minSize = { width: 1, height: 1, pixelRatio: 1 };
var canvasSizeAttrs = ["width", "height", "pixelRatio"];
var LeaferCanvasBase = class extends Canvas {
  get width() {
    return this.size.width;
  }
  get height() {
    return this.size.height;
  }
  get pixelRatio() {
    return this.size.pixelRatio;
  }
  get pixelWidth() {
    return this.width * this.pixelRatio;
  }
  get pixelHeight() {
    return this.height * this.pixelRatio;
  }
  get allowBackgroundColor() {
    return this.view && this.parentView;
  }
  constructor(config2, manager) {
    super();
    this.size = {};
    this.worldTransform = {};
    if (!config2)
      config2 = minSize;
    if (!config2.pixelRatio)
      config2.pixelRatio = Platform.devicePixelRatio;
    this.manager = manager;
    this.innerId = IncrementId.create(IncrementId.CNAVAS);
    const { width, height, pixelRatio } = config2;
    this.autoLayout = !width || !height;
    this.size.pixelRatio = pixelRatio;
    this.config = config2;
    this.init();
  }
  init() {
  }
  __createContext() {
    const { view } = this;
    const { contextSettings } = this.config;
    this.context = contextSettings ? view.getContext("2d", contextSettings) : view.getContext("2d");
    this.__bindContext();
  }
  export(_filename, _options) {
    return void 0;
  }
  toBlob(_type, _quality) {
    return void 0;
  }
  toDataURL(_type, _quality) {
    return void 0;
  }
  saveAs(_filename, _quality) {
    return void 0;
  }
  resize(size) {
    if (this.isSameSize(size))
      return;
    let takeCanvas;
    if (this.context && !this.unreal && this.width) {
      takeCanvas = this.getSameCanvas();
      takeCanvas.copyWorld(this);
    }
    const s2 = this.size;
    DataHelper.copyAttrs(s2, size, canvasSizeAttrs);
    canvasSizeAttrs.forEach((key) => s2[key] || (s2[key] = 1));
    this.bounds = new Bounds(0, 0, this.width, this.height);
    if (this.context && !this.unreal) {
      this.updateViewSize();
      this.smooth = this.config.smooth;
    }
    this.updateClientBounds();
    if (this.context && !this.unreal && takeCanvas) {
      this.clearWorld(takeCanvas.bounds);
      this.copyWorld(takeCanvas);
      takeCanvas.recycle();
    }
  }
  updateViewSize() {
  }
  updateClientBounds() {
  }
  getClientBounds(update) {
    if (update)
      this.updateClientBounds();
    return this.clientBounds || this.bounds;
  }
  startAutoLayout(_autoBounds, _listener) {
  }
  stopAutoLayout() {
  }
  setCursor(_cursor) {
  }
  setWorld(matrix3, parentMatrix) {
    const { pixelRatio } = this;
    const w = this.worldTransform;
    if (parentMatrix) {
      const { a: a2, b, c: c2, d, e, f } = parentMatrix;
      this.setTransform(w.a = (matrix3.a * a2 + matrix3.b * c2) * pixelRatio, w.b = (matrix3.a * b + matrix3.b * d) * pixelRatio, w.c = (matrix3.c * a2 + matrix3.d * c2) * pixelRatio, w.d = (matrix3.c * b + matrix3.d * d) * pixelRatio, w.e = (matrix3.e * a2 + matrix3.f * c2 + e) * pixelRatio, w.f = (matrix3.e * b + matrix3.f * d + f) * pixelRatio);
    } else {
      this.setTransform(w.a = matrix3.a * pixelRatio, w.b = matrix3.b * pixelRatio, w.c = matrix3.c * pixelRatio, w.d = matrix3.d * pixelRatio, w.e = matrix3.e * pixelRatio, w.f = matrix3.f * pixelRatio);
    }
  }
  useWorldTransform(worldTransform) {
    if (worldTransform)
      this.worldTransform = worldTransform;
    const w = this.worldTransform;
    if (w)
      this.setTransform(w.a, w.b, w.c, w.d, w.e, w.f);
  }
  setStroke(color, strokeWidth, options) {
    if (strokeWidth)
      this.strokeWidth = strokeWidth;
    if (color)
      this.strokeStyle = color;
    if (options)
      this.setStrokeOptions(options);
  }
  setStrokeOptions(options) {
    this.strokeCap = options.strokeCap === "none" ? "butt" : options.strokeCap;
    this.strokeJoin = options.strokeJoin;
    this.dashPattern = options.dashPattern;
    this.dashOffset = options.dashOffset;
    this.miterLimit = options.miterLimit;
  }
  saveBlendMode(blendMode) {
    this.savedBlendMode = this.blendMode;
    this.blendMode = blendMode;
  }
  restoreBlendMode() {
    this.blendMode = this.savedBlendMode;
  }
  hitFill(_point, _fillRule) {
    return true;
  }
  hitStroke(_point, _strokeWidth) {
    return true;
  }
  hitPixel(_radiusPoint, _offset, _scale = 1) {
    return true;
  }
  setWorldShadow(x, y, blur2, color) {
    const { pixelRatio } = this;
    this.shadowOffsetX = x * pixelRatio;
    this.shadowOffsetY = y * pixelRatio;
    this.shadowBlur = blur2 * pixelRatio;
    this.shadowColor = color || "black";
  }
  setWorldBlur(blur2) {
    const { pixelRatio } = this;
    this.filter = `blur(${blur2 * pixelRatio}px)`;
  }
  copyWorld(canvas3, from, to, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    if (from) {
      const { pixelRatio } = this;
      if (!to)
        to = from;
      this.drawImage(canvas3.view, from.x * pixelRatio, from.y * pixelRatio, from.width * pixelRatio, from.height * pixelRatio, to.x * pixelRatio, to.y * pixelRatio, to.width * pixelRatio, to.height * pixelRatio);
    } else {
      this.drawImage(canvas3.view, 0, 0);
    }
    if (blendMode)
      this.blendMode = "source-over";
  }
  copyWorldToInner(canvas3, fromWorld, toInnerBounds, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    if (fromWorld.b || fromWorld.c) {
      this.save();
      this.resetTransform();
      this.copyWorld(canvas3, fromWorld, BoundsHelper.tempToOuterOf(toInnerBounds, fromWorld));
      this.restore();
    } else {
      const { pixelRatio } = this;
      this.drawImage(canvas3.view, fromWorld.x * pixelRatio, fromWorld.y * pixelRatio, fromWorld.width * pixelRatio, fromWorld.height * pixelRatio, toInnerBounds.x, toInnerBounds.y, toInnerBounds.width, toInnerBounds.height);
    }
    if (blendMode)
      this.blendMode = "source-over";
  }
  copyWorldByReset(canvas3, from, to, blendMode, onlyResetTransform) {
    this.resetTransform();
    this.copyWorld(canvas3, from, to, blendMode);
    if (!onlyResetTransform)
      this.useWorldTransform();
  }
  useGrayscaleAlpha(bounds2) {
    this.setTempBounds(bounds2, true, true);
    let alpha, pixel;
    const { context } = this, imageData = context.getImageData(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height), { data } = imageData;
    for (let i = 0, len = data.length; i < len; i += 4) {
      pixel = data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114;
      if (alpha = data[i + 3])
        data[i + 3] = alpha === 255 ? pixel : alpha * (pixel / 255);
    }
    context.putImageData(imageData, tempBounds.x, tempBounds.y);
  }
  useMask(maskCanvas, fromBounds, toBounds4) {
    this.copyWorld(maskCanvas, fromBounds, toBounds4, "destination-in");
  }
  useEraser(eraserCanvas, fromBounds, toBounds4) {
    this.copyWorld(eraserCanvas, fromBounds, toBounds4, "destination-out");
  }
  fillWorld(bounds2, color, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    this.fillStyle = color;
    this.setTempBounds(bounds2);
    this.fillRect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
    if (blendMode)
      this.blendMode = "source-over";
  }
  strokeWorld(bounds2, color, blendMode) {
    if (blendMode)
      this.blendMode = blendMode;
    this.strokeStyle = color;
    this.setTempBounds(bounds2);
    this.strokeRect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
    if (blendMode)
      this.blendMode = "source-over";
  }
  clearWorld(bounds2, ceilPixel) {
    this.setTempBounds(bounds2, ceilPixel);
    this.clearRect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
  }
  clipWorld(bounds2, ceilPixel) {
    this.beginPath();
    this.setTempBounds(bounds2, ceilPixel);
    this.rect(tempBounds.x, tempBounds.y, tempBounds.width, tempBounds.height);
    this.clip();
  }
  clear() {
    const { pixelRatio } = this;
    this.clearRect(0, 0, this.width * pixelRatio + 2, this.height * pixelRatio + 2);
  }
  setTempBounds(bounds2, ceil3, intersect) {
    tempBounds.set(bounds2);
    if (intersect)
      tempBounds.intersect(this.bounds);
    tempBounds.scale(this.pixelRatio);
    if (ceil3)
      tempBounds.ceil();
  }
  isSameSize(size) {
    return this.width === size.width && this.height === size.height && this.pixelRatio === size.pixelRatio;
  }
  getSameCanvas(useSameWorldTransform, useSameSmooth) {
    const canvas3 = this.manager ? this.manager.get(this.size) : Creator.canvas(Object.assign({}, this.size));
    canvas3.save();
    if (useSameWorldTransform)
      copy$5(canvas3.worldTransform, this.worldTransform), canvas3.useWorldTransform();
    if (useSameSmooth)
      canvas3.smooth = this.smooth;
    return canvas3;
  }
  recycle(clearBounds) {
    if (!this.recycled) {
      this.restore();
      clearBounds ? this.clearWorld(clearBounds, true) : this.clear();
      this.manager ? this.manager.recycle(this) : this.destroy();
    }
  }
  updateRender(_bounds) {
  }
  unrealCanvas() {
  }
  destroy() {
    this.manager = this.view = this.parentView = null;
  }
};
var PathHelper = {
  creator: {},
  parse(_pathString, _curveMode) {
    return void 0;
  },
  convertToCanvasData(_old, _curveMode) {
    return void 0;
  }
};
var CanvasCommandOnlyMap = {
  N: 21,
  D: 22,
  X: 23,
  G: 24,
  F: 25,
  O: 26,
  P: 27,
  U: 28
};
var PathCommandMap = Object.assign({ M: 1, m: 10, L: 2, l: 20, H: 3, h: 30, V: 4, v: 40, C: 5, c: 50, S: 6, s: 60, Q: 7, q: 70, T: 8, t: 80, A: 9, a: 90, Z: 11, z: 11, R: 12 }, CanvasCommandOnlyMap);
var PathCommandLengthMap = {
  M: 3,
  m: 3,
  L: 3,
  l: 3,
  H: 2,
  h: 2,
  V: 2,
  v: 2,
  C: 7,
  c: 7,
  S: 5,
  s: 5,
  Q: 5,
  q: 5,
  T: 3,
  t: 3,
  A: 8,
  a: 8,
  Z: 1,
  z: 1,
  N: 5,
  D: 9,
  X: 6,
  G: 9,
  F: 5,
  O: 7,
  P: 4,
  U: 6
};
var NeedConvertToCanvasCommandMap = {
  m: 10,
  l: 20,
  H: 3,
  h: 30,
  V: 4,
  v: 40,
  c: 50,
  S: 6,
  s: 60,
  q: 70,
  T: 8,
  t: 80,
  A: 9,
  a: 90
};
var NeedConvertToCurveCommandMap = Object.assign(Object.assign({}, NeedConvertToCanvasCommandMap), CanvasCommandOnlyMap);
var P$4 = PathCommandMap;
var PathNumberCommandMap = {};
for (let key in P$4) {
  PathNumberCommandMap[P$4[key]] = key;
}
var PathNumberCommandLengthMap = {};
for (let key in P$4) {
  PathNumberCommandLengthMap[P$4[key]] = PathCommandLengthMap[key];
}
var RectHelper = {
  drawRoundRect(drawer, x, y, width, height, cornerRadius) {
    const data = MathHelper.fourNumber(cornerRadius, Math.min(width / 2, height / 2));
    const right3 = x + width;
    const bottom3 = y + height;
    data[0] ? drawer.moveTo(x + data[0], y) : drawer.moveTo(x, y);
    data[1] ? drawer.arcTo(right3, y, right3, bottom3, data[1]) : drawer.lineTo(right3, y);
    data[2] ? drawer.arcTo(right3, bottom3, x, bottom3, data[2]) : drawer.lineTo(right3, bottom3);
    data[3] ? drawer.arcTo(x, bottom3, x, y, data[3]) : drawer.lineTo(x, bottom3);
    data[0] ? drawer.arcTo(x, y, right3, y, data[0]) : drawer.lineTo(x, y);
  }
};
var { sin: sin$1, cos: cos$1, atan2: atan2$1, ceil, abs: abs$1, PI, sqrt: sqrt$1, pow } = Math;
var { setPoint: setPoint$1, addPoint: addPoint$1 } = TwoPointBoundsHelper;
var { set, toNumberPoints } = PointHelper;
var { M: M$5, L: L$6, C: C$5, Q: Q$4, Z: Z$5 } = PathCommandMap;
var tempPoint$1 = {};
var BezierHelper = {
  points(data, originPoints, curve, close) {
    let points = toNumberPoints(originPoints);
    data.push(M$5, points[0], points[1]);
    if (curve && points.length > 5) {
      let aX, aY, bX, bY, cX, cY, c1X, c1Y, c2X, c2Y;
      let ba, cb, d, len = points.length;
      const t2 = curve === true ? 0.5 : curve;
      if (close) {
        points = [points[len - 2], points[len - 1], ...points, points[0], points[1], points[2], points[3]];
        len = points.length;
      }
      for (let i = 2; i < len - 2; i += 2) {
        aX = points[i - 2];
        aY = points[i - 1];
        bX = points[i];
        bY = points[i + 1];
        cX = points[i + 2];
        cY = points[i + 3];
        ba = sqrt$1(pow(bX - aX, 2) + pow(bY - aY, 2));
        cb = sqrt$1(pow(cX - bX, 2) + pow(cY - bY, 2));
        d = ba + cb;
        ba = t2 * ba / d;
        cb = t2 * cb / d;
        cX -= aX;
        cY -= aY;
        c1X = bX - ba * cX;
        c1Y = bY - ba * cY;
        if (i === 2) {
          if (!close)
            data.push(Q$4, c1X, c1Y, bX, bY);
        } else {
          data.push(C$5, c2X, c2Y, c1X, c1Y, bX, bY);
        }
        c2X = bX + cb * cX;
        c2Y = bY + cb * cY;
      }
      if (!close)
        data.push(Q$4, c2X, c2Y, points[len - 2], points[len - 1]);
    } else {
      for (let i = 2, len = points.length; i < len; i += 2) {
        data.push(L$6, points[i], points[i + 1]);
      }
    }
    if (close)
      data.push(Z$5);
  },
  rect(data, x, y, width, height) {
    PathHelper.creator.path = data;
    PathHelper.creator.moveTo(x, y).lineTo(x + width, y).lineTo(x + width, y + height).lineTo(x, y + height).lineTo(x, y);
  },
  roundRect(data, x, y, width, height, radius2) {
    PathHelper.creator.path = [];
    RectHelper.drawRoundRect(PathHelper.creator, x, y, width, height, radius2);
    data.push(...PathHelper.convertToCanvasData(PathHelper.creator.path, true));
  },
  arcTo(data, fromX, fromY, x1, y1, toX, toY, radius2, setPointBounds2, setEndPoint2, setStartPoint) {
    const BAx = x1 - fromX;
    const BAy = y1 - fromY;
    const CBx = toX - x1;
    const CBy = toY - y1;
    let startRadian = atan2$1(BAy, BAx);
    let endRadian = atan2$1(CBy, CBx);
    let totalRadian = endRadian - startRadian;
    if (totalRadian < 0)
      totalRadian += PI2;
    if (totalRadian === PI || abs$1(BAx + BAy) < 1e-12 || abs$1(CBx + CBy) < 1e-12) {
      if (data)
        data.push(L$6, x1, y1);
      if (setPointBounds2) {
        setPoint$1(setPointBounds2, fromX, fromY);
        addPoint$1(setPointBounds2, x1, y1);
      }
      if (setStartPoint)
        set(setStartPoint, fromX, fromY);
      if (setEndPoint2)
        set(setEndPoint2, x1, y1);
      return;
    }
    const anticlockwise = BAx * CBy - CBx * BAy < 0;
    const sign = anticlockwise ? -1 : 1;
    const c2 = radius2 / cos$1(totalRadian / 2);
    const centerX = x1 + c2 * cos$1(startRadian + totalRadian / 2 + PI_2 * sign);
    const centerY = y1 + c2 * sin$1(startRadian + totalRadian / 2 + PI_2 * sign);
    startRadian -= PI_2 * sign;
    endRadian -= PI_2 * sign;
    return ellipse$5(data, centerX, centerY, radius2, radius2, 0, startRadian / OneRadian, endRadian / OneRadian, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint);
  },
  arc(data, x, y, radius2, startAngle, endAngle, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint) {
    return ellipse$5(data, x, y, radius2, radius2, 0, startAngle, endAngle, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint);
  },
  ellipse(data, cx, cy, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise, setPointBounds2, setEndPoint2, setStartPoint) {
    const rotationRadian = rotation * OneRadian;
    const rotationSin = sin$1(rotationRadian);
    const rotationCos = cos$1(rotationRadian);
    let startRadian = startAngle * OneRadian;
    let endRadian = endAngle * OneRadian;
    if (startRadian > PI)
      startRadian -= PI2;
    if (endRadian < 0)
      endRadian += PI2;
    let totalRadian = endRadian - startRadian;
    if (totalRadian < 0)
      totalRadian += PI2;
    else if (totalRadian > PI2)
      totalRadian -= PI2;
    if (anticlockwise)
      totalRadian -= PI2;
    const parts = ceil(abs$1(totalRadian / PI_2));
    const partRadian = totalRadian / parts;
    const partRadian4Sin = sin$1(partRadian / 4);
    const control = 8 / 3 * partRadian4Sin * partRadian4Sin / sin$1(partRadian / 2);
    endRadian = startRadian + partRadian;
    let startCos = cos$1(startRadian);
    let startSin = sin$1(startRadian);
    let endCos, endSin;
    let x, y, x1, y1, x2, y2;
    let startX = x = rotationCos * radiusX2 * startCos - rotationSin * radiusY2 * startSin;
    let startY = y = rotationSin * radiusX2 * startCos + rotationCos * radiusY2 * startSin;
    let fromX = cx + x, fromY = cy + y;
    if (data)
      data.push(data.length ? L$6 : M$5, fromX, fromY);
    if (setPointBounds2)
      setPoint$1(setPointBounds2, fromX, fromY);
    if (setStartPoint)
      set(setStartPoint, fromX, fromY);
    for (let i = 0; i < parts; i++) {
      endCos = cos$1(endRadian);
      endSin = sin$1(endRadian);
      x = rotationCos * radiusX2 * endCos - rotationSin * radiusY2 * endSin;
      y = rotationSin * radiusX2 * endCos + rotationCos * radiusY2 * endSin;
      x1 = cx + startX - control * (rotationCos * radiusX2 * startSin + rotationSin * radiusY2 * startCos);
      y1 = cy + startY - control * (rotationSin * radiusX2 * startSin - rotationCos * radiusY2 * startCos);
      x2 = cx + x + control * (rotationCos * radiusX2 * endSin + rotationSin * radiusY2 * endCos);
      y2 = cy + y + control * (rotationSin * radiusX2 * endSin - rotationCos * radiusY2 * endCos);
      if (data)
        data.push(C$5, x1, y1, x2, y2, cx + x, cy + y);
      if (setPointBounds2)
        toTwoPointBounds$1(cx + startX, cy + startY, x1, y1, x2, y2, cx + x, cy + y, setPointBounds2, true);
      startX = x;
      startY = y;
      startCos = endCos;
      startSin = endSin;
      startRadian = endRadian;
      endRadian += partRadian;
    }
    if (setEndPoint2)
      set(setEndPoint2, cx + x, cy + y);
  },
  quadraticCurveTo(data, fromX, fromY, x1, y1, toX, toY) {
    data.push(C$5, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY);
  },
  toTwoPointBoundsByQuadraticCurve(fromX, fromY, x1, y1, toX, toY, pointBounds, addMode) {
    toTwoPointBounds$1(fromX, fromY, (fromX + 2 * x1) / 3, (fromY + 2 * y1) / 3, (toX + 2 * x1) / 3, (toY + 2 * y1) / 3, toX, toY, pointBounds, addMode);
  },
  toTwoPointBounds(fromX, fromY, x1, y1, x2, y2, toX, toY, pointBounds, addMode) {
    const tList = [];
    let a2, b, c2, t2, t1, t22, v2, sqrtV;
    let f = fromX, z1 = x1, z2 = x2, o = toX;
    for (let i = 0; i < 2; ++i) {
      if (i == 1) {
        f = fromY, z1 = y1, z2 = y2, o = toY;
      }
      a2 = -3 * f + 9 * z1 - 9 * z2 + 3 * o;
      b = 6 * f - 12 * z1 + 6 * z2;
      c2 = 3 * z1 - 3 * f;
      if (Math.abs(a2) < 1e-12) {
        if (Math.abs(b) < 1e-12)
          continue;
        t2 = -c2 / b;
        if (0 < t2 && t2 < 1)
          tList.push(t2);
        continue;
      }
      v2 = b * b - 4 * c2 * a2;
      sqrtV = Math.sqrt(v2);
      if (v2 < 0)
        continue;
      t1 = (-b + sqrtV) / (2 * a2);
      if (0 < t1 && t1 < 1)
        tList.push(t1);
      t22 = (-b - sqrtV) / (2 * a2);
      if (0 < t22 && t22 < 1)
        tList.push(t22);
    }
    addMode ? addPoint$1(pointBounds, fromX, fromY) : setPoint$1(pointBounds, fromX, fromY);
    addPoint$1(pointBounds, toX, toY);
    for (let i = 0, len = tList.length; i < len; i++) {
      getPointAndSet(tList[i], fromX, fromY, x1, y1, x2, y2, toX, toY, tempPoint$1);
      addPoint$1(pointBounds, tempPoint$1.x, tempPoint$1.y);
    }
  },
  getPointAndSet(t2, fromX, fromY, x1, y1, x2, y2, toX, toY, setPoint3) {
    const o = 1 - t2, a2 = o * o * o, b = 3 * o * o * t2, c2 = 3 * o * t2 * t2, d = t2 * t2 * t2;
    setPoint3.x = a2 * fromX + b * x1 + c2 * x2 + d * toX;
    setPoint3.y = a2 * fromY + b * y1 + c2 * y2 + d * toY;
  },
  getPoint(t2, fromX, fromY, x1, y1, x2, y2, toX, toY) {
    const point2 = {};
    getPointAndSet(t2, fromX, fromY, x1, y1, x2, y2, toX, toY, point2);
    return point2;
  }
};
var { getPointAndSet, toTwoPointBounds: toTwoPointBounds$1, ellipse: ellipse$5 } = BezierHelper;
var { sin, cos, sqrt, atan2 } = Math;
var { ellipse: ellipse$4 } = BezierHelper;
var EllipseHelper = {
  ellipticalArc(data, fromX, fromY, radiusX2, radiusY2, rotation, largeFlag, sweepFlag, toX, toY, curveMode) {
    const halfX = (toX - fromX) / 2;
    const halfY = (toY - fromY) / 2;
    const rotationRadian = rotation * OneRadian;
    const rotationSin = sin(rotationRadian);
    const rotationCos = cos(rotationRadian);
    const px = -rotationCos * halfX - rotationSin * halfY;
    const py = -rotationCos * halfY + rotationSin * halfX;
    const rxSquare = radiusX2 * radiusX2;
    const rySquare = radiusY2 * radiusY2;
    const pySquare = py * py;
    const pxSquare = px * px;
    const a2 = rxSquare * rySquare - rxSquare * pySquare - rySquare * pxSquare;
    let s2 = 0;
    if (a2 < 0) {
      const t2 = sqrt(1 - a2 / (rxSquare * rySquare));
      radiusX2 *= t2;
      radiusY2 *= t2;
    } else {
      s2 = (largeFlag === sweepFlag ? -1 : 1) * sqrt(a2 / (rxSquare * pySquare + rySquare * pxSquare));
    }
    const cx = s2 * radiusX2 * py / radiusY2;
    const cy = -s2 * radiusY2 * px / radiusX2;
    const startRadian = atan2((py - cy) / radiusY2, (px - cx) / radiusX2);
    const endRadian = atan2((-py - cy) / radiusY2, (-px - cx) / radiusX2);
    let totalRadian = endRadian - startRadian;
    if (sweepFlag === 0 && totalRadian > 0) {
      totalRadian -= PI2;
    } else if (sweepFlag === 1 && totalRadian < 0) {
      totalRadian += PI2;
    }
    const centerX = fromX + halfX + rotationCos * cx - rotationSin * cy;
    const centerY = fromY + halfY + rotationSin * cx + rotationCos * cy;
    const anticlockwise = totalRadian < 0 ? 1 : 0;
    if (curveMode || Platform.ellipseToCurve) {
      ellipse$4(data, centerX, centerY, radiusX2, radiusY2, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
    } else {
      if (radiusX2 === radiusY2 && !rotation) {
        data.push(PathCommandMap.O, centerX, centerY, radiusX2, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
      } else {
        data.push(PathCommandMap.G, centerX, centerY, radiusX2, radiusY2, rotation, startRadian / OneRadian, endRadian / OneRadian, anticlockwise);
      }
    }
  }
};
var { M: M$4, m, L: L$5, l, H, h, V, v, C: C$4, c, S, s, Q: Q$3, q, T, t, A, a, Z: Z$4, z, N: N$3, D: D$3, X: X$3, G: G$3, F: F$4, O: O$3, P: P$3, U: U$3 } = PathCommandMap;
var { rect: rect$1, roundRect: roundRect$2, arcTo: arcTo$3, arc: arc$3, ellipse: ellipse$3, quadraticCurveTo: quadraticCurveTo$1 } = BezierHelper;
var { ellipticalArc } = EllipseHelper;
var debug$5 = Debug.get("PathConvert");
var setEndPoint$1 = {};
var PathConvert = {
  current: { dot: 0 },
  stringify(data, floatLength) {
    let i = 0, len = data.length, count, str = "", command, lastCommand;
    while (i < len) {
      command = data[i];
      count = PathNumberCommandLengthMap[command];
      if (command === lastCommand) {
        str += " ";
      } else {
        str += PathNumberCommandMap[command];
      }
      for (let j = 1; j < count; j++) {
        str += MathHelper.float(data[i + j], floatLength);
        j === count - 1 || (str += " ");
      }
      lastCommand = command;
      i += count;
    }
    return str;
  },
  parse(pathString, curveMode) {
    let needConvert, char2, lastChar, num = "";
    const data = [];
    const convertCommand = curveMode ? NeedConvertToCurveCommandMap : NeedConvertToCanvasCommandMap;
    for (let i = 0, len = pathString.length; i < len; i++) {
      char2 = pathString[i];
      if (StringNumberMap[char2]) {
        if (char2 === ".") {
          if (current.dot) {
            pushData(data, num);
            num = "";
          }
          current.dot++;
        }
        if (num === "0" && char2 !== ".") {
          pushData(data, num);
          num = "";
        }
        num += char2;
      } else if (PathCommandMap[char2]) {
        if (num) {
          pushData(data, num);
          num = "";
        }
        current.name = PathCommandMap[char2];
        current.length = PathCommandLengthMap[char2];
        current.index = 0;
        pushData(data, current.name);
        if (!needConvert && convertCommand[char2])
          needConvert = true;
      } else {
        if (char2 === "-" || char2 === "+") {
          if (lastChar === "e" || lastChar === "E") {
            num += char2;
          } else {
            if (num)
              pushData(data, num);
            num = char2;
          }
        } else {
          if (num) {
            pushData(data, num);
            num = "";
          }
        }
      }
      lastChar = char2;
    }
    if (num)
      pushData(data, num);
    return needConvert ? PathConvert.toCanvasData(data, curveMode) : data;
  },
  toCanvasData(old, curveMode) {
    let x = 0, y = 0, x1 = 0, y1 = 0, i = 0, len = old.length, controlX, controlY, command, lastCommand, smooth;
    const data = [];
    while (i < len) {
      command = old[i];
      switch (command) {
        case m:
          old[i + 1] += x;
          old[i + 2] += y;
        case M$4:
          x = old[i + 1];
          y = old[i + 2];
          data.push(M$4, x, y);
          i += 3;
          break;
        case h:
          old[i + 1] += x;
        case H:
          x = old[i + 1];
          data.push(L$5, x, y);
          i += 2;
          break;
        case v:
          old[i + 1] += y;
        case V:
          y = old[i + 1];
          data.push(L$5, x, y);
          i += 2;
          break;
        case l:
          old[i + 1] += x;
          old[i + 2] += y;
        case L$5:
          x = old[i + 1];
          y = old[i + 2];
          data.push(L$5, x, y);
          i += 3;
          break;
        case s:
          old[i + 1] += x;
          old[i + 2] += y;
          old[i + 3] += x;
          old[i + 4] += y;
          command = S;
        case S:
          smooth = lastCommand === C$4 || lastCommand === S;
          x1 = smooth ? x * 2 - controlX : old[i + 1];
          y1 = smooth ? y * 2 - controlY : old[i + 2];
          controlX = old[i + 1];
          controlY = old[i + 2];
          x = old[i + 3];
          y = old[i + 4];
          data.push(C$4, x1, y1, controlX, controlY, x, y);
          i += 5;
          break;
        case c:
          old[i + 1] += x;
          old[i + 2] += y;
          old[i + 3] += x;
          old[i + 4] += y;
          old[i + 5] += x;
          old[i + 6] += y;
          command = C$4;
        case C$4:
          controlX = old[i + 3];
          controlY = old[i + 4];
          x = old[i + 5];
          y = old[i + 6];
          data.push(C$4, old[i + 1], old[i + 2], controlX, controlY, x, y);
          i += 7;
          break;
        case t:
          old[i + 1] += x;
          old[i + 2] += y;
          command = T;
        case T:
          smooth = lastCommand === Q$3 || lastCommand === T;
          controlX = smooth ? x * 2 - controlX : old[i + 1];
          controlY = smooth ? y * 2 - controlY : old[i + 2];
          curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 1], old[i + 2]) : data.push(Q$3, controlX, controlY, old[i + 1], old[i + 2]);
          x = old[i + 1];
          y = old[i + 2];
          i += 3;
          break;
        case q:
          old[i + 1] += x;
          old[i + 2] += y;
          old[i + 3] += x;
          old[i + 4] += y;
          command = Q$3;
        case Q$3:
          controlX = old[i + 1];
          controlY = old[i + 2];
          curveMode ? quadraticCurveTo$1(data, x, y, controlX, controlY, old[i + 3], old[i + 4]) : data.push(Q$3, controlX, controlY, old[i + 3], old[i + 4]);
          x = old[i + 3];
          y = old[i + 4];
          i += 5;
          break;
        case a:
          old[i + 6] += x;
          old[i + 7] += y;
        case A:
          ellipticalArc(data, x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], curveMode);
          x = old[i + 6];
          y = old[i + 7];
          i += 8;
          break;
        case z:
        case Z$4:
          data.push(Z$4);
          i++;
          break;
        case N$3:
          x = old[i + 1];
          y = old[i + 2];
          curveMode ? rect$1(data, x, y, old[i + 3], old[i + 4]) : copyData(data, old, i, 5);
          i += 5;
          break;
        case D$3:
          x = old[i + 1];
          y = old[i + 2];
          curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], [old[i + 5], old[i + 6], old[i + 7], old[i + 8]]) : copyData(data, old, i, 9);
          i += 9;
          break;
        case X$3:
          x = old[i + 1];
          y = old[i + 2];
          curveMode ? roundRect$2(data, x, y, old[i + 3], old[i + 4], old[i + 5]) : copyData(data, old, i, 6);
          i += 6;
          break;
        case G$3:
          ellipse$3(curveMode ? data : copyData(data, old, i, 9), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], old[i + 7], old[i + 8], null, setEndPoint$1);
          x = setEndPoint$1.x;
          y = setEndPoint$1.y;
          i += 9;
          break;
        case F$4:
          curveMode ? ellipse$3(data, old[i + 1], old[i + 2], old[i + 3], old[i + 4], 0, 0, 360, false) : copyData(data, old, i, 5);
          x = old[i + 1] + old[i + 3];
          y = old[i + 2];
          i += 5;
          break;
        case O$3:
          arc$3(curveMode ? data : copyData(data, old, i, 7), old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], old[i + 6], null, setEndPoint$1);
          x = setEndPoint$1.x;
          y = setEndPoint$1.y;
          i += 7;
          break;
        case P$3:
          curveMode ? arc$3(data, old[i + 1], old[i + 2], old[i + 3], 0, 360, false) : copyData(data, old, i, 4);
          x = old[i + 1] + old[i + 3];
          y = old[i + 2];
          i += 4;
          break;
        case U$3:
          arcTo$3(curveMode ? data : copyData(data, old, i, 6), x, y, old[i + 1], old[i + 2], old[i + 3], old[i + 4], old[i + 5], null, setEndPoint$1);
          x = setEndPoint$1.x;
          y = setEndPoint$1.y;
          i += 6;
          break;
        default:
          debug$5.error(`command: ${command} [index:${i}]`, old);
          return data;
      }
      lastCommand = command;
    }
    return data;
  },
  objectToCanvasData(list3) {
    const data = [];
    list3.forEach((item) => {
      switch (item.name) {
        case "M":
          data.push(M$4, item.x, item.y);
          break;
        case "L":
          data.push(L$5, item.x, item.y);
          break;
        case "C":
          data.push(C$4, item.x1, item.y1, item.x2, item.y2, item.x, item.y);
          break;
        case "Q":
          data.push(Q$3, item.x1, item.y1, item.x, item.y);
          break;
        case "Z":
          data.push(Z$4);
      }
    });
    return data;
  },
  copyData(data, old, index, count) {
    for (let i = index, end = index + count; i < end; i++) {
      data.push(old[i]);
    }
  },
  pushData(data, strNum) {
    if (current.index === current.length) {
      current.index = 1;
      data.push(current.name);
    }
    data.push(Number(strNum));
    current.index++;
    current.dot = 0;
  }
};
var { current, pushData, copyData } = PathConvert;
var { M: M$3, L: L$4, C: C$3, Q: Q$2, Z: Z$3, N: N$2, D: D$2, X: X$2, G: G$2, F: F$3, O: O$2, P: P$2, U: U$2 } = PathCommandMap;
var { getMinDistanceFrom, getRadianFrom } = PointHelper;
var { tan, min, abs } = Math;
var startPoint = {};
var PathCommandDataHelper = {
  beginPath(data) {
    data.length = 0;
  },
  moveTo(data, x, y) {
    data.push(M$3, x, y);
  },
  lineTo(data, x, y) {
    data.push(L$4, x, y);
  },
  bezierCurveTo(data, x1, y1, x2, y2, x, y) {
    data.push(C$3, x1, y1, x2, y2, x, y);
  },
  quadraticCurveTo(data, x1, y1, x, y) {
    data.push(Q$2, x1, y1, x, y);
  },
  closePath(data) {
    data.push(Z$3);
  },
  rect(data, x, y, width, height) {
    data.push(N$2, x, y, width, height);
  },
  roundRect(data, x, y, width, height, cornerRadius) {
    if (typeof cornerRadius === "number") {
      data.push(X$2, x, y, width, height, cornerRadius);
    } else {
      const fourCorners = MathHelper.fourNumber(cornerRadius);
      if (fourCorners) {
        data.push(D$2, x, y, width, height, ...fourCorners);
      } else {
        data.push(N$2, x, y, width, height);
      }
    }
  },
  ellipse(data, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    if (rotation === void 0) {
      data.push(F$3, x, y, radiusX2, radiusY2);
    } else {
      if (startAngle === void 0)
        startAngle = 0;
      if (endAngle === void 0)
        endAngle = 360;
      data.push(G$2, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise ? 1 : 0);
    }
  },
  arc(data, x, y, radius2, startAngle, endAngle, anticlockwise) {
    if (startAngle === void 0) {
      data.push(P$2, x, y, radius2);
    } else {
      if (endAngle === void 0)
        endAngle = 360;
      data.push(O$2, x, y, radius2, startAngle, endAngle, anticlockwise ? 1 : 0);
    }
  },
  arcTo(data, x1, y1, x2, y2, radius2, lastX, lastY) {
    if (lastX !== void 0) {
      const maxRadius = tan(getRadianFrom(lastX, lastY, x1, y1, x2, y2) / 2) * (getMinDistanceFrom(lastX, lastY, x1, y1, x2, y2) / 2);
      data.push(U$2, x1, y1, x2, y2, min(radius2, abs(maxRadius)));
    } else {
      data.push(U$2, x1, y1, x2, y2, radius2);
    }
  },
  drawEllipse(data, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    BezierHelper.ellipse(null, x, y, radiusX2, radiusY2, rotation === void 0 ? 0 : rotation, startAngle === void 0 ? 0 : startAngle, endAngle === void 0 ? 360 : endAngle, anticlockwise, null, null, startPoint);
    data.push(M$3, startPoint.x, startPoint.y);
    ellipse$2(data, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise);
  },
  drawArc(data, x, y, radius2, startAngle, endAngle, anticlockwise) {
    BezierHelper.arc(null, x, y, radius2, startAngle === void 0 ? 0 : startAngle, endAngle === void 0 ? 360 : endAngle, anticlockwise, null, null, startPoint);
    data.push(M$3, startPoint.x, startPoint.y);
    arc$2(data, x, y, radius2, startAngle, endAngle, anticlockwise);
  },
  drawPoints(data, points, curve, close) {
    BezierHelper.points(data, points, curve, close);
  }
};
var { ellipse: ellipse$2, arc: arc$2 } = PathCommandDataHelper;
var { moveTo, lineTo, quadraticCurveTo, bezierCurveTo, closePath, beginPath, rect, roundRect: roundRect$1, ellipse: ellipse$1, arc: arc$1, arcTo: arcTo$2, drawEllipse, drawArc, drawPoints } = PathCommandDataHelper;
var PathCreator = class {
  set path(value) {
    this.__path = value;
  }
  get path() {
    return this.__path;
  }
  constructor(path) {
    this.set(path);
  }
  set(path) {
    if (path) {
      this.__path = typeof path === "string" ? PathHelper.parse(path) : path;
    } else {
      this.__path = [];
    }
    return this;
  }
  beginPath() {
    beginPath(this.__path);
    this.paint();
    return this;
  }
  moveTo(x, y) {
    moveTo(this.__path, x, y);
    this.paint();
    return this;
  }
  lineTo(x, y) {
    lineTo(this.__path, x, y);
    this.paint();
    return this;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    bezierCurveTo(this.__path, x1, y1, x2, y2, x, y);
    this.paint();
    return this;
  }
  quadraticCurveTo(x1, y1, x, y) {
    quadraticCurveTo(this.__path, x1, y1, x, y);
    this.paint();
    return this;
  }
  closePath() {
    closePath(this.__path);
    this.paint();
    return this;
  }
  rect(x, y, width, height) {
    rect(this.__path, x, y, width, height);
    this.paint();
    return this;
  }
  roundRect(x, y, width, height, cornerRadius) {
    roundRect$1(this.__path, x, y, width, height, cornerRadius);
    this.paint();
    return this;
  }
  ellipse(x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    ellipse$1(this.__path, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  arc(x, y, radius2, startAngle, endAngle, anticlockwise) {
    arc$1(this.__path, x, y, radius2, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  arcTo(x1, y1, x2, y2, radius2) {
    arcTo$2(this.__path, x1, y1, x2, y2, radius2);
    this.paint();
    return this;
  }
  drawEllipse(x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise) {
    drawEllipse(this.__path, x, y, radiusX2, radiusY2, rotation, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  drawArc(x, y, radius2, startAngle, endAngle, anticlockwise) {
    drawArc(this.__path, x, y, radius2, startAngle, endAngle, anticlockwise);
    this.paint();
    return this;
  }
  drawPoints(points, curve, close) {
    drawPoints(this.__path, points, curve, close);
    this.paint();
    return this;
  }
  clearPath() {
    return this.beginPath();
  }
  paint() {
  }
};
var { M: M$2, L: L$3, C: C$2, Q: Q$1, Z: Z$2, N: N$1, D: D$1, X: X$1, G: G$1, F: F$2, O: O$1, P: P$1, U: U$1 } = PathCommandMap;
var debug$4 = Debug.get("PathDrawer");
var PathDrawer = {
  drawPathByData(drawer, data) {
    if (!data)
      return;
    let command;
    let i = 0, len = data.length;
    while (i < len) {
      command = data[i];
      switch (command) {
        case M$2:
          drawer.moveTo(data[i + 1], data[i + 2]);
          i += 3;
          break;
        case L$3:
          drawer.lineTo(data[i + 1], data[i + 2]);
          i += 3;
          break;
        case C$2:
          drawer.bezierCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);
          i += 7;
          break;
        case Q$1:
          drawer.quadraticCurveTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
          i += 5;
          break;
        case Z$2:
          drawer.closePath();
          i += 1;
          break;
        case N$1:
          drawer.rect(data[i + 1], data[i + 2], data[i + 3], data[i + 4]);
          i += 5;
          break;
        case D$1:
          drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], [data[i + 5], data[i + 6], data[i + 7], data[i + 8]]);
          i += 9;
          break;
        case X$1:
          drawer.roundRect(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
          i += 6;
          break;
        case G$1:
          drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5] * OneRadian, data[i + 6] * OneRadian, data[i + 7] * OneRadian, data[i + 8]);
          i += 9;
          break;
        case F$2:
          drawer.ellipse(data[i + 1], data[i + 2], data[i + 3], data[i + 4], 0, 0, PI2, false);
          i += 5;
          break;
        case O$1:
          drawer.arc(data[i + 1], data[i + 2], data[i + 3], data[i + 4] * OneRadian, data[i + 5] * OneRadian, data[i + 6]);
          i += 7;
          break;
        case P$1:
          drawer.arc(data[i + 1], data[i + 2], data[i + 3], 0, PI2, false);
          i += 4;
          break;
        case U$1:
          drawer.arcTo(data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5]);
          i += 6;
          break;
        default:
          debug$4.error(`command: ${command} [index:${i}]`, data);
          return;
      }
    }
  }
};
var { M: M$1, L: L$2, C: C$1, Q, Z: Z$1, N, D, X, G, F: F$1, O, P, U } = PathCommandMap;
var { toTwoPointBounds, toTwoPointBoundsByQuadraticCurve, arcTo: arcTo$1, arc, ellipse } = BezierHelper;
var { addPointBounds, copy: copy$4, addPoint, setPoint, addBounds, toBounds: toBounds$1 } = TwoPointBoundsHelper;
var debug$3 = Debug.get("PathBounds");
var radius;
var radiusX;
var radiusY;
var tempPointBounds = {};
var setPointBounds = {};
var setEndPoint = {};
var PathBounds = {
  toBounds(data, setBounds) {
    PathBounds.toTwoPointBounds(data, setPointBounds);
    toBounds$1(setPointBounds, setBounds);
  },
  toTwoPointBounds(data, setPointBounds2) {
    if (!data || !data.length)
      return setPoint(setPointBounds2, 0, 0);
    let i = 0, x = 0, y = 0, x1, y1, toX, toY, command;
    const len = data.length;
    while (i < len) {
      command = data[i];
      if (i === 0) {
        if (command === Z$1 || command === C$1 || command === Q) {
          setPoint(setPointBounds2, x, y);
        } else {
          setPoint(setPointBounds2, data[i + 1], data[i + 2]);
        }
      }
      switch (command) {
        case M$1:
        case L$2:
          x = data[i + 1];
          y = data[i + 2];
          addPoint(setPointBounds2, x, y);
          i += 3;
          break;
        case C$1:
          toX = data[i + 5];
          toY = data[i + 6];
          toTwoPointBounds(x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], toX, toY, tempPointBounds);
          addPointBounds(setPointBounds2, tempPointBounds);
          x = toX;
          y = toY;
          i += 7;
          break;
        case Q:
          x1 = data[i + 1];
          y1 = data[i + 2];
          toX = data[i + 3];
          toY = data[i + 4];
          toTwoPointBoundsByQuadraticCurve(x, y, x1, y1, toX, toY, tempPointBounds);
          addPointBounds(setPointBounds2, tempPointBounds);
          x = toX;
          y = toY;
          i += 5;
          break;
        case Z$1:
          i += 1;
          break;
        case N:
          x = data[i + 1];
          y = data[i + 2];
          addBounds(setPointBounds2, x, y, data[i + 3], data[i + 4]);
          i += 5;
          break;
        case D:
        case X:
          x = data[i + 1];
          y = data[i + 2];
          addBounds(setPointBounds2, x, y, data[i + 3], data[i + 4]);
          i += command === D ? 9 : 6;
          break;
        case G:
          ellipse(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], data[i + 7], data[i + 8], tempPointBounds, setEndPoint);
          i === 0 ? copy$4(setPointBounds2, tempPointBounds) : addPointBounds(setPointBounds2, tempPointBounds);
          x = setEndPoint.x;
          y = setEndPoint.y;
          i += 9;
          break;
        case F$1:
          x = data[i + 1];
          y = data[i + 2];
          radiusX = data[i + 3];
          radiusY = data[i + 4];
          addBounds(setPointBounds2, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2);
          x += radiusX;
          i += 5;
          break;
        case O:
          arc(null, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6], tempPointBounds, setEndPoint);
          i === 0 ? copy$4(setPointBounds2, tempPointBounds) : addPointBounds(setPointBounds2, tempPointBounds);
          x = setEndPoint.x;
          y = setEndPoint.y;
          i += 7;
          break;
        case P:
          x = data[i + 1];
          y = data[i + 2];
          radius = data[i + 3];
          addBounds(setPointBounds2, x - radius, y - radius, radius * 2, radius * 2);
          x += radius;
          i += 4;
          break;
        case U:
          arcTo$1(null, x, y, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], tempPointBounds, setEndPoint);
          i === 0 ? copy$4(setPointBounds2, tempPointBounds) : addPointBounds(setPointBounds2, tempPointBounds);
          x = setEndPoint.x;
          y = setEndPoint.y;
          i += 6;
          break;
        default:
          debug$3.error(`command: ${command} [index:${i}]`, data);
          return;
      }
    }
  }
};
var { M, L: L$1, C, Z } = PathCommandMap;
var { getCenterX, getCenterY } = PointHelper;
var { arcTo } = PathCommandDataHelper;
var PathCorner = {
  smooth(data, cornerRadius, _cornerSmoothing) {
    let command;
    let i = 0, x = 0, y = 0, startX = 0, startY = 0, secondX = 0, secondY = 0, lastX = 0, lastY = 0;
    const len = data.length;
    const smooth = [];
    while (i < len) {
      command = data[i];
      switch (command) {
        case M:
          startX = lastX = data[i + 1];
          startY = lastY = data[i + 2];
          i += 3;
          if (data[i] === L$1) {
            secondX = data[i + 1];
            secondY = data[i + 2];
            smooth.push(M, getCenterX(startX, secondX), getCenterY(startY, secondY));
          } else {
            smooth.push(M, startX, startY);
          }
          break;
        case L$1:
          x = data[i + 1];
          y = data[i + 2];
          i += 3;
          switch (data[i]) {
            case L$1:
              arcTo(smooth, x, y, data[i + 1], data[i + 2], cornerRadius, lastX, lastY);
              break;
            case Z:
              arcTo(smooth, x, y, startX, startY, cornerRadius, lastX, lastY);
              break;
            default:
              smooth.push(L$1, x, y);
          }
          lastX = x;
          lastY = y;
          break;
        case C:
          smooth.push(C, data[i + 1], data[i + 2], data[i + 3], data[i + 4], data[i + 5], data[i + 6]);
          i += 7;
          break;
        case Z:
          arcTo(smooth, startX, startY, secondX, secondY, cornerRadius, lastX, lastY);
          smooth.push(Z);
          i += 1;
          break;
      }
    }
    if (command !== Z) {
      smooth[1] = startX;
      smooth[2] = startY;
    }
    return smooth;
  }
};
PathHelper.creator = new PathCreator();
PathHelper.parse = PathConvert.parse;
PathHelper.convertToCanvasData = PathConvert.toCanvasData;
var pen = new PathCreator();
var { drawRoundRect } = RectHelper;
function roundRect(drawer) {
  if (drawer && !drawer.roundRect) {
    drawer.roundRect = function(x, y, width, height, cornerRadius) {
      drawRoundRect(this, x, y, width, height, cornerRadius);
    };
  }
}
function canvasPatch(drawer) {
  roundRect(drawer);
}
var FileHelper = {
  opacityTypes: ["png", "webp", "svg"],
  upperCaseTypeMap: {},
  mineType(type) {
    if (!type || type.startsWith("image"))
      return type;
    if (type === "jpg")
      type = "jpeg";
    return "image/" + type;
  },
  fileType(filename) {
    const l2 = filename.split(".");
    return l2[l2.length - 1];
  },
  isOpaqueImage(filename) {
    const type = F.fileType(filename);
    return ["jpg", "jpeg"].some((item) => item === type);
  },
  getExportOptions(options) {
    switch (typeof options) {
      case "object":
        return options;
      case "number":
        return { quality: options };
      case "boolean":
        return { blob: options };
      default:
        return {};
    }
  }
};
var F = FileHelper;
F.opacityTypes.forEach((type) => F.upperCaseTypeMap[type] = type.toUpperCase());
var debug$2 = Debug.get("TaskProcessor");
var TaskItem = class {
  constructor(task) {
    this.parallel = true;
    this.time = 1;
    this.id = IncrementId.create(IncrementId.TASK);
    this.task = task;
  }
  run() {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (this.task && !this.isComplete && this.parent.running)
          yield this.task();
      } catch (error) {
        debug$2.error(error);
      }
    });
  }
  complete() {
    this.isComplete = true;
    this.parent = null;
    this.task = null;
  }
  cancel() {
    this.isCancel = true;
    this.complete();
  }
};
var TaskProcessor = class {
  get total() {
    return this.list.length + this.delayNumber;
  }
  get finishedIndex() {
    return this.isComplete ? 0 : this.index + this.parallelSuccessNumber;
  }
  get remain() {
    return this.isComplete ? this.total : this.total - this.finishedIndex;
  }
  get percent() {
    const { total } = this;
    let totalTime = 0, runTime = 0;
    for (let i = 0; i < total; i++) {
      if (i <= this.finishedIndex) {
        runTime += this.list[i].time;
        if (i === this.finishedIndex)
          totalTime = runTime;
      } else {
        totalTime += this.list[i].time;
      }
    }
    return this.isComplete ? 1 : runTime / totalTime;
  }
  constructor(config2) {
    this.config = { parallel: 6 };
    this.list = [];
    this.running = false;
    this.isComplete = true;
    this.index = 0;
    this.delayNumber = 0;
    if (config2)
      DataHelper.assign(this.config, config2);
    this.empty();
  }
  add(taskCallback, options) {
    let start, parallel, time, delay;
    const task = new TaskItem(taskCallback);
    task.parent = this;
    if (typeof options === "number") {
      delay = options;
    } else if (options) {
      parallel = options.parallel;
      start = options.start;
      time = options.time;
      delay = options.delay;
    }
    if (time)
      task.time = time;
    if (parallel === false)
      task.parallel = false;
    if (delay === void 0) {
      this.push(task, start);
    } else {
      this.delayNumber++;
      setTimeout(() => {
        if (this.delayNumber) {
          this.delayNumber--;
          this.push(task, start);
        }
      }, delay);
    }
    this.isComplete = false;
    return task;
  }
  push(task, start) {
    this.list.push(task);
    if (start !== false && !this.timer) {
      this.timer = setTimeout(() => this.start());
    }
  }
  empty() {
    this.index = 0;
    this.parallelSuccessNumber = 0;
    this.list = [];
    this.parallelList = [];
    this.delayNumber = 0;
  }
  start() {
    if (!this.running) {
      this.running = true;
      this.isComplete = false;
      this.run();
    }
  }
  pause() {
    clearTimeout(this.timer);
    this.timer = null;
    this.running = false;
  }
  resume() {
    this.start();
  }
  skip() {
    this.index++;
    this.resume();
  }
  stop() {
    this.isComplete = true;
    this.list.forEach((task) => {
      if (!task.isComplete)
        task.cancel();
    });
    this.pause();
    this.empty();
  }
  run() {
    if (!this.running)
      return;
    this.setParallelList();
    if (this.parallelList.length > 1) {
      this.runParallelTasks();
    } else {
      this.remain ? this.runTask() : this.onComplete();
    }
  }
  runTask() {
    const task = this.list[this.index];
    if (!task) {
      this.nextTask();
      return;
    }
    task.run().then(() => {
      this.onTask(task);
      this.index++;
      this.nextTask();
    }).catch((error) => {
      this.onError(error);
    });
  }
  runParallelTasks() {
    this.parallelList.forEach((task) => this.runParallelTask(task));
  }
  runParallelTask(task) {
    task.run().then(() => {
      this.onTask(task);
      this.fillParallelTask();
    }).catch((error) => {
      this.onParallelError(error);
    });
  }
  nextTask() {
    if (this.total === this.finishedIndex) {
      this.onComplete();
    } else {
      this.timer = setTimeout(() => this.run());
    }
  }
  setParallelList() {
    let task;
    this.parallelList = [];
    this.parallelSuccessNumber = 0;
    let end = this.index + this.config.parallel;
    if (end > this.list.length)
      end = this.list.length;
    for (let i = this.index; i < end; i++) {
      task = this.list[i];
      if (task.parallel) {
        this.parallelList.push(task);
      } else {
        break;
      }
    }
  }
  fillParallelTask() {
    let task;
    const parallelList = this.parallelList;
    this.parallelSuccessNumber++;
    parallelList.pop();
    const parallelWaitNumber = parallelList.length;
    const nextIndex = this.finishedIndex + parallelWaitNumber;
    if (parallelList.length) {
      if (!this.running)
        return;
      if (nextIndex < this.total) {
        task = this.list[nextIndex];
        if (task && task.parallel) {
          parallelList.push(task);
          this.runParallelTask(task);
        }
      }
    } else {
      this.index += this.parallelSuccessNumber;
      this.parallelSuccessNumber = 0;
      this.nextTask();
    }
  }
  onComplete() {
    this.stop();
    if (this.config.onComplete)
      this.config.onComplete();
  }
  onTask(task) {
    task.complete();
    if (this.config.onTask)
      this.config.onTask();
  }
  onParallelError(error) {
    this.parallelList.forEach((task) => {
      task.parallel = false;
    });
    this.parallelList.length = 0;
    this.parallelSuccessNumber = 0;
    this.onError(error);
  }
  onError(error) {
    this.pause();
    if (this.config.onError)
      this.config.onError(error);
  }
  destroy() {
    this.stop();
  }
};
var ImageManager = {
  map: {},
  recycledList: [],
  tasker: new TaskProcessor(),
  patternTasker: new TaskProcessor(),
  get isComplete() {
    return I.tasker.isComplete;
  },
  get(config2) {
    let image2 = I.map[config2.url];
    if (!image2) {
      image2 = Creator.image(config2);
      I.map[config2.url] = image2;
    }
    image2.use++;
    return image2;
  },
  recycle(image2) {
    image2.use--;
    setTimeout(() => {
      if (!image2.use)
        I.recycledList.push(image2);
    });
  },
  clearRecycled() {
    const list3 = I.recycledList;
    if (list3.length > 100) {
      list3.forEach((image2) => {
        if (!image2.use && image2.url) {
          delete I.map[image2.url];
          image2.destroy();
        }
      });
      list3.length = 0;
    }
  },
  hasOpacityPixel(config2) {
    return FileHelper.opacityTypes.some((item) => I.isFormat(item, config2));
  },
  isFormat(format, config2) {
    if (config2.format === format)
      return true;
    const { url } = config2;
    if (url.startsWith("data:")) {
      if (url.startsWith("data:" + FileHelper.mineType(format)))
        return true;
    } else {
      if (url.includes("." + format) || url.includes("." + FileHelper.upperCaseTypeMap[format]))
        return true;
      else if (format === "png" && !url.includes("."))
        return true;
    }
    return false;
  },
  destroy() {
    I.map = {};
    I.recycledList = [];
  }
};
var I = ImageManager;
var { IMAGE, create: create$1 } = IncrementId;
var LeaferImage = class {
  get url() {
    return this.config.url;
  }
  get completed() {
    return this.ready || !!this.error;
  }
  constructor(config2) {
    this.use = 0;
    this.waitComplete = [];
    this.innerId = create$1(IMAGE);
    this.config = config2 || { url: "" };
    this.isSVG = ImageManager.isFormat("svg", config2);
    this.hasOpacityPixel = ImageManager.hasOpacityPixel(config2);
  }
  load(onSuccess, onError) {
    if (!this.loading) {
      this.loading = true;
      ImageManager.tasker.add(() => __awaiter(this, void 0, void 0, function* () {
        return yield Platform.origin.loadImage(this.url).then((img) => {
          this.ready = true;
          this.width = img.naturalWidth || img.width;
          this.height = img.naturalHeight || img.height;
          this.view = img;
          this.onComplete(true);
        }).catch((e) => {
          this.error = e;
          this.onComplete(false);
        });
      }));
    }
    this.waitComplete.push(onSuccess, onError);
    return this.waitComplete.length - 2;
  }
  unload(index, stopEvent) {
    const l2 = this.waitComplete;
    if (stopEvent) {
      const error = l2[index + 1];
      if (error)
        error({ type: "stop" });
    }
    l2[index] = l2[index + 1] = void 0;
  }
  onComplete(isSuccess) {
    let odd;
    this.waitComplete.forEach((item, index) => {
      odd = index % 2;
      if (item) {
        if (isSuccess) {
          if (!odd)
            item(this);
        } else {
          if (odd)
            item(this.error);
        }
      }
    });
    this.waitComplete.length = 0;
    this.loading = false;
  }
  getCanvas(width, height, opacity, _filters) {
    width || (width = this.width);
    height || (height = this.height);
    if (this.cache) {
      let { params, data } = this.cache;
      for (let i in params) {
        if (params[i] !== arguments[i]) {
          data = null;
          break;
        }
      }
      if (data)
        return data;
    }
    const canvas3 = Platform.origin.createCanvas(width, height);
    const ctx = canvas3.getContext("2d");
    if (opacity)
      ctx.globalAlpha = opacity;
    ctx.drawImage(this.view, 0, 0, width, height);
    this.cache = this.use > 1 ? { data: canvas3, params: arguments } : null;
    return canvas3;
  }
  getPattern(canvas3, repeat, transform2, paint) {
    const pattern = Platform.canvas.createPattern(canvas3, repeat);
    try {
      if (transform2 && pattern.setTransform) {
        pattern.setTransform(transform2);
        transform2 = null;
      }
    } catch (_a) {
    }
    if (paint)
      paint.transform = transform2;
    return pattern;
  }
  destroy() {
    this.config = { url: "" };
    this.cache = null;
    this.waitComplete.length = 0;
  }
};
function defineKey(target, key, descriptor, noConfigurable) {
  if (!noConfigurable)
    descriptor.configurable = descriptor.enumerable = true;
  Object.defineProperty(target, key, descriptor);
}
function getDescriptor(object, name) {
  return Object.getOwnPropertyDescriptor(object, name);
}
function getNames(object) {
  return Object.getOwnPropertyNames(object);
}
function decorateLeafAttr(defaultValue, descriptorFn) {
  return (target, key) => defineLeafAttr(target, key, defaultValue, descriptorFn && descriptorFn(key));
}
function attr(partDescriptor) {
  return partDescriptor;
}
function defineLeafAttr(target, key, defaultValue, partDescriptor) {
  const defaultDescriptor = {
    get() {
      return this.__getAttr(key);
    },
    set(value) {
      this.__setAttr(key, value);
    }
  };
  defineKey(target, key, Object.assign(defaultDescriptor, partDescriptor || {}));
  defineDataProcessor(target, key, defaultValue);
}
function dataType(defaultValue) {
  return decorateLeafAttr(defaultValue);
}
function positionType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.matrixChanged || this.__layout.matrixChange());
    }
  }));
}
function autoLayoutType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.matrixChanged || this.__layout.matrixChange();
        this.__hasAutoLayout = !!(this.origin || this.around || this.flow);
        if (!this.__local)
          this.__layout.createLocal();
      }
    }
  }));
}
function scaleType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.scaleChanged || this.__layout.scaleChange());
    }
  }));
}
function rotationType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && (this.__layout.rotationChanged || this.__layout.rotationChange());
    }
  }));
}
function boundsType(defaultValue, checkFiniteNumber) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value, checkFiniteNumber) && doBoundsType(this);
    }
  }));
}
function naturalBoundsType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && (doBoundsType(this), this.__.__removeNaturalSize());
    }
  }));
}
function doBoundsType(leaf2) {
  leaf2.__layout.boxChanged || leaf2.__layout.boxChange();
  if (leaf2.__hasAutoLayout)
    leaf2.__layout.matrixChanged || leaf2.__layout.matrixChange();
}
function pathInputType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      const data = this.__;
      if (data.__pathInputed !== 2)
        data.__pathInputed = value ? 1 : 0;
      if (!value)
        data.__pathForRender = void 0;
      this.__setAttr(key, value);
      doBoundsType(this);
    }
  }));
}
var pathType = boundsType;
function affectStrokeBoundsType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && doStrokeType(this);
    }
  }));
}
function doStrokeType(leaf2) {
  leaf2.__layout.strokeChanged || leaf2.__layout.strokeChange();
  if (leaf2.__.__useArrow)
    doBoundsType(leaf2);
}
var strokeType = affectStrokeBoundsType;
function affectRenderBoundsType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      this.__layout.renderChanged || this.__layout.renderChange();
    }
  }));
}
function surfaceType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && (this.__layout.surfaceChanged || this.__layout.surfaceChange());
    }
  }));
}
function opacityType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && (this.__layout.opacityChanged || this.__layout.opacityChange());
    }
  }));
}
function visibleType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      const oldValue = this.visible;
      if (oldValue === true && value === 0) {
        if (this.animationOut)
          return this.__runAnimation("out", () => doVisible(this, key, value, oldValue));
      } else if (oldValue === 0 && value === true) {
        if (this.animation)
          this.__runAnimation("in");
      }
      doVisible(this, key, value, oldValue);
    }
  }));
}
function doVisible(leaf2, key, value, oldValue) {
  if (leaf2.__setAttr(key, value)) {
    leaf2.__layout.opacityChanged || leaf2.__layout.opacityChange();
    if (oldValue === 0 || value === 0)
      doBoundsType(leaf2);
  }
}
function sortType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.surfaceChanged || this.__layout.surfaceChange();
        this.waitParent(() => {
          this.parent.__layout.childrenSortChange();
        });
      }
    }
  }));
}
function maskType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.boxChanged || this.__layout.boxChange();
        this.waitParent(() => {
          this.parent.__updateMask(value);
        });
      }
    }
  }));
}
function eraserType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value) && this.waitParent(() => {
        this.parent.__updateEraser(value);
      });
    }
  }));
}
function hitType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      if (this.__setAttr(key, value)) {
        this.__layout.hitCanvasChanged = true;
        if (Debug.showHitView) {
          this.__layout.surfaceChanged || this.__layout.surfaceChange();
        }
        if (this.leafer)
          this.leafer.updateCursor();
      }
    }
  }));
}
function cursorType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      if (this.leafer)
        this.leafer.updateCursor();
    }
  }));
}
function dataProcessor(processor) {
  return (target, _key) => {
    defineKey(target, "__DataProcessor", {
      get() {
        return processor;
      }
    });
  };
}
function layoutProcessor(processor) {
  return (target, _key) => {
    defineKey(target, "__LayoutProcessor", {
      get() {
        return processor;
      }
    });
  };
}
function getSetMethodName(key) {
  return "set" + key.charAt(0).toUpperCase() + key.slice(1);
}
function defineDataProcessor(target, key, defaultValue) {
  const data = target.__DataProcessor.prototype;
  const computedKey = "_" + key;
  const setMethodName = getSetMethodName(key);
  const property = {
    get() {
      const v2 = this[computedKey];
      return v2 === void 0 ? defaultValue : v2;
    },
    set(value) {
      this[computedKey] = value;
    }
  };
  if (defaultValue === void 0) {
    property.get = function() {
      return this[computedKey];
    };
  } else if (typeof defaultValue === "object") {
    const { clone } = DataHelper;
    property.get = function() {
      let v2 = this[computedKey];
      if (v2 === void 0)
        this[computedKey] = v2 = clone(defaultValue);
      return v2;
    };
  }
  if (key === "width") {
    property.get = function() {
      const v2 = this[computedKey];
      if (v2 === void 0) {
        const t2 = this;
        return t2._height && t2.__naturalWidth && t2.__useNaturalRatio ? t2._height * t2.__naturalWidth / t2.__naturalHeight : t2.__naturalWidth || defaultValue;
      } else {
        return v2;
      }
    };
  } else if (key === "height") {
    property.get = function() {
      const v2 = this[computedKey];
      if (v2 === void 0) {
        const t2 = this;
        return t2._width && t2.__naturalHeight && t2.__useNaturalRatio ? t2._width * t2.__naturalHeight / t2.__naturalWidth : t2.__naturalHeight || defaultValue;
      } else {
        return v2;
      }
    };
  }
  let descriptor, find = data;
  while (!descriptor && find) {
    descriptor = getDescriptor(find, key);
    find = find.__proto__;
  }
  if (descriptor && descriptor.set)
    property.set = descriptor.set;
  if (data[setMethodName]) {
    property.set = data[setMethodName];
    delete data[setMethodName];
  }
  defineKey(data, key, property);
}
var debug$1 = new Debug("rewrite");
var list = [];
var excludeNames = ["destroy", "constructor"];
function rewrite(method) {
  return (target, key) => {
    list.push({ name: target.constructor.name + "." + key, run: () => {
      target[key] = method;
    } });
  };
}
function rewriteAble() {
  return (_target) => {
    doRewrite();
  };
}
function doRewrite(error) {
  if (list.length) {
    list.forEach((item) => {
      if (error)
        debug$1.error(item.name, "需在Class上装饰@rewriteAble()");
      item.run();
    });
    list.length = 0;
  }
}
setTimeout(() => doRewrite(true));
function useModule(module, exclude2) {
  return (target) => {
    const names = module.prototype ? getNames(module.prototype) : Object.keys(module);
    names.forEach((name) => {
      if (!excludeNames.includes(name) && (!exclude2 || !exclude2.includes(name))) {
        if (module.prototype) {
          const d = getDescriptor(module.prototype, name);
          if (d.writable)
            target.prototype[name] = module.prototype[name];
        } else {
          target.prototype[name] = module[name];
        }
      }
    });
  };
}
function registerUI() {
  return (target) => {
    UICreator.register(target);
  };
}
function registerUIEvent() {
  return (target) => {
    EventCreator.register(target);
  };
}
var { copy: copy$3, toInnerPoint: toInnerPoint$1, toOuterPoint: toOuterPoint$1, scaleOfOuter, rotateOfOuter, skewOfOuter, multiplyParent: multiplyParent$2, divideParent, getLayout } = MatrixHelper;
var matrix = {};
var LeafHelper = {
  updateAllMatrix(leaf2, checkAutoLayout, waitAutoLayout) {
    if (checkAutoLayout && leaf2.__hasAutoLayout && leaf2.__layout.matrixChanged)
      waitAutoLayout = true;
    updateMatrix$1(leaf2, checkAutoLayout, waitAutoLayout);
    if (leaf2.isBranch) {
      const { children } = leaf2;
      for (let i = 0, len = children.length; i < len; i++) {
        updateAllMatrix$1(children[i], checkAutoLayout, waitAutoLayout);
      }
    }
  },
  updateMatrix(leaf2, checkAutoLayout, waitAutoLayout) {
    const layout = leaf2.__layout;
    if (checkAutoLayout) {
      if (waitAutoLayout) {
        layout.waitAutoLayout = true;
        if (leaf2.__hasAutoLayout)
          layout.matrixChanged = false;
      }
    } else if (layout.waitAutoLayout) {
      layout.waitAutoLayout = false;
    }
    if (layout.matrixChanged)
      leaf2.__updateLocalMatrix();
    if (!layout.waitAutoLayout)
      leaf2.__updateWorldMatrix();
  },
  updateBounds(leaf2) {
    const layout = leaf2.__layout;
    if (layout.boundsChanged)
      leaf2.__updateLocalBounds();
    if (!layout.waitAutoLayout)
      leaf2.__updateWorldBounds();
  },
  updateAllWorldOpacity(leaf2) {
    leaf2.__updateWorldOpacity();
    if (leaf2.isBranch) {
      const { children } = leaf2;
      for (let i = 0, len = children.length; i < len; i++) {
        updateAllWorldOpacity(children[i]);
      }
    }
  },
  updateAllChange(leaf2) {
    updateAllWorldOpacity(leaf2);
    leaf2.__updateChange();
    if (leaf2.isBranch) {
      const { children } = leaf2;
      for (let i = 0, len = children.length; i < len; i++) {
        updateAllChange(children[i]);
      }
    }
  },
  worldHittable(t2) {
    while (t2) {
      if (!t2.__.hittable)
        return false;
      t2 = t2.parent;
    }
    return true;
  },
  moveWorld(t2, x, y = 0, isInnerPoint, transition) {
    const local = typeof x === "object" ? Object.assign({}, x) : { x, y };
    isInnerPoint ? toOuterPoint$1(t2.localTransform, local, local, true) : t2.parent && toInnerPoint$1(t2.parent.worldTransform, local, local, true);
    L.moveLocal(t2, local.x, local.y, transition);
  },
  moveLocal(t2, x, y = 0, transition) {
    if (typeof x === "object")
      y = x.y, x = x.x;
    x += t2.x;
    y += t2.y;
    transition ? t2.animate({ x, y }, transition) : (t2.x = x, t2.y = y);
  },
  zoomOfWorld(t2, origin2, scaleX, scaleY, resize) {
    L.zoomOfLocal(t2, getTempLocal(t2, origin2), scaleX, scaleY, resize);
  },
  zoomOfLocal(t2, origin2, scaleX, scaleY = scaleX, resize) {
    copy$3(matrix, t2.__localMatrix);
    scaleOfOuter(matrix, origin2, scaleX, scaleY);
    if (t2.origin || t2.around) {
      L.setTransform(t2, matrix, resize);
    } else {
      moveByMatrix(t2, matrix);
      t2.scaleResize(scaleX, scaleY, resize !== true);
    }
  },
  rotateOfWorld(t2, origin2, angle) {
    L.rotateOfLocal(t2, getTempLocal(t2, origin2), angle);
  },
  rotateOfLocal(t2, origin2, angle) {
    copy$3(matrix, t2.__localMatrix);
    rotateOfOuter(matrix, origin2, angle);
    if (t2.origin || t2.around) {
      L.setTransform(t2, matrix);
    } else {
      moveByMatrix(t2, matrix);
      t2.rotation = MathHelper.formatRotation(t2.rotation + angle);
    }
  },
  skewOfWorld(t2, origin2, skewX, skewY, resize) {
    L.skewOfLocal(t2, getTempLocal(t2, origin2), skewX, skewY, resize);
  },
  skewOfLocal(t2, origin2, skewX, skewY = 0, resize) {
    copy$3(matrix, t2.__localMatrix);
    skewOfOuter(matrix, origin2, skewX, skewY);
    L.setTransform(t2, matrix, resize);
  },
  transformWorld(t2, transform2, resize) {
    copy$3(matrix, t2.worldTransform);
    multiplyParent$2(matrix, transform2);
    if (t2.parent)
      divideParent(matrix, t2.parent.worldTransform);
    L.setTransform(t2, matrix, resize);
  },
  transform(t2, transform2, resize) {
    copy$3(matrix, t2.localTransform);
    multiplyParent$2(matrix, transform2);
    L.setTransform(t2, matrix, resize);
  },
  setTransform(t2, transform2, resize) {
    const layout = getLayout(transform2, t2.origin && L.getInnerOrigin(t2, t2.origin), t2.around && L.getInnerOrigin(t2, t2.around));
    if (resize) {
      const scaleX = layout.scaleX / t2.scaleX;
      const scaleY = layout.scaleY / t2.scaleY;
      delete layout.scaleX;
      delete layout.scaleY;
      t2.set(layout);
      t2.scaleResize(scaleX, scaleY, resize !== true);
    } else {
      t2.set(layout);
    }
  },
  getFlipTransform(t2, axis) {
    const m2 = getMatrixData();
    const sign = axis === "x" ? 1 : -1;
    scaleOfOuter(m2, L.getLocalOrigin(t2, "center"), -1 * sign, 1 * sign);
    return m2;
  },
  getLocalOrigin(t2, origin2) {
    return PointHelper.tempToOuterOf(L.getInnerOrigin(t2, origin2), t2.localTransform);
  },
  getInnerOrigin(t2, origin2) {
    const innerOrigin = {};
    AroundHelper.toPoint(origin2, t2.boxBounds, innerOrigin);
    return innerOrigin;
  },
  getRelativeWorld(t2, relative, temp) {
    copy$3(matrix, t2.worldTransform);
    divideParent(matrix, relative.worldTransform);
    return temp ? matrix : Object.assign({}, matrix);
  },
  drop(t2, parent, index, resize) {
    t2.setTransform(L.getRelativeWorld(t2, parent, true), resize);
    parent.add(t2, index);
  },
  hasParent(p, parent) {
    if (!parent)
      return false;
    while (p) {
      if (parent === p)
        return true;
      p = p.parent;
    }
  }
};
var L = LeafHelper;
var { updateAllMatrix: updateAllMatrix$1, updateMatrix: updateMatrix$1, updateAllWorldOpacity, updateAllChange } = L;
function moveByMatrix(t2, matrix3) {
  const { e, f } = t2.__localMatrix;
  t2.x += matrix3.e - e;
  t2.y += matrix3.f - f;
}
function getTempLocal(t2, world) {
  t2.__layout.update();
  return t2.parent ? PointHelper.tempToInnerOf(world, t2.parent.__world) : world;
}
var LeafBoundsHelper = {
  worldBounds(target) {
    return target.__world;
  },
  localBoxBounds(target) {
    return target.__.eraser || target.__.visible === 0 ? null : target.__local || target.__layout;
  },
  localStrokeBounds(target) {
    return target.__.eraser || target.__.visible === 0 ? null : target.__layout.localStrokeBounds;
  },
  localRenderBounds(target) {
    return target.__.eraser || target.__.visible === 0 ? null : target.__layout.localRenderBounds;
  },
  maskLocalBoxBounds(target) {
    return target.__.mask ? target.__localBoxBounds : null;
  },
  maskLocalStrokeBounds(target) {
    return target.__.mask ? target.__layout.localStrokeBounds : null;
  },
  maskLocalRenderBounds(target) {
    return target.__.mask ? target.__layout.localRenderBounds : null;
  },
  excludeRenderBounds(child, options) {
    if (options.bounds && !options.bounds.hit(child.__world, options.matrix))
      return true;
    if (options.hideBounds && options.hideBounds.includes(child.__world, options.matrix))
      return true;
    return false;
  }
};
var { updateBounds: updateBounds$1 } = LeafHelper;
var BranchHelper = {
  sort(a2, b) {
    return a2.__.zIndex === b.__.zIndex ? a2.__tempNumber - b.__tempNumber : a2.__.zIndex - b.__.zIndex;
  },
  pushAllChildBranch(branch, leafList) {
    branch.__tempNumber = 1;
    if (branch.__.__childBranchNumber) {
      const { children } = branch;
      for (let i = 0, len = children.length; i < len; i++) {
        branch = children[i];
        if (branch.isBranch) {
          branch.__tempNumber = 1;
          leafList.add(branch);
          pushAllChildBranch(branch, leafList);
        }
      }
    }
  },
  pushAllParent(leaf2, leafList) {
    const { keys } = leafList;
    if (keys) {
      while (leaf2.parent) {
        if (keys[leaf2.parent.innerId] === void 0) {
          leafList.add(leaf2.parent);
          leaf2 = leaf2.parent;
        } else {
          break;
        }
      }
    } else {
      while (leaf2.parent) {
        leafList.add(leaf2.parent);
        leaf2 = leaf2.parent;
      }
    }
  },
  pushAllBranchStack(branch, pushList) {
    let start = pushList.length;
    const { children } = branch;
    for (let i = 0, len = children.length; i < len; i++) {
      if (children[i].isBranch) {
        pushList.push(children[i]);
      }
    }
    for (let i = start, len = pushList.length; i < len; i++) {
      pushAllBranchStack(pushList[i], pushList);
    }
  },
  updateBounds(branch, exclude2) {
    const branchStack = [branch];
    pushAllBranchStack(branch, branchStack);
    updateBoundsByBranchStack(branchStack, exclude2);
  },
  updateBoundsByBranchStack(branchStack, exclude2) {
    let branch, children;
    for (let i = branchStack.length - 1; i > -1; i--) {
      branch = branchStack[i];
      children = branch.children;
      for (let j = 0, len = children.length; j < len; j++) {
        updateBounds$1(children[j]);
      }
      if (exclude2 && exclude2 === branch)
        continue;
      updateBounds$1(branch);
    }
  }
};
var { pushAllChildBranch, pushAllBranchStack, updateBoundsByBranchStack } = BranchHelper;
var WaitHelper = {
  run(wait) {
    if (wait && wait.length) {
      const len = wait.length;
      for (let i = 0; i < len; i++) {
        wait[i]();
      }
      wait.length === len ? wait.length = 0 : wait.splice(0, len);
    }
  }
};
var { getRelativeWorld: getRelativeWorld$1 } = LeafHelper;
var { toOuterOf: toOuterOf$2, getPoints, copy: copy$2 } = BoundsHelper;
var localContent = "_localContentBounds";
var worldContent = "_worldContentBounds";
var worldBox = "_worldBoxBounds";
var worldStroke = "_worldStrokeBounds";
var LeafLayout = class {
  get contentBounds() {
    return this._contentBounds || this.boxBounds;
  }
  set contentBounds(bounds2) {
    this._contentBounds = bounds2;
  }
  get strokeBounds() {
    return this._strokeBounds || this.boxBounds;
  }
  get renderBounds() {
    return this._renderBounds || this.boxBounds;
  }
  get localContentBounds() {
    toOuterOf$2(this.contentBounds, this.leaf.__localMatrix, this[localContent] || (this[localContent] = {}));
    return this[localContent];
  }
  get localStrokeBounds() {
    return this._localStrokeBounds || this;
  }
  get localRenderBounds() {
    return this._localRenderBounds || this;
  }
  get worldContentBounds() {
    toOuterOf$2(this.contentBounds, this.leaf.__world, this[worldContent] || (this[worldContent] = {}));
    return this[worldContent];
  }
  get worldBoxBounds() {
    toOuterOf$2(this.boxBounds, this.leaf.__world, this[worldBox] || (this[worldBox] = {}));
    return this[worldBox];
  }
  get worldStrokeBounds() {
    toOuterOf$2(this.strokeBounds, this.leaf.__world, this[worldStroke] || (this[worldStroke] = {}));
    return this[worldStroke];
  }
  get a() {
    return 1;
  }
  get b() {
    return 0;
  }
  get c() {
    return 0;
  }
  get d() {
    return 1;
  }
  get e() {
    return this.leaf.__.x;
  }
  get f() {
    return this.leaf.__.y;
  }
  get x() {
    return this.e + this.boxBounds.x;
  }
  get y() {
    return this.f + this.boxBounds.y;
  }
  get width() {
    return this.boxBounds.width;
  }
  get height() {
    return this.boxBounds.height;
  }
  constructor(leaf2) {
    this.leaf = leaf2;
    this.boxBounds = { x: 0, y: 0, width: 0, height: 0 };
    if (this.leaf.__local)
      this._localRenderBounds = this._localStrokeBounds = this.leaf.__local;
    this.boxChange();
    this.matrixChange();
  }
  createLocal() {
    const local = this.leaf.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 };
    if (!this._localStrokeBounds)
      this._localStrokeBounds = local;
    if (!this._localRenderBounds)
      this._localRenderBounds = local;
  }
  update() {
    const { leafer: leafer2 } = this.leaf;
    if (leafer2) {
      if (leafer2.ready)
        leafer2.watcher.changed && leafer2.layouter.layout();
      else
        leafer2.start();
    } else {
      let root = this.leaf;
      while (root.parent && !root.parent.leafer) {
        root = root.parent;
      }
      Platform.layout(root);
    }
  }
  getTransform(relative = "world") {
    this.update();
    const { leaf: leaf2 } = this;
    switch (relative) {
      case "world":
        return leaf2.__world;
      case "local":
        return leaf2.__localMatrix;
      case "inner":
        return MatrixHelper.defaultMatrix;
      case "page":
        relative = leaf2.zoomLayer;
      default:
        return getRelativeWorld$1(leaf2, relative);
    }
  }
  getBounds(type, relative = "world") {
    this.update();
    switch (relative) {
      case "world":
        return this.getWorldBounds(type);
      case "local":
        return this.getLocalBounds(type);
      case "inner":
        return this.getInnerBounds(type);
      case "page":
        relative = this.leaf.zoomLayer;
      default:
        return new Bounds(this.getInnerBounds(type)).toOuterOf(this.getTransform(relative));
    }
  }
  getInnerBounds(type = "box") {
    switch (type) {
      case "render":
        return this.renderBounds;
      case "content":
        if (this.contentBounds)
          return this.contentBounds;
      case "box":
        return this.boxBounds;
      case "stroke":
        return this.strokeBounds;
    }
  }
  getLocalBounds(type = "box") {
    switch (type) {
      case "render":
        return this.localRenderBounds;
      case "stroke":
        return this.localStrokeBounds;
      case "content":
        if (this.contentBounds)
          return this.localContentBounds;
      case "box":
        return this.leaf.__localBoxBounds;
    }
  }
  getWorldBounds(type = "box") {
    switch (type) {
      case "render":
        return this.leaf.__world;
      case "stroke":
        return this.worldStrokeBounds;
      case "content":
        if (this.contentBounds)
          return this.worldContentBounds;
      case "box":
        return this.worldBoxBounds;
    }
  }
  getLayoutBounds(type, relative = "world", unscale) {
    const { leaf: leaf2 } = this;
    let point2, matrix3, layoutBounds, bounds2 = this.getInnerBounds(type);
    switch (relative) {
      case "world":
        point2 = leaf2.getWorldPoint(bounds2);
        matrix3 = leaf2.__world;
        break;
      case "local":
        const { scaleX, scaleY, rotation, skewX, skewY } = leaf2.__;
        layoutBounds = { scaleX, scaleY, rotation, skewX, skewY };
        point2 = leaf2.getLocalPointByInner(bounds2);
        break;
      case "inner":
        point2 = bounds2;
        matrix3 = MatrixHelper.defaultMatrix;
        break;
      case "page":
        relative = leaf2.zoomLayer;
      default:
        point2 = leaf2.getWorldPoint(bounds2, relative);
        matrix3 = getRelativeWorld$1(leaf2, relative, true);
    }
    if (!layoutBounds)
      layoutBounds = MatrixHelper.getLayout(matrix3);
    copy$2(layoutBounds, bounds2);
    PointHelper.copy(layoutBounds, point2);
    if (unscale) {
      const { scaleX, scaleY } = layoutBounds;
      const uScaleX = Math.abs(scaleX);
      const uScaleY = Math.abs(scaleY);
      if (uScaleX !== 1 || uScaleY !== 1) {
        layoutBounds.scaleX /= uScaleX;
        layoutBounds.scaleY /= uScaleY;
        layoutBounds.width *= uScaleX;
        layoutBounds.height *= uScaleY;
      }
    }
    return layoutBounds;
  }
  getLayoutPoints(type, relative = "world") {
    const { leaf: leaf2 } = this;
    const points = getPoints(this.getInnerBounds(type));
    let relativeLeaf;
    switch (relative) {
      case "world":
        relativeLeaf = null;
        break;
      case "local":
        relativeLeaf = leaf2.parent;
        break;
      case "inner":
        break;
      case "page":
        relative = leaf2.zoomLayer;
      default:
        relativeLeaf = relative;
    }
    if (relativeLeaf !== void 0)
      points.forEach((point2) => leaf2.innerToWorld(point2, null, false, relativeLeaf));
    return points;
  }
  shrinkContent() {
    const { x, y, width, height } = this.boxBounds;
    this._contentBounds = { x, y, width, height };
  }
  spreadStroke() {
    const { x, y, width, height } = this.strokeBounds;
    this._strokeBounds = { x, y, width, height };
    this._localStrokeBounds = { x, y, width, height };
    if (!this.renderSpread)
      this.spreadRenderCancel();
  }
  spreadRender() {
    const { x, y, width, height } = this.renderBounds;
    this._renderBounds = { x, y, width, height };
    this._localRenderBounds = { x, y, width, height };
  }
  shrinkContentCancel() {
    this._contentBounds = void 0;
  }
  spreadStrokeCancel() {
    const same = this.renderBounds === this.strokeBounds;
    this._strokeBounds = this.boxBounds;
    this._localStrokeBounds = this.leaf.__localBoxBounds;
    if (same)
      this.spreadRenderCancel();
  }
  spreadRenderCancel() {
    this._renderBounds = this._strokeBounds;
    this._localRenderBounds = this._localStrokeBounds;
  }
  boxChange() {
    this.boxChanged = true;
    this.localBoxChanged || this.localBoxChange();
    this.hitCanvasChanged = true;
  }
  localBoxChange() {
    this.localBoxChanged = true;
    this.boundsChanged = true;
  }
  strokeChange() {
    this.strokeChanged = true;
    this.strokeSpread || (this.strokeSpread = 1);
    this.boundsChanged = true;
    this.hitCanvasChanged = true;
  }
  renderChange() {
    this.renderChanged = true;
    this.renderSpread || (this.renderSpread = 1);
    this.boundsChanged = true;
  }
  scaleChange() {
    this.scaleChanged = true;
    this._scaleOrRotationChange();
  }
  rotationChange() {
    this.rotationChanged = true;
    this.affectRotation = true;
    this._scaleOrRotationChange();
  }
  _scaleOrRotationChange() {
    this.affectScaleOrRotation = true;
    this.matrixChange();
    if (!this.leaf.__local)
      this.createLocal();
  }
  matrixChange() {
    this.matrixChanged = true;
    this.localBoxChanged || this.localBoxChange();
  }
  surfaceChange() {
    this.surfaceChanged = true;
  }
  opacityChange() {
    this.opacityChanged = true;
    this.surfaceChanged || this.surfaceChange();
  }
  childrenSortChange() {
    if (!this.childrenSortChanged) {
      this.childrenSortChanged = true;
      this.leaf.forceUpdate("surface");
    }
  }
  destroy() {
  }
};
var Event = class {
  constructor(type, target) {
    this.bubbles = false;
    this.type = type;
    if (target)
      this.target = target;
  }
  stopDefault() {
    this.isStopDefault = true;
    if (this.origin)
      Platform.event.stopDefault(this.origin);
  }
  stopNow() {
    this.isStopNow = true;
    this.isStop = true;
    if (this.origin)
      Platform.event.stopNow(this.origin);
  }
  stop() {
    this.isStop = true;
    if (this.origin)
      Platform.event.stop(this.origin);
  }
};
var ChildEvent = class extends Event {
  constructor(type, child, parent) {
    super(type, child);
    this.parent = parent;
    this.child = child;
  }
};
ChildEvent.ADD = "child.add";
ChildEvent.REMOVE = "child.remove";
ChildEvent.CREATED = "created";
ChildEvent.MOUNTED = "mounted";
ChildEvent.UNMOUNTED = "unmounted";
ChildEvent.DESTROY = "destroy";
var PropertyEvent = class extends Event {
  constructor(type, target, attrName, oldValue, newValue) {
    super(type, target);
    this.attrName = attrName;
    this.oldValue = oldValue;
    this.newValue = newValue;
  }
};
PropertyEvent.CHANGE = "property.change";
PropertyEvent.LEAFER_CHANGE = "property.leafer_change";
var ImageEvent = class extends Event {
  constructor(type, data) {
    super(type);
    Object.assign(this, data);
  }
};
ImageEvent.LOAD = "image.load";
ImageEvent.LOADED = "image.loaded";
ImageEvent.ERROR = "image.error";
var ResizeEvent = class _ResizeEvent extends Event {
  get bigger() {
    if (!this.old)
      return true;
    const { width, height } = this.old;
    return this.width >= width && this.height >= height;
  }
  get smaller() {
    return !this.bigger;
  }
  get samePixelRatio() {
    if (!this.old)
      return true;
    return this.pixelRatio === this.old.pixelRatio;
  }
  constructor(size, oldSize) {
    if (typeof size === "object") {
      super(_ResizeEvent.RESIZE);
      Object.assign(this, size);
    } else {
      super(size);
    }
    this.old = oldSize;
  }
};
ResizeEvent.RESIZE = "resize";
var WatchEvent = class extends Event {
  constructor(type, data) {
    super(type);
    this.data = data;
  }
};
WatchEvent.REQUEST = "watch.request";
WatchEvent.DATA = "watch.data";
var LayoutEvent = class extends Event {
  constructor(type, data, times) {
    super(type);
    if (data) {
      this.data = data;
      this.times = times;
    }
  }
};
LayoutEvent.CHECK_UPDATE = "layout.check_update";
LayoutEvent.REQUEST = "layout.request";
LayoutEvent.START = "layout.start";
LayoutEvent.BEFORE = "layout.before";
LayoutEvent.LAYOUT = "layout";
LayoutEvent.AFTER = "layout.after";
LayoutEvent.AGAIN = "layout.again";
LayoutEvent.END = "layout.end";
var RenderEvent = class extends Event {
  constructor(type, times, bounds2, options) {
    super(type);
    if (times)
      this.times = times;
    if (bounds2) {
      this.renderBounds = bounds2;
      this.renderOptions = options;
    }
  }
};
RenderEvent.REQUEST = "render.request";
RenderEvent.CHILD_START = "render.child_start";
RenderEvent.START = "render.start";
RenderEvent.BEFORE = "render.before";
RenderEvent.RENDER = "render";
RenderEvent.AFTER = "render.after";
RenderEvent.AGAIN = "render.again";
RenderEvent.END = "render.end";
RenderEvent.NEXT = "render.next";
var LeaferEvent = class extends Event {
};
LeaferEvent.START = "leafer.start";
LeaferEvent.BEFORE_READY = "leafer.before_ready";
LeaferEvent.READY = "leafer.ready";
LeaferEvent.AFTER_READY = "leafer.after_ready";
LeaferEvent.VIEW_READY = "leafer.view_ready";
LeaferEvent.VIEW_COMPLETED = "leafer.view_completed";
LeaferEvent.STOP = "leafer.stop";
LeaferEvent.RESTART = "leafer.restart";
LeaferEvent.END = "leafer.end";
var empty = {};
var Eventer = class {
  set event(map) {
    this.on(map);
  }
  on(type, listener, options) {
    if (!listener) {
      let event, map2 = type;
      for (let key in map2)
        event = map2[key], event instanceof Array ? this.on(key, event[0], event[1]) : this.on(key, event);
      return;
    }
    let capture, once2;
    if (options) {
      if (options === "once") {
        once2 = true;
      } else if (typeof options === "boolean") {
        capture = options;
      } else {
        capture = options.capture;
        once2 = options.once;
      }
    }
    let events;
    const map = __getListenerMap(this, capture, true);
    const typeList = typeof type === "string" ? type.split(" ") : type;
    const item = once2 ? { listener, once: once2 } : { listener };
    typeList.forEach((type2) => {
      if (type2) {
        events = map[type2];
        if (events) {
          if (events.findIndex((item2) => item2.listener === listener) === -1)
            events.push(item);
        } else {
          map[type2] = [item];
        }
      }
    });
  }
  off(type, listener, options) {
    if (type) {
      const typeList = typeof type === "string" ? type.split(" ") : type;
      if (listener) {
        let capture;
        if (options)
          capture = typeof options === "boolean" ? options : options === "once" ? false : options.capture;
        let events, index;
        const map = __getListenerMap(this, capture);
        typeList.forEach((type2) => {
          if (type2) {
            events = map[type2];
            if (events) {
              index = events.findIndex((item) => item.listener === listener);
              if (index > -1)
                events.splice(index, 1);
              if (!events.length)
                delete map[type2];
            }
          }
        });
      } else {
        const { __bubbleMap: b, __captureMap: c2 } = this;
        typeList.forEach((type2) => {
          if (b)
            delete b[type2];
          if (c2)
            delete c2[type2];
        });
      }
    } else {
      this.__bubbleMap = this.__captureMap = void 0;
    }
  }
  on_(type, listener, bind, options) {
    if (bind)
      listener = listener.bind(bind);
    this.on(type, listener, options);
    return { type, current: this, listener, options };
  }
  off_(id) {
    if (!id)
      return;
    const list3 = id instanceof Array ? id : [id];
    list3.forEach((item) => item.current.off(item.type, item.listener, item.options));
    list3.length = 0;
  }
  once(type, listener, capture) {
    this.on(type, listener, { once: true, capture });
  }
  emit(type, event, capture) {
    if (!event && EventCreator.has(type))
      event = EventCreator.get(type, { type, target: this, current: this });
    const map = __getListenerMap(this, capture);
    const list3 = map[type];
    if (list3) {
      let item;
      for (let i = 0, len = list3.length; i < len; i++) {
        item = list3[i];
        item.listener(event);
        if (item.once) {
          this.off(type, item.listener, capture);
          i--, len--;
        }
        if (event && event.isStopNow)
          break;
      }
    }
    this.syncEventer && this.syncEventer.emitEvent(event, capture);
  }
  emitEvent(event, capture) {
    event.current = this;
    this.emit(event.type, event, capture);
  }
  hasEvent(type, capture) {
    if (this.syncEventer && this.syncEventer.hasEvent(type, capture))
      return true;
    const { __bubbleMap: b, __captureMap: c2 } = this;
    const hasB = b && b[type], hasC = c2 && c2[type];
    return !!(capture === void 0 ? hasB || hasC : capture ? hasC : hasB);
  }
  destroy() {
    this.__captureMap = this.__bubbleMap = this.syncEventer = null;
  }
};
function __getListenerMap(eventer, capture, create2) {
  if (capture) {
    const { __captureMap: c2 } = eventer;
    if (c2) {
      return c2;
    } else {
      return create2 ? eventer.__captureMap = {} : empty;
    }
  } else {
    const { __bubbleMap: b } = eventer;
    if (b) {
      return b;
    } else {
      return create2 ? eventer.__bubbleMap = {} : empty;
    }
  }
}
var { on, on_, off, off_, once, emit, emitEvent, hasEvent, destroy } = Eventer.prototype;
var LeafEventer = { on, on_, off, off_, once, emit, emitEvent, hasEvent, destroyEventer: destroy };
var { isFinite } = Number;
var debug = Debug.get("setAttr");
var LeafDataProxy = {
  __setAttr(name, newValue, checkFiniteNumber) {
    if (this.leaferIsCreated) {
      const oldValue = this.__.__getInput(name);
      if (checkFiniteNumber && !isFinite(newValue) && newValue !== void 0) {
        debug.warn(this.innerName, name, newValue);
        newValue = void 0;
      }
      if (typeof newValue === "object" || oldValue !== newValue) {
        this.__realSetAttr(name, newValue);
        const { CHANGE } = PropertyEvent;
        const event = new PropertyEvent(CHANGE, this, name, oldValue, newValue);
        if (this.isLeafer) {
          this.emitEvent(new PropertyEvent(PropertyEvent.LEAFER_CHANGE, this, name, oldValue, newValue));
        } else {
          if (this.hasEvent(CHANGE))
            this.emitEvent(event);
        }
        this.leafer.emitEvent(event);
        return true;
      } else {
        return false;
      }
    } else {
      this.__realSetAttr(name, newValue);
      return true;
    }
  },
  __realSetAttr(name, newValue) {
    const data = this.__;
    data[name] = newValue;
    if (this.__proxyData)
      this.setProxyAttr(name, newValue);
    if (data.normalStyle)
      this.lockNormalStyle || data.normalStyle[name] === void 0 || (data.normalStyle[name] = newValue);
  },
  __getAttr(name) {
    if (this.__proxyData)
      return this.getProxyAttr(name);
    return this.__.__get(name);
  }
};
var { setLayout, multiplyParent: multiplyParent$1, translateInner, defaultWorld } = MatrixHelper;
var { toPoint, tempPoint } = AroundHelper;
var LeafMatrix = {
  __updateWorldMatrix() {
    multiplyParent$1(this.__local || this.__layout, this.parent ? this.parent.__world : defaultWorld, this.__world, !!this.__layout.affectScaleOrRotation, this.__, this.parent && this.parent.__);
  },
  __updateLocalMatrix() {
    if (this.__local) {
      const layout = this.__layout, local = this.__local, data = this.__;
      if (layout.affectScaleOrRotation) {
        if (layout.scaleChanged || layout.rotationChanged) {
          setLayout(local, data, null, null, layout.affectRotation);
          layout.scaleChanged = layout.rotationChanged = false;
        }
      }
      local.e = data.x + data.offsetX;
      local.f = data.y + data.offsetY;
      if (data.around || data.origin) {
        toPoint(data.around || data.origin, layout.boxBounds, tempPoint);
        translateInner(local, -tempPoint.x, -tempPoint.y, !data.around);
      }
    }
    this.__layout.matrixChanged = false;
  }
};
var { updateMatrix, updateAllMatrix } = LeafHelper;
var { updateBounds } = BranchHelper;
var { toOuterOf: toOuterOf$1, copyAndSpread, copy: copy$1 } = BoundsHelper;
var { toBounds } = PathBounds;
var LeafBounds = {
  __updateWorldBounds() {
    toOuterOf$1(this.__layout.renderBounds, this.__world, this.__world);
    if (this.__layout.resized) {
      this.__onUpdateSize();
      this.__layout.resized = false;
    }
  },
  __updateLocalBounds() {
    const layout = this.__layout;
    if (layout.boxChanged) {
      if (!this.__.__pathInputed)
        this.__updatePath();
      this.__updateRenderPath();
      this.__updateBoxBounds();
      layout.resized = true;
    }
    if (layout.localBoxChanged) {
      if (this.__local)
        this.__updateLocalBoxBounds();
      layout.localBoxChanged = false;
      if (layout.strokeSpread)
        layout.strokeChanged = true;
      if (layout.renderSpread)
        layout.renderChanged = true;
      if (this.parent)
        this.parent.__layout.boxChange();
    }
    layout.boxChanged = false;
    if (layout.strokeChanged) {
      layout.strokeSpread = this.__updateStrokeSpread();
      if (layout.strokeSpread) {
        if (layout.strokeBounds === layout.boxBounds)
          layout.spreadStroke();
        this.__updateStrokeBounds();
        this.__updateLocalStrokeBounds();
      } else {
        layout.spreadStrokeCancel();
      }
      layout.strokeChanged = false;
      if (layout.renderSpread || layout.strokeSpread !== layout.strokeBoxSpread)
        layout.renderChanged = true;
      if (this.parent)
        this.parent.__layout.strokeChange();
      layout.resized = true;
    }
    if (layout.renderChanged) {
      layout.renderSpread = this.__updateRenderSpread();
      if (layout.renderSpread) {
        if (layout.renderBounds === layout.boxBounds || layout.renderBounds === layout.strokeBounds)
          layout.spreadRender();
        this.__updateRenderBounds();
        this.__updateLocalRenderBounds();
      } else {
        layout.spreadRenderCancel();
      }
      layout.renderChanged = false;
      if (this.parent)
        this.parent.__layout.renderChange();
    }
    layout.boundsChanged = false;
  },
  __updateLocalBoxBounds() {
    if (this.__hasMotionPath)
      this.__updateMotionPath();
    if (this.__hasAutoLayout)
      this.__updateAutoLayout();
    toOuterOf$1(this.__layout.boxBounds, this.__local, this.__local);
  },
  __updateLocalStrokeBounds() {
    toOuterOf$1(this.__layout.strokeBounds, this.__localMatrix, this.__layout.localStrokeBounds);
  },
  __updateLocalRenderBounds() {
    toOuterOf$1(this.__layout.renderBounds, this.__localMatrix, this.__layout.localRenderBounds);
  },
  __updateBoxBounds() {
    const b = this.__layout.boxBounds;
    const data = this.__;
    if (data.__pathInputed) {
      toBounds(data.path, b);
    } else {
      b.x = 0;
      b.y = 0;
      b.width = data.width;
      b.height = data.height;
    }
  },
  __updateAutoLayout() {
    this.__layout.matrixChanged = true;
    if (this.isBranch) {
      if (this.leaferIsReady)
        this.leafer.layouter.addExtra(this);
      if (this.__.flow) {
        if (this.__layout.boxChanged)
          this.__updateFlowLayout();
        updateAllMatrix(this);
        updateBounds(this, this);
        if (this.__.__autoSide)
          this.__updateBoxBounds(true);
      } else {
        updateAllMatrix(this);
        updateBounds(this, this);
      }
    } else {
      updateMatrix(this);
    }
  },
  __updateNaturalSize() {
    const { __: data, __layout: layout } = this;
    data.__naturalWidth = layout.boxBounds.width;
    data.__naturalHeight = layout.boxBounds.height;
  },
  __updateStrokeBounds() {
    const layout = this.__layout;
    copyAndSpread(layout.strokeBounds, layout.boxBounds, layout.strokeBoxSpread);
  },
  __updateRenderBounds() {
    const layout = this.__layout;
    layout.renderSpread > 0 ? copyAndSpread(layout.renderBounds, layout.boxBounds, layout.renderSpread) : copy$1(layout.renderBounds, layout.strokeBounds);
  }
};
var LeafRender = {
  __render(canvas3, options) {
    if (this.__worldOpacity) {
      canvas3.setWorld(this.__nowWorld = this.__getNowWorld(options));
      canvas3.opacity = this.__.opacity;
      if (this.__.__single) {
        if (this.__.eraser === "path")
          return this.__renderEraser(canvas3, options);
        const tempCanvas = canvas3.getSameCanvas(true, true);
        this.__draw(tempCanvas, options);
        if (this.__worldFlipped) {
          canvas3.copyWorldByReset(tempCanvas, this.__nowWorld, null, this.__.__blendMode, true);
        } else {
          canvas3.copyWorldToInner(tempCanvas, this.__nowWorld, this.__layout.renderBounds, this.__.__blendMode);
        }
        tempCanvas.recycle(this.__nowWorld);
      } else {
        this.__draw(canvas3, options);
      }
    }
  },
  __clip(canvas3, options) {
    if (this.__worldOpacity) {
      canvas3.setWorld(this.__nowWorld = this.__getNowWorld(options));
      this.__drawRenderPath(canvas3);
      this.windingRule ? canvas3.clip(this.windingRule) : canvas3.clip();
    }
  },
  __updateWorldOpacity() {
    this.__worldOpacity = this.__.visible ? this.parent ? this.parent.__worldOpacity * this.__.opacity : this.__.opacity : 0;
    if (this.__layout.opacityChanged)
      this.__layout.opacityChanged = false;
  }
};
var { excludeRenderBounds } = LeafBoundsHelper;
var BranchRender = {
  __updateChange() {
    const { __layout: layout } = this;
    if (layout.childrenSortChanged) {
      this.__updateSortChildren();
      layout.childrenSortChanged = false;
    }
    this.__.__checkSingle();
  },
  __render(canvas3, options) {
    this.__nowWorld = this.__getNowWorld(options);
    if (this.__worldOpacity) {
      if (this.__.__single) {
        if (this.__.eraser === "path")
          return this.__renderEraser(canvas3, options);
        const tempCanvas = canvas3.getSameCanvas(false, true);
        this.__renderBranch(tempCanvas, options);
        const nowWorld = this.__nowWorld;
        canvas3.opacity = this.__.opacity;
        canvas3.copyWorldByReset(tempCanvas, nowWorld, nowWorld, this.__.__blendMode, true);
        tempCanvas.recycle(nowWorld);
      } else {
        this.__renderBranch(canvas3, options);
      }
    }
  },
  __renderBranch(canvas3, options) {
    if (this.__hasMask) {
      this.__renderMask(canvas3, options);
    } else {
      const { children } = this;
      for (let i = 0, len = children.length; i < len; i++) {
        if (excludeRenderBounds(children[i], options))
          continue;
        children[i].__render(canvas3, options);
      }
    }
  },
  __clip(canvas3, options) {
    if (this.__worldOpacity) {
      const { children } = this;
      for (let i = 0, len = children.length; i < len; i++) {
        if (excludeRenderBounds(children[i], options))
          continue;
        children[i].__clip(canvas3, options);
      }
    }
  }
};
var { LEAF, create } = IncrementId;
var { toInnerPoint, toOuterPoint, multiplyParent } = MatrixHelper;
var { toOuterOf } = BoundsHelper;
var { copy, move } = PointHelper;
var { moveLocal, zoomOfLocal, rotateOfLocal, skewOfLocal, moveWorld, zoomOfWorld, rotateOfWorld, skewOfWorld, transform, transformWorld, setTransform, getFlipTransform, getLocalOrigin, getRelativeWorld, drop } = LeafHelper;
var Leaf = class Leaf2 {
  get tag() {
    return this.__tag;
  }
  set tag(_value) {
  }
  get __tag() {
    return "Leaf";
  }
  get innerName() {
    return this.__.name || this.tag + this.innerId;
  }
  get __DataProcessor() {
    return LeafData;
  }
  get __LayoutProcessor() {
    return LeafLayout;
  }
  get leaferIsCreated() {
    return this.leafer && this.leafer.created;
  }
  get leaferIsReady() {
    return this.leafer && this.leafer.ready;
  }
  get isLeafer() {
    return false;
  }
  get isBranch() {
    return false;
  }
  get isBranchLeaf() {
    return false;
  }
  get __localMatrix() {
    return this.__local || this.__layout;
  }
  get __localBoxBounds() {
    return this.__local || this.__layout;
  }
  get worldTransform() {
    return this.__layout.getTransform("world");
  }
  get localTransform() {
    return this.__layout.getTransform("local");
  }
  get boxBounds() {
    return this.getBounds("box", "inner");
  }
  get renderBounds() {
    return this.getBounds("render", "inner");
  }
  get worldBoxBounds() {
    return this.getBounds("box");
  }
  get worldStrokeBounds() {
    return this.getBounds("stroke");
  }
  get worldRenderBounds() {
    return this.getBounds("render");
  }
  get worldOpacity() {
    this.__layout.update();
    return this.__worldOpacity;
  }
  get __worldFlipped() {
    return this.__world.scaleX < 0 || this.__world.scaleY < 0;
  }
  get __onlyHitMask() {
    return this.__hasMask && !this.__.hitChildren;
  }
  get __ignoreHitWorld() {
    return (this.__hasMask || this.__hasEraser) && this.__.hitChildren;
  }
  get __inLazyBounds() {
    const { leafer: leafer2 } = this;
    return leafer2 && leafer2.created && leafer2.lazyBounds.hit(this.__world);
  }
  get pathInputed() {
    return this.__.__pathInputed;
  }
  set event(map) {
    this.on(map);
  }
  constructor(data) {
    this.innerId = create(LEAF);
    this.reset(data);
    if (this.__bubbleMap)
      this.__emitLifeEvent(ChildEvent.CREATED);
  }
  reset(data) {
    if (this.leafer)
      this.leafer.forceRender(this.__world);
    this.__world = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0, scaleX: 1, scaleY: 1 };
    if (data !== null)
      this.__local = { a: 1, b: 0, c: 0, d: 1, e: 0, f: 0, x: 0, y: 0, width: 0, height: 0 };
    this.__worldOpacity = 1;
    this.__ = new this.__DataProcessor(this);
    this.__layout = new this.__LayoutProcessor(this);
    if (this.__level)
      this.resetCustom();
    if (data) {
      if (data.__)
        data = data.toJSON();
      data.children ? this.set(data) : Object.assign(this, data);
    }
  }
  resetCustom() {
    this.__hasMask = this.__hasEraser = null;
    this.forceUpdate();
  }
  waitParent(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.parent ? item() : this.on(ChildEvent.ADD, item, "once");
  }
  waitLeafer(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.leafer ? item() : this.on(ChildEvent.MOUNTED, item, "once");
  }
  nextRender(item, bind, off2) {
    this.leafer ? this.leafer.nextRender(item, bind, off2) : this.waitLeafer(() => this.leafer.nextRender(item, bind, off2));
  }
  removeNextRender(item) {
    this.nextRender(item, null, "off");
  }
  __bindLeafer(leafer2) {
    if (this.isLeafer && leafer2 !== null)
      leafer2 = this;
    if (this.leafer && !leafer2)
      this.leafer.leafs--;
    this.leafer = leafer2;
    if (leafer2) {
      leafer2.leafs++;
      this.__level = this.parent ? this.parent.__level + 1 : 1;
      if (this.animation)
        this.__runAnimation("in");
      if (this.__bubbleMap)
        this.__emitLifeEvent(ChildEvent.MOUNTED);
    } else {
      this.__emitLifeEvent(ChildEvent.UNMOUNTED);
    }
    if (this.isBranch) {
      const { children } = this;
      for (let i = 0, len = children.length; i < len; i++) {
        children[i].__bindLeafer(leafer2);
      }
    }
  }
  set(_data, _isTemp) {
  }
  get(_name) {
    return void 0;
  }
  setAttr(name, value) {
    this[name] = value;
  }
  getAttr(name) {
    return this[name];
  }
  getComputedAttr(name) {
    return this.__[name];
  }
  toJSON(options) {
    if (options)
      this.__layout.update();
    return this.__.__getInputData(null, options);
  }
  toString(options) {
    return JSON.stringify(this.toJSON(options));
  }
  toSVG() {
    return void 0;
  }
  __SVG(_data) {
  }
  toHTML() {
    return void 0;
  }
  __setAttr(_attrName, _newValue) {
    return true;
  }
  __getAttr(_attrName) {
    return void 0;
  }
  setProxyAttr(_attrName, _newValue) {
  }
  getProxyAttr(_attrName) {
    return void 0;
  }
  find(_condition, _options) {
    return void 0;
  }
  findTag(_tag) {
    return void 0;
  }
  findOne(_condition, _options) {
    return void 0;
  }
  findId(_id) {
    return void 0;
  }
  focus(_value) {
  }
  updateState() {
  }
  updateLayout() {
    this.__layout.update();
  }
  forceUpdate(attrName) {
    if (attrName === void 0)
      attrName = "width";
    else if (attrName === "surface")
      attrName = "blendMode";
    const value = this.__.__getInput(attrName);
    this.__[attrName] = value === void 0 ? null : void 0;
    this[attrName] = value;
  }
  forceRender(_bounds) {
    this.forceUpdate("surface");
  }
  __updateWorldMatrix() {
  }
  __updateLocalMatrix() {
  }
  __updateWorldBounds() {
  }
  __updateLocalBounds() {
  }
  __updateLocalBoxBounds() {
  }
  __updateLocalStrokeBounds() {
  }
  __updateLocalRenderBounds() {
  }
  __updateBoxBounds() {
  }
  __updateContentBounds() {
  }
  __updateStrokeBounds() {
  }
  __updateRenderBounds() {
  }
  __updateAutoLayout() {
  }
  __updateFlowLayout() {
  }
  __updateNaturalSize() {
  }
  __updateStrokeSpread() {
    return 0;
  }
  __updateRenderSpread() {
    return 0;
  }
  __onUpdateSize() {
  }
  __updateEraser(value) {
    this.__hasEraser = value ? true : this.children.some((item) => item.__.eraser);
  }
  __renderEraser(canvas3, options) {
    canvas3.save();
    this.__clip(canvas3, options);
    const { renderBounds: r } = this.__layout;
    canvas3.clearRect(r.x, r.y, r.width, r.height);
    canvas3.restore();
  }
  __updateMask(value) {
    this.__hasMask = value ? true : this.children.some((item) => item.__.mask);
  }
  __renderMask(_canvas, _options) {
  }
  __getNowWorld(options) {
    if (options.matrix) {
      if (!this.__cameraWorld)
        this.__cameraWorld = {};
      const cameraWorld = this.__cameraWorld;
      multiplyParent(this.__world, options.matrix, cameraWorld, void 0, this.__world);
      toOuterOf(this.__layout.renderBounds, cameraWorld, cameraWorld);
      return cameraWorld;
    } else {
      return this.__world;
    }
  }
  getTransform(relative) {
    return this.__layout.getTransform(relative || "local");
  }
  getBounds(type, relative) {
    return this.__layout.getBounds(type, relative);
  }
  getLayoutBounds(type, relative, unscale) {
    return this.__layout.getLayoutBounds(type, relative, unscale);
  }
  getLayoutPoints(type, relative) {
    return this.__layout.getLayoutPoints(type, relative);
  }
  getWorldBounds(inner2, relative, change) {
    const matrix3 = relative ? getRelativeWorld(this, relative) : this.worldTransform;
    const to = change ? inner2 : {};
    toOuterOf(inner2, matrix3, to);
    return to;
  }
  worldToLocal(world, to, distance, relative) {
    if (this.parent) {
      this.parent.worldToInner(world, to, distance, relative);
    } else {
      if (to)
        copy(to, world);
    }
  }
  localToWorld(local, to, distance, relative) {
    if (this.parent) {
      this.parent.innerToWorld(local, to, distance, relative);
    } else {
      if (to)
        copy(to, local);
    }
  }
  worldToInner(world, to, distance, relative) {
    if (relative) {
      relative.innerToWorld(world, to, distance);
      world = to ? to : world;
    }
    toInnerPoint(this.worldTransform, world, to, distance);
  }
  innerToWorld(inner2, to, distance, relative) {
    toOuterPoint(this.worldTransform, inner2, to, distance);
    if (relative)
      relative.worldToInner(to ? to : inner2, null, distance);
  }
  getBoxPoint(world, relative, distance, change) {
    return this.getBoxPointByInner(this.getInnerPoint(world, relative, distance, change), null, null, true);
  }
  getBoxPointByInner(inner2, _relative, _distance, change) {
    const point2 = change ? inner2 : Object.assign({}, inner2), { x, y } = this.boxBounds;
    move(point2, -x, -y);
    return point2;
  }
  getInnerPoint(world, relative, distance, change) {
    const point2 = change ? world : {};
    this.worldToInner(world, point2, distance, relative);
    return point2;
  }
  getInnerPointByBox(box3, _relative, _distance, change) {
    const point2 = change ? box3 : Object.assign({}, box3), { x, y } = this.boxBounds;
    move(point2, x, y);
    return point2;
  }
  getInnerPointByLocal(local, _relative, distance, change) {
    return this.getInnerPoint(local, this.parent, distance, change);
  }
  getLocalPoint(world, relative, distance, change) {
    const point2 = change ? world : {};
    this.worldToLocal(world, point2, distance, relative);
    return point2;
  }
  getLocalPointByInner(inner2, _relative, distance, change) {
    return this.getWorldPoint(inner2, this.parent, distance, change);
  }
  getPagePoint(world, relative, distance, change) {
    const layer = this.leafer ? this.leafer.zoomLayer : this;
    return layer.getInnerPoint(world, relative, distance, change);
  }
  getWorldPoint(inner2, relative, distance, change) {
    const point2 = change ? inner2 : {};
    this.innerToWorld(inner2, point2, distance, relative);
    return point2;
  }
  getWorldPointByBox(box3, relative, distance, change) {
    return this.getWorldPoint(this.getInnerPointByBox(box3, null, null, change), relative, distance, true);
  }
  getWorldPointByLocal(local, relative, distance, change) {
    const point2 = change ? local : {};
    this.localToWorld(local, point2, distance, relative);
    return point2;
  }
  getWorldPointByPage(page, relative, distance, change) {
    const layer = this.leafer ? this.leafer.zoomLayer : this;
    return layer.getWorldPoint(page, relative, distance, change);
  }
  setTransform(matrix3, resize) {
    setTransform(this, matrix3, resize);
  }
  transform(matrix3, resize) {
    transform(this, matrix3, resize);
  }
  move(x, y, transition) {
    moveLocal(this, x, y, transition);
  }
  moveInner(x, y, transition) {
    moveWorld(this, x, y, true, transition);
  }
  scaleOf(origin2, scaleX, scaleY, resize) {
    zoomOfLocal(this, getLocalOrigin(this, origin2), scaleX, scaleY, resize);
  }
  rotateOf(origin2, rotation) {
    rotateOfLocal(this, getLocalOrigin(this, origin2), rotation);
  }
  skewOf(origin2, skewX, skewY, resize) {
    skewOfLocal(this, getLocalOrigin(this, origin2), skewX, skewY, resize);
  }
  transformWorld(worldTransform, resize) {
    transformWorld(this, worldTransform, resize);
  }
  moveWorld(x, y, transition) {
    moveWorld(this, x, y, false, transition);
  }
  scaleOfWorld(worldOrigin, scaleX, scaleY, resize) {
    zoomOfWorld(this, worldOrigin, scaleX, scaleY, resize);
  }
  rotateOfWorld(worldOrigin, rotation) {
    rotateOfWorld(this, worldOrigin, rotation);
  }
  skewOfWorld(worldOrigin, skewX, skewY, resize) {
    skewOfWorld(this, worldOrigin, skewX, skewY, resize);
  }
  flip(axis) {
    transform(this, getFlipTransform(this, axis));
  }
  scaleResize(scaleX, scaleY = scaleX, _noResize) {
    this.scaleX *= scaleX;
    this.scaleY *= scaleY;
  }
  __scaleResize(_scaleX, _scaleY) {
  }
  resizeWidth(_width) {
  }
  resizeHeight(_height) {
  }
  __hitWorld(_point) {
    return true;
  }
  __hit(_local) {
    return true;
  }
  __hitFill(_inner) {
    return true;
  }
  __hitStroke(_inner, _strokeWidth) {
    return true;
  }
  __hitPixel(_inner) {
    return true;
  }
  __drawHitPath(_canvas) {
  }
  __updateHitCanvas() {
  }
  __render(_canvas, _options) {
  }
  __drawFast(_canvas, _options) {
  }
  __draw(_canvas, _options) {
  }
  __clip(_canvas, _options) {
  }
  __renderShape(_canvas, _options, _ignoreFill, _ignoreStroke) {
  }
  __updateWorldOpacity() {
  }
  __updateChange() {
  }
  __drawPath(_canvas) {
  }
  __drawRenderPath(_canvas) {
  }
  __updatePath() {
  }
  __updateRenderPath() {
  }
  getMotionPathData() {
    return needPlugin("path");
  }
  getMotionPoint(_motionDistance) {
    return needPlugin("path");
  }
  getMotionTotal() {
    return 0;
  }
  __updateMotionPath() {
  }
  __runAnimation(_type, _complete) {
  }
  __updateSortChildren() {
  }
  add(_child, _index) {
  }
  remove(_child, destroy2) {
    if (this.parent)
      this.parent.remove(this, destroy2);
  }
  dropTo(parent, index, resize) {
    drop(this, parent, index, resize);
  }
  on(_type, _listener, _options) {
  }
  off(_type, _listener, _options) {
  }
  on_(_type, _listener, _bind, _options) {
    return void 0;
  }
  off_(_id) {
  }
  once(_type, _listener, _capture) {
  }
  emit(_type, _event, _capture) {
  }
  emitEvent(_event, _capture) {
  }
  hasEvent(_type, _capture) {
    return false;
  }
  static changeAttr(attrName, defaultValue, fn) {
    fn ? this.addAttr(attrName, defaultValue, fn) : defineDataProcessor(this.prototype, attrName, defaultValue);
  }
  static addAttr(attrName, defaultValue, fn) {
    if (!fn)
      fn = boundsType;
    fn(defaultValue)(this.prototype, attrName);
  }
  __emitLifeEvent(type) {
    if (this.hasEvent(type))
      this.emitEvent(new ChildEvent(type, this, this.parent));
  }
  destroy() {
    if (!this.destroyed) {
      if (this.parent)
        this.remove();
      if (this.children)
        this.clear();
      this.__emitLifeEvent(ChildEvent.DESTROY);
      this.__.destroy();
      this.__layout.destroy();
      this.destroyEventer();
      this.destroyed = true;
    }
  }
};
Leaf = __decorate([
  useModule(LeafDataProxy),
  useModule(LeafMatrix),
  useModule(LeafBounds),
  useModule(LeafEventer),
  useModule(LeafRender)
], Leaf);
var { setListWithFn } = BoundsHelper;
var { sort } = BranchHelper;
var { localBoxBounds, localStrokeBounds, localRenderBounds, maskLocalBoxBounds, maskLocalStrokeBounds, maskLocalRenderBounds } = LeafBoundsHelper;
var Branch = class Branch2 extends Leaf {
  __updateStrokeSpread() {
    const { children } = this;
    for (let i = 0, len = children.length; i < len; i++) {
      if (children[i].__layout.strokeSpread)
        return 1;
    }
    return 0;
  }
  __updateRenderSpread() {
    const { children } = this;
    for (let i = 0, len = children.length; i < len; i++) {
      if (children[i].__layout.renderSpread)
        return 1;
    }
    return 0;
  }
  __updateBoxBounds() {
    setListWithFn(this.__layout.boxBounds, this.children, this.__hasMask ? maskLocalBoxBounds : localBoxBounds);
  }
  __updateStrokeBounds() {
    setListWithFn(this.__layout.strokeBounds, this.children, this.__hasMask ? maskLocalStrokeBounds : localStrokeBounds);
  }
  __updateRenderBounds() {
    setListWithFn(this.__layout.renderBounds, this.children, this.__hasMask ? maskLocalRenderBounds : localRenderBounds);
  }
  __updateSortChildren() {
    let affectSort;
    const { children } = this;
    if (children.length > 1) {
      for (let i = 0, len = children.length; i < len; i++) {
        children[i].__tempNumber = i;
        if (children[i].__.zIndex)
          affectSort = true;
      }
      children.sort(sort);
      this.__layout.affectChildrenSort = affectSort;
    }
  }
  add(child, index) {
    if (child === this)
      return;
    const noIndex = index === void 0;
    if (!child.__) {
      if (child instanceof Array)
        return child.forEach((item) => {
          this.add(item, index);
          noIndex || index++;
        });
      else
        child = UICreator.get(child.tag, child);
    }
    if (child.parent)
      child.parent.remove(child);
    child.parent = this;
    noIndex ? this.children.push(child) : this.children.splice(index, 0, child);
    if (child.isBranch)
      this.__.__childBranchNumber = (this.__.__childBranchNumber || 0) + 1;
    child.__layout.boxChanged || child.__layout.boxChange();
    child.__layout.matrixChanged || child.__layout.matrixChange();
    if (child.__bubbleMap)
      child.__emitLifeEvent(ChildEvent.ADD);
    if (this.leafer) {
      child.__bindLeafer(this.leafer);
      if (this.leafer.created)
        this.__emitChildEvent(ChildEvent.ADD, child);
    }
    this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
  }
  addMany(...children) {
    this.add(children);
  }
  remove(child, destroy2) {
    if (child) {
      if (child.__) {
        if (child.animationOut)
          child.__runAnimation("out", () => this.__remove(child, destroy2));
        else
          this.__remove(child, destroy2);
      } else
        this.find(child).forEach((item) => this.remove(item, destroy2));
    } else if (child === void 0) {
      super.remove(null, destroy2);
    }
  }
  removeAll(destroy2) {
    const { children } = this;
    if (children.length) {
      this.children = [];
      this.__preRemove();
      this.__.__childBranchNumber = 0;
      children.forEach((child) => {
        this.__realRemoveChild(child);
        if (destroy2)
          child.destroy();
      });
    }
  }
  clear() {
    this.removeAll(true);
  }
  __remove(child, destroy2) {
    const index = this.children.indexOf(child);
    if (index > -1) {
      this.children.splice(index, 1);
      if (child.isBranch)
        this.__.__childBranchNumber = (this.__.__childBranchNumber || 1) - 1;
      this.__preRemove();
      this.__realRemoveChild(child);
      if (destroy2)
        child.destroy();
    }
  }
  __preRemove() {
    if (this.__hasMask)
      this.__updateMask();
    if (this.__hasEraser)
      this.__updateEraser();
    this.__layout.boxChange();
    this.__layout.affectChildrenSort && this.__layout.childrenSortChange();
  }
  __realRemoveChild(child) {
    child.__emitLifeEvent(ChildEvent.REMOVE);
    child.parent = null;
    if (this.leafer) {
      child.__bindLeafer(null);
      if (this.leafer.created) {
        this.__emitChildEvent(ChildEvent.REMOVE, child);
        if (this.leafer.hitCanvasManager)
          this.leafer.hitCanvasManager.clear();
      }
    }
  }
  __emitChildEvent(type, child) {
    const event = new ChildEvent(type, child, this);
    if (this.hasEvent(type) && !this.isLeafer)
      this.emitEvent(event);
    this.leafer.emitEvent(event);
  }
};
Branch = __decorate([
  useModule(BranchRender)
], Branch);
var LeafList = class _LeafList {
  get length() {
    return this.list.length;
  }
  constructor(item) {
    this.reset();
    if (item)
      item instanceof Array ? this.addList(item) : this.add(item);
  }
  has(leaf2) {
    return leaf2 && this.keys[leaf2.innerId] !== void 0;
  }
  indexAt(index) {
    return this.list[index];
  }
  indexOf(leaf2) {
    const index = this.keys[leaf2.innerId];
    return index === void 0 ? -1 : index;
  }
  add(leaf2) {
    const { list: list3, keys } = this;
    if (keys[leaf2.innerId] === void 0) {
      list3.push(leaf2);
      keys[leaf2.innerId] = list3.length - 1;
    }
  }
  addAt(leaf2, index = 0) {
    const { keys } = this;
    if (keys[leaf2.innerId] === void 0) {
      const { list: list3 } = this;
      for (let i = index, len = list3.length; i < len; i++)
        keys[list3[i].innerId]++;
      if (index === 0) {
        list3.unshift(leaf2);
      } else {
        if (index > list3.length)
          index = list3.length;
        list3.splice(index, 0, leaf2);
      }
      keys[leaf2.innerId] = index;
    }
  }
  addList(list3) {
    for (let i = 0; i < list3.length; i++)
      this.add(list3[i]);
  }
  remove(leaf2) {
    const { list: list3 } = this;
    let findIndex;
    for (let i = 0, len = list3.length; i < len; i++) {
      if (findIndex !== void 0) {
        this.keys[list3[i].innerId] = i - 1;
      } else if (list3[i].innerId === leaf2.innerId) {
        findIndex = i;
        delete this.keys[leaf2.innerId];
      }
    }
    if (findIndex !== void 0)
      list3.splice(findIndex, 1);
  }
  sort(reverse) {
    const { list: list3 } = this;
    if (reverse) {
      list3.sort((a2, b) => b.__level - a2.__level);
    } else {
      list3.sort((a2, b) => a2.__level - b.__level);
    }
  }
  forEach(itemCallback) {
    this.list.forEach(itemCallback);
  }
  clone() {
    const list3 = new _LeafList();
    list3.list = [...this.list];
    list3.keys = Object.assign({}, this.keys);
    return list3;
  }
  update() {
    this.keys = {};
    const { list: list3, keys } = this;
    for (let i = 0, len = list3.length; i < len; i++)
      keys[list3[i].innerId] = i;
  }
  reset() {
    this.list = [];
    this.keys = {};
  }
  destroy() {
    this.reset();
  }
};
var LeafLevelList = class {
  get length() {
    return this._length;
  }
  constructor(item) {
    this._length = 0;
    this.reset();
    if (item)
      item instanceof Array ? this.addList(item) : this.add(item);
  }
  has(leaf2) {
    return this.keys[leaf2.innerId] !== void 0;
  }
  without(leaf2) {
    return this.keys[leaf2.innerId] === void 0;
  }
  sort(reverse) {
    const { levels } = this;
    if (reverse) {
      levels.sort((a2, b) => b - a2);
    } else {
      levels.sort((a2, b) => a2 - b);
    }
  }
  addList(list3) {
    list3.forEach((leaf2) => {
      this.add(leaf2);
    });
  }
  add(leaf2) {
    const { keys, levelMap } = this;
    if (!keys[leaf2.innerId]) {
      keys[leaf2.innerId] = 1;
      if (!levelMap[leaf2.__level]) {
        levelMap[leaf2.__level] = [leaf2];
        this.levels.push(leaf2.__level);
      } else {
        levelMap[leaf2.__level].push(leaf2);
      }
      this._length++;
    }
  }
  forEach(itemCallback) {
    let list3;
    this.levels.forEach((level) => {
      list3 = this.levelMap[level];
      for (let i = 0, len = list3.length; i < len; i++) {
        itemCallback(list3[i]);
      }
    });
  }
  reset() {
    this.levelMap = {};
    this.keys = {};
    this.levels = [];
    this._length = 0;
  }
  destroy() {
    this.levelMap = null;
  }
};
var version = "1.1.0";

// node_modules/@leafer-ui/draw/lib/draw.esm.js
function __decorate2(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
function effectType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      if (value)
        this.__.__useEffect = true;
      this.__layout.renderChanged || this.__layout.renderChange();
    }
  }));
}
function resizeType(defaultValue) {
  return decorateLeafAttr(defaultValue, (key) => attr({
    set(value) {
      this.__setAttr(key, value);
      this.__layout.boxChanged || this.__layout.boxChange();
      this.__updateSize();
    }
  }));
}
function zoomLayerType() {
  return (target, key) => {
    const privateKey = "_" + key;
    defineKey(target, key, {
      set(value) {
        if (this.isLeafer)
          this[privateKey] = value;
      },
      get() {
        return this.isApp ? this.tree.zoomLayer : this.isLeafer ? this[privateKey] || this : this.leafer && this.leafer.zoomLayer;
      }
    });
  };
}
var TextConvert = {};
var ColorConvert = {};
var UnitConvert = {
  number(value, percentRefer) {
    if (typeof value === "object")
      return value.type === "percent" ? value.value * percentRefer : value.value;
    return value;
  }
};
var PathArrow = {};
var Paint = {};
var PaintImage = {};
var PaintGradient = {};
var Effect = {};
var Export = {};
var State = {
  setStyleName(_leaf, _styleName, _value) {
    return needPlugin("state");
  },
  set(_leaf, _stateName) {
    return needPlugin("state");
  }
};
var Transition = {
  list: {},
  register(attrName, fn) {
    Transition.list[attrName] = fn;
  },
  get(attrName) {
    return Transition.list[attrName];
  }
};
var { parse, objectToCanvasData } = PathConvert;
var emptyPaint = {};
var debug$12 = Debug.get("UIData");
var UIData = class extends LeafData {
  get scale() {
    const { scaleX, scaleY } = this;
    return scaleX !== scaleY ? { x: scaleX, y: scaleY } : scaleX;
  }
  get __strokeWidth() {
    const { strokeWidth, strokeWidthFixed } = this;
    if (strokeWidthFixed) {
      const ui2 = this.__leaf;
      let { scaleX } = ui2.__nowWorld || ui2.__world;
      if (scaleX < 0)
        scaleX = -scaleX;
      return scaleX > 1 ? strokeWidth / scaleX : strokeWidth;
    } else
      return strokeWidth;
  }
  get __hasStroke() {
    return this.stroke && this.strokeWidth;
  }
  get __hasMultiPaint() {
    const t2 = this;
    if (t2.__isFills && t2.fill.length > 1 || t2.__isStrokes && t2.stroke.length > 1 || t2.__useEffect)
      return true;
    return t2.fill && this.__hasStroke;
  }
  get __clipAfterFill() {
    return this.cornerRadius || this.__pathInputed;
  }
  get __autoWidth() {
    return !this._width;
  }
  get __autoHeight() {
    return !this._height;
  }
  get __autoSide() {
    return !this._width || !this._height;
  }
  get __autoSize() {
    return !this._width && !this._height;
  }
  setVisible(value) {
    this._visible = value;
    const { leafer: leafer2 } = this.__leaf;
    if (leafer2)
      leafer2.watcher.hasVisible = true;
  }
  setWidth(value) {
    if (value < 0) {
      this._width = -value;
      this.__leaf.scaleX *= -1;
      debug$12.warn("width < 0, instead -scaleX ", this);
    } else
      this._width = value;
  }
  setHeight(value) {
    if (value < 0) {
      this._height = -value;
      this.__leaf.scaleY *= -1;
      debug$12.warn("height < 0, instead -scaleY", this);
    } else
      this._height = value;
  }
  setFill(value) {
    if (this.__naturalWidth)
      this.__removeNaturalSize();
    if (typeof value === "string" || !value) {
      if (this.__isFills) {
        this.__removeInput("fill");
        PaintImage.recycleImage("fill", this);
        this.__isFills = false;
        if (this.__pixelFill)
          this.__pixelFill = false;
      }
      this._fill = value;
    } else if (typeof value === "object") {
      this.__setInput("fill", value);
      this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange();
      this.__isFills = true;
      this._fill || (this._fill = emptyPaint);
    }
  }
  setStroke(value) {
    if (typeof value === "string" || !value) {
      if (this.__isStrokes) {
        this.__removeInput("stroke");
        PaintImage.recycleImage("stroke", this);
        this.__isStrokes = false;
        if (this.__pixelStroke)
          this.__pixelStroke = false;
      }
      this._stroke = value;
    } else if (typeof value === "object") {
      this.__setInput("stroke", value);
      this.__leaf.__layout.boxChanged || this.__leaf.__layout.boxChange();
      this.__isStrokes = true;
      this._stroke || (this._stroke = emptyPaint);
    }
  }
  setPath(value) {
    const isString = typeof value === "string";
    if (isString || value && typeof value[0] === "object") {
      this.__setInput("path", value);
      this._path = isString ? parse(value) : objectToCanvasData(value);
    } else {
      if (this.__input)
        this.__removeInput("path");
      this._path = value;
    }
  }
  setShadow(value) {
    this.__setInput("shadow", value);
    if (value instanceof Array) {
      if (value.some((item) => item.visible === false))
        value = value.filter((item) => item.visible !== false);
      this._shadow = value.length ? value : null;
    } else
      this._shadow = value && value.visible !== false ? [value] : null;
  }
  setInnerShadow(value) {
    this.__setInput("innerShadow", value);
    if (value instanceof Array) {
      if (value.some((item) => item.visible === false))
        value = value.filter((item) => item.visible !== false);
      this._innerShadow = value.length ? value : null;
    } else
      this._innerShadow = value && value.visible !== false ? [value] : null;
  }
  __computePaint() {
    const { fill: fill2, stroke: stroke2 } = this.__input;
    if (fill2)
      Paint.compute("fill", this.__leaf);
    if (stroke2)
      Paint.compute("stroke", this.__leaf);
    this.__needComputePaint = false;
  }
};
var GroupData = class extends UIData {
};
var BoxData = class extends GroupData {
  get __boxStroke() {
    return !this.__pathInputed;
  }
  get __drawAfterFill() {
    return this.overflow === "hide" && this.__clipAfterFill && this.__leaf.children.length;
  }
  get __clipAfterFill() {
    return this.__leaf.isOverflow || super.__clipAfterFill;
  }
};
var LeaferData = class extends GroupData {
  __getInputData(names, options) {
    const data = super.__getInputData(names, options);
    canvasSizeAttrs.forEach((key) => delete data[key]);
    return data;
  }
};
var FrameData = class extends BoxData {
};
var LineData = class extends UIData {
};
var RectData = class extends UIData {
  get __boxStroke() {
    return !this.__pathInputed;
  }
};
var EllipseData = class extends UIData {
  get __boxStroke() {
    return !this.__pathInputed;
  }
};
var PolygonData = class extends UIData {
};
var StarData = class extends UIData {
};
var PathData = class extends UIData {
  get __pathInputed() {
    return 2;
  }
};
var PenData = class extends GroupData {
};
var fontWeightMap = {
  "thin": 100,
  "extra-light": 200,
  "light": 300,
  "normal": 400,
  "medium": 500,
  "semi-bold": 600,
  "bold": 700,
  "extra-bold": 800,
  "black": 900
};
var TextData = class extends UIData {
  get __useNaturalRatio() {
    return false;
  }
  setFontWeight(value) {
    if (typeof value === "string") {
      this.__setInput("fontWeight", value);
      this._fontWeight = fontWeightMap[value] || 400;
    } else {
      if (this.__input)
        this.__removeInput("fontWeight");
      this._fontWeight = value;
    }
  }
};
var ImageData = class extends RectData {
  setUrl(value) {
    this.__setImageFill(value);
    this._url = value;
  }
  __setImageFill(value) {
    if (this.__leaf.image)
      this.__leaf.image = null;
    this.fill = value ? { type: "image", mode: "stretch", url: value } : void 0;
  }
  __getData() {
    const data = super.__getData();
    delete data.fill;
    return data;
  }
  __getInputData(names, options) {
    const data = super.__getInputData(names, options);
    delete data.fill;
    return data;
  }
};
var CanvasData = class extends RectData {
  get __isCanvas() {
    return true;
  }
  get __drawAfterFill() {
    return true;
  }
  __getInputData(names, options) {
    const data = super.__getInputData(names, options);
    data.url = this.__leaf.canvas.toDataURL("image/png");
    return data;
  }
};
var UIBounds = {
  __updateStrokeSpread() {
    let width = 0, boxWidth = 0;
    const data = this.__, { strokeAlign, strokeWidth } = data;
    if ((data.stroke || data.hitStroke === "all") && strokeWidth && strokeAlign !== "inside") {
      boxWidth = width = strokeAlign === "center" ? strokeWidth / 2 : strokeWidth;
      if (!data.__boxStroke) {
        const miterLimitAddWidth = data.__isLinePath ? 0 : 10 * width;
        const storkeCapAddWidth = data.strokeCap === "none" ? 0 : strokeWidth;
        width += Math.max(miterLimitAddWidth, storkeCapAddWidth);
      }
    }
    if (data.__useArrow)
      width += strokeWidth * 5;
    this.__layout.strokeBoxSpread = boxWidth;
    return width;
  },
  __updateRenderSpread() {
    let width = 0;
    const { shadow: shadow2, innerShadow: innerShadow2, blur: blur2, backgroundBlur: backgroundBlur2 } = this.__;
    if (shadow2)
      shadow2.forEach((item) => width = Math.max(width, Math.max(Math.abs(item.y), Math.abs(item.x)) + (item.spread > 0 ? item.spread : 0) + item.blur * 1.5));
    if (blur2)
      width = Math.max(width, blur2);
    let shapeWidth = width = Math.ceil(width);
    if (innerShadow2)
      innerShadow2.forEach((item) => shapeWidth = Math.max(shapeWidth, Math.max(Math.abs(item.y), Math.abs(item.x)) + (item.spread < 0 ? -item.spread : 0) + item.blur * 1.5));
    if (backgroundBlur2)
      shapeWidth = Math.max(shapeWidth, backgroundBlur2);
    this.__layout.renderShapeSpread = shapeWidth;
    return width + (this.__layout.strokeSpread || 0);
  }
};
var UIRender = {
  __updateChange() {
    const data = this.__;
    if (data.__useEffect) {
      const { shadow: shadow2, innerShadow: innerShadow2, blur: blur2, backgroundBlur: backgroundBlur2 } = this.__;
      data.__useEffect = !!(shadow2 || innerShadow2 || blur2 || backgroundBlur2);
    }
    data.__checkSingle();
    const complex = data.__isFills || data.__isStrokes || data.cornerRadius || data.__useEffect;
    if (complex) {
      data.__complex = true;
    } else {
      data.__complex && (data.__complex = false);
    }
  },
  __drawFast(canvas3, options) {
    drawFast(this, canvas3, options);
  },
  __draw(canvas3, options) {
    const data = this.__;
    if (data.__complex) {
      if (data.__needComputePaint)
        data.__computePaint();
      const { fill: fill2, stroke: stroke2, __drawAfterFill } = data;
      this.__drawRenderPath(canvas3);
      if (data.__useEffect) {
        const shape2 = Paint.shape(this, canvas3, options);
        this.__nowWorld = this.__getNowWorld(options);
        const { shadow: shadow2, innerShadow: innerShadow2 } = data;
        if (shadow2)
          Effect.shadow(this, canvas3, shape2);
        if (fill2)
          data.__isFills ? Paint.fills(fill2, this, canvas3) : Paint.fill(fill2, this, canvas3);
        if (__drawAfterFill)
          this.__drawAfterFill(canvas3, options);
        if (innerShadow2)
          Effect.innerShadow(this, canvas3, shape2);
        if (stroke2)
          data.__isStrokes ? Paint.strokes(stroke2, this, canvas3) : Paint.stroke(stroke2, this, canvas3);
        if (shape2.worldCanvas)
          shape2.worldCanvas.recycle();
        shape2.canvas.recycle();
      } else {
        if (fill2)
          data.__isFills ? Paint.fills(fill2, this, canvas3) : Paint.fill(fill2, this, canvas3);
        if (__drawAfterFill)
          this.__drawAfterFill(canvas3, options);
        if (stroke2)
          data.__isStrokes ? Paint.strokes(stroke2, this, canvas3) : Paint.stroke(stroke2, this, canvas3);
      }
    } else {
      if (data.__pathInputed) {
        drawFast(this, canvas3, options);
      } else {
        this.__drawFast(canvas3, options);
      }
    }
  },
  __renderShape(canvas3, options, ignoreFill, ignoreStroke) {
    if (this.__worldOpacity) {
      canvas3.setWorld(this.__nowWorld = this.__getNowWorld(options));
      const { fill: fill2, stroke: stroke2 } = this.__;
      this.__drawRenderPath(canvas3);
      if (fill2 && !ignoreFill)
        this.__.__pixelFill ? Paint.fills(fill2, this, canvas3) : Paint.fill("#000000", this, canvas3);
      if (this.__.__isCanvas)
        this.__drawAfterFill(canvas3, options);
      if (stroke2 && !ignoreStroke)
        this.__.__pixelStroke ? Paint.strokes(stroke2, this, canvas3) : Paint.stroke("#000000", this, canvas3);
    }
  },
  __drawAfterFill(canvas3, options) {
    if (this.__.__clipAfterFill) {
      canvas3.save();
      this.windingRule ? canvas3.clip(this.windingRule) : canvas3.clip();
      this.__drawContent(canvas3, options);
      canvas3.restore();
    } else
      this.__drawContent(canvas3, options);
  }
};
function drawFast(ui2, canvas3, options) {
  const { fill: fill2, stroke: stroke2, __drawAfterFill } = ui2.__;
  ui2.__drawRenderPath(canvas3);
  if (fill2)
    Paint.fill(fill2, ui2, canvas3);
  if (__drawAfterFill)
    ui2.__drawAfterFill(canvas3, options);
  if (stroke2)
    Paint.stroke(stroke2, ui2, canvas3);
}
var RectRender = {
  __drawFast(canvas3, options) {
    let { width, height, fill: fill2, stroke: stroke2, __drawAfterFill } = this.__;
    if (fill2) {
      canvas3.fillStyle = fill2;
      canvas3.fillRect(0, 0, width, height);
    }
    if (__drawAfterFill)
      this.__drawAfterFill(canvas3, options);
    if (stroke2) {
      const { strokeAlign, __strokeWidth } = this.__;
      if (!__strokeWidth)
        return;
      canvas3.setStroke(stroke2, __strokeWidth, this.__);
      const half = __strokeWidth / 2;
      switch (strokeAlign) {
        case "center":
          canvas3.strokeRect(0, 0, width, height);
          break;
        case "inside":
          width -= __strokeWidth, height -= __strokeWidth;
          if (width < 0 || height < 0) {
            canvas3.save();
            this.__clip(canvas3, options);
            canvas3.strokeRect(half, half, width, height);
            canvas3.restore();
          } else
            canvas3.strokeRect(half, half, width, height);
          break;
        case "outside":
          canvas3.strokeRect(-half, -half, width + __strokeWidth, height + __strokeWidth);
          break;
      }
    }
  }
};
var UI_1;
var UI = UI_1 = class UI2 extends Leaf {
  get app() {
    return this.leafer && this.leafer.app;
  }
  get isFrame() {
    return false;
  }
  set scale(value) {
    MathHelper.assignScale(this, value);
  }
  get scale() {
    return this.__.scale;
  }
  get pen() {
    const { path } = this.__;
    pen.set(this.path = path || []);
    if (!path)
      this.__drawPathByBox(pen);
    return pen;
  }
  get editConfig() {
    return void 0;
  }
  get editOuter() {
    return "";
  }
  get editInner() {
    return "";
  }
  constructor(data) {
    super(data);
  }
  reset(_data) {
  }
  set(data, transition) {
    if (transition) {
      if (transition === "temp") {
        this.lockNormalStyle = true;
        Object.assign(this, data);
        this.lockNormalStyle = false;
      } else
        this.animate(data, transition);
    } else
      Object.assign(this, data);
  }
  get(name) {
    return typeof name === "string" ? this.__.__getInput(name) : this.__.__getInputData(name);
  }
  createProxyData() {
    return void 0;
  }
  find(_condition, _options) {
    return void 0;
  }
  findTag(tag) {
    return this.find({ tag });
  }
  findOne(_condition, _options) {
    return void 0;
  }
  findId(id) {
    return this.findOne({ id });
  }
  getPath(curve, pathForRender) {
    this.__layout.update();
    let path = pathForRender ? this.__.__pathForRender : this.__.path;
    if (!path)
      pen.set(path = []), this.__drawPathByBox(pen);
    return curve ? PathConvert.toCanvasData(path, true) : path;
  }
  getPathString(curve, pathForRender, floatLength) {
    return PathConvert.stringify(this.getPath(curve, pathForRender), floatLength);
  }
  load() {
    this.__.__computePaint();
  }
  __onUpdateSize() {
    if (this.__.__input) {
      const data = this.__;
      data.lazy && !this.__inLazyBounds && !Export.running ? data.__needComputePaint = true : data.__computePaint();
    }
  }
  __updateRenderPath() {
    if (this.__.path) {
      const data = this.__;
      data.__pathForRender = data.cornerRadius ? PathCorner.smooth(data.path, data.cornerRadius, data.cornerSmoothing) : data.path;
      if (data.__useArrow)
        PathArrow.addArrows(this, !data.cornerRadius);
    }
  }
  __drawRenderPath(canvas3) {
    canvas3.beginPath();
    this.__drawPathByData(canvas3, this.__.__pathForRender);
  }
  __drawPath(canvas3) {
    canvas3.beginPath();
    this.__drawPathByData(canvas3, this.__.path);
  }
  __drawPathByData(drawer, data) {
    data ? PathDrawer.drawPathByData(drawer, data) : this.__drawPathByBox(drawer);
  }
  __drawPathByBox(drawer) {
    const { x, y, width, height } = this.__layout.boxBounds;
    if (this.__.cornerRadius) {
      const { cornerRadius } = this.__;
      drawer.roundRect(x, y, width, height, typeof cornerRadius === "number" ? [cornerRadius] : cornerRadius);
    } else
      drawer.rect(x, y, width, height);
  }
  animate(_keyframe, _options, _type, _isTemp) {
    return needPlugin("animate");
  }
  killAnimate(_type) {
  }
  export(filename, options) {
    return Export.export(this, filename, options);
  }
  clone(data) {
    const json = this.toJSON();
    if (data)
      Object.assign(json, data);
    return UI_1.one(json);
  }
  static one(data, x, y, width, height) {
    return UICreator.get(data.tag || this.prototype.__tag, data, x, y, width, height);
  }
  static registerUI() {
    registerUI()(this);
  }
  static registerData(data) {
    dataProcessor(data)(this.prototype);
  }
  static setEditConfig(_config) {
  }
  static setEditOuter(_toolName) {
  }
  static setEditInner(_editorName) {
  }
  destroy() {
    this.fill = this.stroke = null;
    if (this.__animate)
      this.killAnimate();
    super.destroy();
  }
};
__decorate2([
  dataProcessor(UIData)
], UI.prototype, "__", void 0);
__decorate2([
  zoomLayerType()
], UI.prototype, "zoomLayer", void 0);
__decorate2([
  dataType("")
], UI.prototype, "id", void 0);
__decorate2([
  dataType("")
], UI.prototype, "name", void 0);
__decorate2([
  dataType("")
], UI.prototype, "className", void 0);
__decorate2([
  surfaceType("pass-through")
], UI.prototype, "blendMode", void 0);
__decorate2([
  opacityType(1)
], UI.prototype, "opacity", void 0);
__decorate2([
  visibleType(true)
], UI.prototype, "visible", void 0);
__decorate2([
  surfaceType(false)
], UI.prototype, "locked", void 0);
__decorate2([
  sortType(0)
], UI.prototype, "zIndex", void 0);
__decorate2([
  maskType(false)
], UI.prototype, "mask", void 0);
__decorate2([
  eraserType(false)
], UI.prototype, "eraser", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "x", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "y", void 0);
__decorate2([
  boundsType(100, true)
], UI.prototype, "width", void 0);
__decorate2([
  boundsType(100, true)
], UI.prototype, "height", void 0);
__decorate2([
  scaleType(1, true)
], UI.prototype, "scaleX", void 0);
__decorate2([
  scaleType(1, true)
], UI.prototype, "scaleY", void 0);
__decorate2([
  rotationType(0, true)
], UI.prototype, "rotation", void 0);
__decorate2([
  rotationType(0, true)
], UI.prototype, "skewX", void 0);
__decorate2([
  rotationType(0, true)
], UI.prototype, "skewY", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "offsetX", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "offsetY", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "scrollX", void 0);
__decorate2([
  positionType(0, true)
], UI.prototype, "scrollY", void 0);
__decorate2([
  autoLayoutType()
], UI.prototype, "origin", void 0);
__decorate2([
  autoLayoutType()
], UI.prototype, "around", void 0);
__decorate2([
  dataType(false)
], UI.prototype, "lazy", void 0);
__decorate2([
  naturalBoundsType(1)
], UI.prototype, "pixelRatio", void 0);
__decorate2([
  pathInputType()
], UI.prototype, "path", void 0);
__decorate2([
  pathType()
], UI.prototype, "windingRule", void 0);
__decorate2([
  pathType(true)
], UI.prototype, "closed", void 0);
__decorate2([
  boundsType(0)
], UI.prototype, "padding", void 0);
__decorate2([
  boundsType(false)
], UI.prototype, "lockRatio", void 0);
__decorate2([
  boundsType()
], UI.prototype, "widthRange", void 0);
__decorate2([
  boundsType()
], UI.prototype, "heightRange", void 0);
__decorate2([
  dataType(false)
], UI.prototype, "draggable", void 0);
__decorate2([
  dataType()
], UI.prototype, "dragBounds", void 0);
__decorate2([
  dataType(false)
], UI.prototype, "editable", void 0);
__decorate2([
  hitType(true)
], UI.prototype, "hittable", void 0);
__decorate2([
  hitType("path")
], UI.prototype, "hitFill", void 0);
__decorate2([
  strokeType("path")
], UI.prototype, "hitStroke", void 0);
__decorate2([
  hitType(false)
], UI.prototype, "hitBox", void 0);
__decorate2([
  hitType(true)
], UI.prototype, "hitChildren", void 0);
__decorate2([
  hitType(true)
], UI.prototype, "hitSelf", void 0);
__decorate2([
  hitType()
], UI.prototype, "hitRadius", void 0);
__decorate2([
  cursorType("")
], UI.prototype, "cursor", void 0);
__decorate2([
  surfaceType()
], UI.prototype, "fill", void 0);
__decorate2([
  strokeType()
], UI.prototype, "stroke", void 0);
__decorate2([
  strokeType("inside")
], UI.prototype, "strokeAlign", void 0);
__decorate2([
  strokeType(1)
], UI.prototype, "strokeWidth", void 0);
__decorate2([
  strokeType(false)
], UI.prototype, "strokeWidthFixed", void 0);
__decorate2([
  strokeType("none")
], UI.prototype, "strokeCap", void 0);
__decorate2([
  strokeType("miter")
], UI.prototype, "strokeJoin", void 0);
__decorate2([
  strokeType()
], UI.prototype, "dashPattern", void 0);
__decorate2([
  strokeType()
], UI.prototype, "dashOffset", void 0);
__decorate2([
  strokeType(10)
], UI.prototype, "miterLimit", void 0);
__decorate2([
  pathType(0)
], UI.prototype, "cornerRadius", void 0);
__decorate2([
  pathType()
], UI.prototype, "cornerSmoothing", void 0);
__decorate2([
  effectType()
], UI.prototype, "shadow", void 0);
__decorate2([
  effectType()
], UI.prototype, "innerShadow", void 0);
__decorate2([
  effectType()
], UI.prototype, "blur", void 0);
__decorate2([
  effectType()
], UI.prototype, "backgroundBlur", void 0);
__decorate2([
  effectType()
], UI.prototype, "grayscale", void 0);
__decorate2([
  dataType({})
], UI.prototype, "data", void 0);
__decorate2([
  rewrite(Leaf.prototype.reset)
], UI.prototype, "reset", null);
UI = UI_1 = __decorate2([
  useModule(UIBounds),
  useModule(UIRender),
  rewriteAble()
], UI);
var Group = class Group2 extends UI {
  get __tag() {
    return "Group";
  }
  get isBranch() {
    return true;
  }
  constructor(data) {
    super(data);
  }
  reset(data) {
    this.__setBranch();
    super.reset(data);
  }
  __setBranch() {
    if (!this.children)
      this.children = [];
  }
  set(data, transition) {
    if (data.children) {
      const { children } = data;
      delete data.children;
      this.children ? this.clear() : this.__setBranch();
      super.set(data, transition);
      children.forEach((child) => this.add(child));
      data.children = children;
    } else
      super.set(data, transition);
  }
  toJSON(options) {
    const data = super.toJSON(options);
    data.children = this.children.map((child) => child.toJSON(options));
    return data;
  }
  pick(_hitPoint, _options) {
    return void 0;
  }
  addAt(child, index) {
    this.add(child, index);
  }
  addAfter(child, after) {
    this.add(child, this.children.indexOf(after) + 1);
  }
  addBefore(child, before) {
    this.add(child, this.children.indexOf(before));
  }
  add(_child, _index) {
  }
  addMany(..._children) {
  }
  remove(_child, _destroy) {
  }
  removeAll(_destroy) {
  }
  clear() {
  }
};
__decorate2([
  dataProcessor(GroupData)
], Group.prototype, "__", void 0);
Group = __decorate2([
  useModule(Branch),
  registerUI()
], Group);
var Leafer_1;
var debug2 = Debug.get("Leafer");
var Leafer = Leafer_1 = class Leafer2 extends Group {
  get __tag() {
    return "Leafer";
  }
  get isApp() {
    return false;
  }
  get app() {
    return this.parent || this;
  }
  get isLeafer() {
    return true;
  }
  get imageReady() {
    return this.viewReady && ImageManager.isComplete;
  }
  get layoutLocked() {
    return !this.layouter.running;
  }
  get FPS() {
    return this.renderer ? this.renderer.FPS : 60;
  }
  get cursorPoint() {
    return this.interaction && this.interaction.hoverData || { x: this.width / 2, y: this.height / 2 };
  }
  get clientBounds() {
    return this.canvas && this.canvas.getClientBounds();
  }
  constructor(userConfig, data) {
    super(data);
    this.config = {
      type: "design",
      start: true,
      hittable: true,
      smooth: true,
      lazySpeard: 100,
      zoom: {
        min: 0.01,
        max: 256
      },
      move: {
        holdSpaceKey: true,
        holdMiddleKey: true,
        autoDistance: 2
      }
    };
    this.leafs = 0;
    this.__eventIds = [];
    this.__controllers = [];
    this.__readyWait = [];
    this.__viewReadyWait = [];
    this.__viewCompletedWait = [];
    this.__nextRenderWait = [];
    this.userConfig = userConfig;
    if (userConfig && (userConfig.view || userConfig.width))
      this.init(userConfig);
    Leafer_1.list.add(this);
  }
  init(userConfig, parentApp) {
    if (this.canvas)
      return;
    this.__setLeafer(this);
    if (userConfig)
      DataHelper.assign(this.config, userConfig);
    let start;
    const { config: config2 } = this;
    this.initType(config2.type);
    const canvas3 = this.canvas = Creator.canvas(config2);
    this.__controllers.push(this.renderer = Creator.renderer(this, canvas3, config2), this.watcher = Creator.watcher(this, config2), this.layouter = Creator.layouter(this, config2));
    if (this.isApp)
      this.__setApp();
    this.__checkAutoLayout(config2, parentApp);
    this.view = canvas3.view;
    if (parentApp) {
      this.__bindApp(parentApp);
      start = parentApp.running;
    } else {
      this.selector = Creator.selector(this);
      this.interaction = Creator.interaction(this, canvas3, this.selector, config2);
      if (this.interaction) {
        this.__controllers.unshift(this.interaction);
        this.hitCanvasManager = Creator.hitCanvasManager();
      }
      this.canvasManager = new CanvasManager();
      start = config2.start;
    }
    this.hittable = config2.hittable;
    this.fill = config2.fill;
    this.canvasManager.add(canvas3);
    this.__listenEvents();
    if (start)
      this.__startTimer = setTimeout(this.start.bind(this));
    WaitHelper.run(this.__initWait);
    this.onInit();
  }
  onInit() {
  }
  initType(_type) {
  }
  set(data, transition) {
    this.waitInit(() => {
      super.set(data, transition);
    });
  }
  start() {
    clearTimeout(this.__startTimer);
    if (!this.running && this.canvas) {
      this.running = true;
      this.ready ? this.emitLeafer(LeaferEvent.RESTART) : this.emitLeafer(LeaferEvent.START);
      this.__controllers.forEach((item) => item.start());
      if (!this.isApp)
        this.renderer.render();
    }
  }
  stop() {
    clearTimeout(this.__startTimer);
    if (this.running && this.canvas) {
      this.__controllers.forEach((item) => item.stop());
      this.running = false;
      this.emitLeafer(LeaferEvent.STOP);
    }
  }
  unlockLayout() {
    this.layouter.start();
    this.updateLayout();
  }
  lockLayout() {
    this.updateLayout();
    this.layouter.stop();
  }
  resize(size) {
    const data = DataHelper.copyAttrs({}, size, canvasSizeAttrs);
    Object.keys(data).forEach((key) => this[key] = data[key]);
  }
  forceRender(bounds2) {
    this.renderer.addBlock(bounds2 ? new Bounds(bounds2) : this.canvas.bounds);
    if (this.viewReady)
      this.renderer.update();
  }
  updateCursor(cursor) {
    const i = this.interaction;
    if (i)
      cursor ? i.setCursor(cursor) : i.updateCursor();
  }
  updateLazyBounds() {
    this.lazyBounds = this.canvas.bounds.clone().spread(this.config.lazySpeard);
  }
  __doResize(size) {
    const { canvas: canvas3 } = this;
    if (!canvas3 || canvas3.isSameSize(size))
      return;
    const old = DataHelper.copyAttrs({}, this.canvas, canvasSizeAttrs);
    canvas3.resize(size);
    this.updateLazyBounds();
    this.__onResize(new ResizeEvent(size, old));
  }
  __onResize(event) {
    this.emitEvent(event);
    DataHelper.copyAttrs(this.__, event, canvasSizeAttrs);
    setTimeout(() => {
      if (this.canvasManager)
        this.canvasManager.clearRecycled();
    }, 0);
  }
  __setApp() {
  }
  __bindApp(app) {
    this.selector = app.selector;
    this.interaction = app.interaction;
    this.canvasManager = app.canvasManager;
    this.hitCanvasManager = app.hitCanvasManager;
  }
  __setLeafer(leafer2) {
    this.leafer = leafer2;
    this.__level = 1;
  }
  __checkAutoLayout(config2, parentApp) {
    if (!parentApp) {
      if (!config2.width || !config2.height)
        this.autoLayout = new AutoBounds(config2);
      this.canvas.startAutoLayout(this.autoLayout, this.__onResize.bind(this));
    }
  }
  __setAttr(attrName, newValue) {
    if (this.canvas) {
      if (canvasSizeAttrs.includes(attrName)) {
        if (!newValue)
          debug2.warn(attrName + " is 0");
        this.__changeCanvasSize(attrName, newValue);
      } else if (attrName === "fill") {
        this.__changeFill(newValue);
      } else if (attrName === "hittable") {
        if (!this.parent)
          this.canvas.hittable = newValue;
      } else if (attrName === "zIndex") {
        this.canvas.zIndex = newValue;
        setTimeout(() => this.parent && this.parent.__updateSortChildren());
      }
    }
    return super.__setAttr(attrName, newValue);
  }
  __getAttr(attrName) {
    if (this.canvas && canvasSizeAttrs.includes(attrName))
      return this.canvas[attrName];
    return super.__getAttr(attrName);
  }
  __changeCanvasSize(attrName, newValue) {
    const data = DataHelper.copyAttrs({}, this.canvas, canvasSizeAttrs);
    data[attrName] = this.config[attrName] = newValue;
    if (newValue)
      this.canvas.stopAutoLayout();
    this.__doResize(data);
  }
  __changeFill(newValue) {
    this.config.fill = newValue;
    if (this.canvas.allowBackgroundColor)
      this.canvas.backgroundColor = newValue;
    else
      this.forceRender();
  }
  __onCreated() {
    this.created = true;
  }
  __onReady() {
    if (this.ready)
      return;
    this.ready = true;
    this.emitLeafer(LeaferEvent.BEFORE_READY);
    this.emitLeafer(LeaferEvent.READY);
    this.emitLeafer(LeaferEvent.AFTER_READY);
    WaitHelper.run(this.__readyWait);
  }
  __onViewReady() {
    if (this.viewReady)
      return;
    this.viewReady = true;
    this.emitLeafer(LeaferEvent.VIEW_READY);
    WaitHelper.run(this.__viewReadyWait);
  }
  __onNextRender() {
    if (this.viewReady) {
      WaitHelper.run(this.__nextRenderWait);
      const { imageReady } = this;
      if (imageReady && !this.viewCompleted)
        this.__checkViewCompleted();
      if (!imageReady)
        this.viewCompleted = false;
    }
  }
  __checkViewCompleted(emit4 = true) {
    this.nextRender(() => {
      if (this.imageReady) {
        if (emit4)
          this.emitLeafer(LeaferEvent.VIEW_COMPLETED);
        WaitHelper.run(this.__viewCompletedWait);
        this.viewCompleted = true;
      }
    });
  }
  __onWatchData() {
    if (this.watcher.childrenChanged && this.interaction) {
      this.nextRender(() => this.interaction.updateCursor());
    }
  }
  waitInit(item, bind) {
    if (bind)
      item = item.bind(bind);
    if (!this.__initWait)
      this.__initWait = [];
    this.canvas ? item() : this.__initWait.push(item);
  }
  waitReady(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.ready ? item() : this.__readyWait.push(item);
  }
  waitViewReady(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.viewReady ? item() : this.__viewReadyWait.push(item);
  }
  waitViewCompleted(item, bind) {
    if (bind)
      item = item.bind(bind);
    this.__viewCompletedWait.push(item);
    if (this.viewCompleted)
      this.__checkViewCompleted(false);
    else if (!this.running)
      this.start();
  }
  nextRender(item, bind, off2) {
    if (bind)
      item = item.bind(bind);
    const list3 = this.__nextRenderWait;
    if (off2) {
      for (let i = 0; i < list3.length; i++) {
        if (list3[i] === item) {
          list3.splice(i, 1);
          break;
        }
      }
    } else
      list3.push(item);
  }
  zoom(_zoomType, _padding, _fixedScale) {
    return needPlugin("view");
  }
  getValidMove(moveX, moveY) {
    return { x: moveX, y: moveY };
  }
  getValidScale(changeScale) {
    return changeScale;
  }
  getWorldPointByClient(clientPoint, updateClient) {
    return this.interaction && this.interaction.getLocal(clientPoint, updateClient);
  }
  getPagePointByClient(clientPoint, updateClient) {
    return this.getPagePoint(this.getWorldPointByClient(clientPoint, updateClient));
  }
  updateClientBounds() {
    this.canvas && this.canvas.updateClientBounds();
  }
  receiveEvent(_event) {
  }
  __checkUpdateLayout() {
    this.__layout.update();
  }
  emitLeafer(type) {
    this.emitEvent(new LeaferEvent(type, this));
  }
  __listenEvents() {
    const runId = Run.start("FirstCreate " + this.innerName);
    this.once(LeaferEvent.START, () => Run.end(runId));
    this.once(LayoutEvent.START, () => this.updateLazyBounds());
    this.once(LayoutEvent.END, () => this.__onReady());
    this.once(RenderEvent.START, () => this.__onCreated());
    this.once(RenderEvent.END, () => this.__onViewReady());
    this.__eventIds.push(this.on_(WatchEvent.DATA, this.__onWatchData, this), this.on_(RenderEvent.NEXT, this.__onNextRender, this), this.on_(LayoutEvent.CHECK_UPDATE, this.__checkUpdateLayout, this));
  }
  __removeListenEvents() {
    this.off_(this.__eventIds);
    this.__eventIds.length = 0;
  }
  destroy(sync) {
    const doDestory = () => {
      if (!this.destroyed) {
        Leafer_1.list.remove(this);
        try {
          this.stop();
          this.emitEvent(new LeaferEvent(LeaferEvent.END, this));
          this.__removeListenEvents();
          this.__controllers.forEach((item) => !(this.parent && item === this.interaction) && item.destroy());
          this.__controllers.length = 0;
          if (!this.parent) {
            if (this.selector)
              this.selector.destroy();
            if (this.hitCanvasManager)
              this.hitCanvasManager.destroy();
            this.canvasManager.destroy();
          }
          this.canvas.destroy();
          this.config.view = this.view = null;
          if (this.userConfig)
            this.userConfig.view = null;
          super.destroy();
          setTimeout(() => {
            ImageManager.clearRecycled();
          }, 100);
        } catch (e) {
          debug2.error(e);
        }
      }
    };
    sync ? doDestory() : setTimeout(doDestory);
  }
};
Leafer.list = new LeafList();
__decorate2([
  dataProcessor(LeaferData)
], Leafer.prototype, "__", void 0);
__decorate2([
  boundsType()
], Leafer.prototype, "pixelRatio", void 0);
Leafer = Leafer_1 = __decorate2([
  registerUI()
], Leafer);
var Rect = class Rect2 extends UI {
  get __tag() {
    return "Rect";
  }
  constructor(data) {
    super(data);
  }
};
__decorate2([
  dataProcessor(RectData)
], Rect.prototype, "__", void 0);
Rect = __decorate2([
  useModule(RectRender),
  rewriteAble(),
  registerUI()
], Rect);
var { copy: copy2, add: add2, includes: includes$1 } = BoundsHelper;
var rect2 = Rect.prototype;
var group = Group.prototype;
var childrenRenderBounds = {};
var Box = class Box2 extends Group {
  get __tag() {
    return "Box";
  }
  get isBranchLeaf() {
    return true;
  }
  constructor(data) {
    super(data);
    this.__layout.renderChanged || this.__layout.renderChange();
  }
  __updateStrokeSpread() {
    return 0;
  }
  __updateRectRenderSpread() {
    return 0;
  }
  __updateRenderSpread() {
    return this.__updateRectRenderSpread() || -1;
  }
  __updateRectBoxBounds() {
  }
  __updateBoxBounds(_secondLayout) {
    const data = this.__;
    if (this.children.length) {
      if (data.__autoSide) {
        super.__updateBoxBounds();
        const { boxBounds } = this.__layout;
        if (!data.__autoSize) {
          if (data.__autoWidth) {
            boxBounds.width += boxBounds.x, boxBounds.x = 0;
            boxBounds.height = data.height, boxBounds.y = 0;
          } else {
            boxBounds.height += boxBounds.y, boxBounds.y = 0;
            boxBounds.width = data.width, boxBounds.x = 0;
          }
        }
        this.__updateNaturalSize();
      } else
        this.__updateRectBoxBounds();
    } else
      this.__updateRectBoxBounds();
  }
  __updateStrokeBounds() {
  }
  __updateRenderBounds() {
    let isOverflow;
    const { renderBounds } = this.__layout;
    if (this.children.length) {
      super.__updateRenderBounds();
      copy2(childrenRenderBounds, renderBounds);
      this.__updateRectRenderBounds();
      isOverflow = !includes$1(renderBounds, childrenRenderBounds);
      if (isOverflow && this.__.overflow !== "hide")
        add2(renderBounds, childrenRenderBounds);
    } else
      this.__updateRectRenderBounds();
    !this.isOverflow !== !isOverflow && (this.isOverflow = isOverflow);
  }
  __updateRectRenderBounds() {
  }
  __updateRectChange() {
  }
  __updateChange() {
    super.__updateChange();
    this.__updateRectChange();
  }
  __renderRect(_canvas, _options) {
  }
  __renderGroup(_canvas, _options) {
  }
  __render(canvas3, options) {
    if (this.__.__drawAfterFill) {
      this.__renderRect(canvas3, options);
    } else {
      this.__renderRect(canvas3, options);
      if (this.children.length)
        this.__renderGroup(canvas3, options);
    }
  }
  __drawContent(canvas3, options) {
    this.__renderGroup(canvas3, options);
    if (this.__.__hasStroke) {
      canvas3.setWorld(this.__nowWorld);
      this.__drawRenderPath(canvas3);
    }
  }
};
__decorate2([
  dataProcessor(BoxData)
], Box.prototype, "__", void 0);
__decorate2([
  dataType(false)
], Box.prototype, "resizeChildren", void 0);
__decorate2([
  affectRenderBoundsType("show")
], Box.prototype, "overflow", void 0);
__decorate2([
  rewrite(rect2.__updateStrokeSpread)
], Box.prototype, "__updateStrokeSpread", null);
__decorate2([
  rewrite(rect2.__updateRenderSpread)
], Box.prototype, "__updateRectRenderSpread", null);
__decorate2([
  rewrite(rect2.__updateBoxBounds)
], Box.prototype, "__updateRectBoxBounds", null);
__decorate2([
  rewrite(rect2.__updateStrokeBounds)
], Box.prototype, "__updateStrokeBounds", null);
__decorate2([
  rewrite(rect2.__updateRenderBounds)
], Box.prototype, "__updateRectRenderBounds", null);
__decorate2([
  rewrite(rect2.__updateChange)
], Box.prototype, "__updateRectChange", null);
__decorate2([
  rewrite(rect2.__render)
], Box.prototype, "__renderRect", null);
__decorate2([
  rewrite(group.__render)
], Box.prototype, "__renderGroup", null);
Box = __decorate2([
  rewriteAble(),
  registerUI()
], Box);
var Frame = class Frame2 extends Box {
  get __tag() {
    return "Frame";
  }
  get isFrame() {
    return true;
  }
  constructor(data) {
    super(data);
  }
};
__decorate2([
  dataProcessor(FrameData)
], Frame.prototype, "__", void 0);
__decorate2([
  surfaceType("#FFFFFF")
], Frame.prototype, "fill", void 0);
__decorate2([
  affectRenderBoundsType("hide")
], Frame.prototype, "overflow", void 0);
Frame = __decorate2([
  registerUI()
], Frame);
var { moveTo: moveTo$3, closePath: closePath$2, ellipse: ellipse2 } = PathCommandDataHelper;
var Ellipse = class Ellipse2 extends UI {
  get __tag() {
    return "Ellipse";
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const { width, height, innerRadius, startAngle, endAngle } = this.__;
    const rx = width / 2, ry = height / 2;
    const path = this.__.path = [];
    if (innerRadius) {
      if (startAngle || endAngle) {
        if (innerRadius < 1)
          ellipse2(path, rx, ry, rx * innerRadius, ry * innerRadius, 0, startAngle, endAngle, false);
        ellipse2(path, rx, ry, rx, ry, 0, endAngle, startAngle, true);
        if (innerRadius < 1)
          closePath$2(path);
      } else {
        if (innerRadius < 1) {
          ellipse2(path, rx, ry, rx * innerRadius, ry * innerRadius);
          moveTo$3(path, width, ry);
        }
        ellipse2(path, rx, ry, rx, ry, 0, 360, 0, true);
      }
      if (Platform.ellipseToCurve)
        this.__.path = this.getPath(true);
    } else {
      if (startAngle || endAngle) {
        moveTo$3(path, rx, ry);
        ellipse2(path, rx, ry, rx, ry, 0, startAngle, endAngle, false);
        closePath$2(path);
      } else {
        ellipse2(path, rx, ry, rx, ry);
      }
    }
  }
};
__decorate2([
  dataProcessor(EllipseData)
], Ellipse.prototype, "__", void 0);
__decorate2([
  pathType(0)
], Ellipse.prototype, "innerRadius", void 0);
__decorate2([
  pathType(0)
], Ellipse.prototype, "startAngle", void 0);
__decorate2([
  pathType(0)
], Ellipse.prototype, "endAngle", void 0);
Ellipse = __decorate2([
  registerUI()
], Ellipse);
var { moveTo: moveTo$2, lineTo: lineTo$2, drawPoints: drawPoints$1 } = PathCommandDataHelper;
var { rotate, getAngle, getDistance, defaultPoint } = PointHelper;
var { toBounds: toBounds2 } = PathBounds;
var Line = class Line2 extends UI {
  get __tag() {
    return "Line";
  }
  get toPoint() {
    const { width, rotation } = this.__;
    const to = getPointData();
    if (width)
      to.x = width;
    if (rotation)
      rotate(to, rotation);
    return to;
  }
  set toPoint(value) {
    this.width = getDistance(defaultPoint, value);
    this.rotation = getAngle(defaultPoint, value);
    if (this.height)
      this.height = 0;
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const data = this.__;
    const path = data.path = [];
    if (data.points) {
      drawPoints$1(path, data.points, false, data.closed);
    } else {
      moveTo$2(path, 0, 0);
      lineTo$2(path, this.width, 0);
    }
  }
  __updateRenderPath() {
    const data = this.__;
    if (!this.pathInputed && data.points && data.curve) {
      drawPoints$1(data.__pathForRender = [], data.points, data.curve, data.closed);
      if (data.__useArrow)
        PathArrow.addArrows(this, false);
    } else
      super.__updateRenderPath();
  }
  __updateBoxBounds() {
    if (this.points) {
      toBounds2(this.__.__pathForRender, this.__layout.boxBounds);
    } else
      super.__updateBoxBounds();
  }
};
__decorate2([
  dataProcessor(LineData)
], Line.prototype, "__", void 0);
__decorate2([
  affectStrokeBoundsType("center")
], Line.prototype, "strokeAlign", void 0);
__decorate2([
  boundsType(0)
], Line.prototype, "height", void 0);
__decorate2([
  pathType()
], Line.prototype, "points", void 0);
__decorate2([
  pathType(0)
], Line.prototype, "curve", void 0);
__decorate2([
  pathType(false)
], Line.prototype, "closed", void 0);
Line = __decorate2([
  registerUI()
], Line);
var { sin: sin$12, cos: cos$12, PI: PI$12 } = Math;
var { moveTo: moveTo$1, lineTo: lineTo$1, closePath: closePath$1, drawPoints: drawPoints2 } = PathCommandDataHelper;
var line = Line.prototype;
var Polygon = class Polygon2 extends UI {
  get __tag() {
    return "Polygon";
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const path = this.__.path = [];
    if (this.__.points) {
      drawPoints2(path, this.__.points, false, true);
    } else {
      const { width, height, sides } = this.__;
      const rx = width / 2, ry = height / 2;
      moveTo$1(path, rx, 0);
      for (let i = 1; i < sides; i++) {
        lineTo$1(path, rx + rx * sin$12(i * 2 * PI$12 / sides), ry - ry * cos$12(i * 2 * PI$12 / sides));
      }
    }
    closePath$1(path);
  }
  __updateRenderPath() {
  }
  __updateBoxBounds() {
  }
};
__decorate2([
  dataProcessor(PolygonData)
], Polygon.prototype, "__", void 0);
__decorate2([
  pathType(3)
], Polygon.prototype, "sides", void 0);
__decorate2([
  pathType()
], Polygon.prototype, "points", void 0);
__decorate2([
  pathType(0)
], Polygon.prototype, "curve", void 0);
__decorate2([
  rewrite(line.__updateRenderPath)
], Polygon.prototype, "__updateRenderPath", null);
__decorate2([
  rewrite(line.__updateBoxBounds)
], Polygon.prototype, "__updateBoxBounds", null);
Polygon = __decorate2([
  rewriteAble(),
  registerUI()
], Polygon);
var { sin: sin2, cos: cos2, PI: PI3 } = Math;
var { moveTo: moveTo2, lineTo: lineTo2, closePath: closePath2 } = PathCommandDataHelper;
var Star = class Star2 extends UI {
  get __tag() {
    return "Star";
  }
  constructor(data) {
    super(data);
  }
  __updatePath() {
    const { width, height, corners, innerRadius } = this.__;
    const rx = width / 2, ry = height / 2;
    const path = this.__.path = [];
    moveTo2(path, rx, 0);
    for (let i = 1; i < corners * 2; i++) {
      lineTo2(path, rx + (i % 2 === 0 ? rx : rx * innerRadius) * sin2(i * PI3 / corners), ry - (i % 2 === 0 ? ry : ry * innerRadius) * cos2(i * PI3 / corners));
    }
    closePath2(path);
  }
};
__decorate2([
  dataProcessor(StarData)
], Star.prototype, "__", void 0);
__decorate2([
  pathType(5)
], Star.prototype, "corners", void 0);
__decorate2([
  pathType(0.382)
], Star.prototype, "innerRadius", void 0);
Star = __decorate2([
  registerUI()
], Star);
var Image2 = class Image3 extends Rect {
  get __tag() {
    return "Image";
  }
  get ready() {
    return this.image ? this.image.ready : false;
  }
  constructor(data) {
    super(data);
    this.on(ImageEvent.LOADED, (e) => {
      if (e.attrName === "fill" && e.attrValue.url === this.url)
        this.image = e.image;
    });
  }
  destroy() {
    this.image = null;
    super.destroy();
  }
};
__decorate2([
  dataProcessor(ImageData)
], Image2.prototype, "__", void 0);
__decorate2([
  boundsType("")
], Image2.prototype, "url", void 0);
Image2 = __decorate2([
  registerUI()
], Image2);
var MyImage = Image2;
var Canvas2 = class Canvas3 extends Rect {
  get __tag() {
    return "Canvas";
  }
  get ready() {
    return !this.url;
  }
  constructor(data) {
    super(data);
    this.canvas = Creator.canvas(this.__);
    this.context = this.canvas.context;
    if (data && data.url)
      this.drawImage(data.url);
  }
  drawImage(url) {
    new LeaferImage({ url }).load((image2) => {
      this.context.drawImage(image2.view, 0, 0);
      this.url = void 0;
      this.paint();
      this.emitEvent(new ImageEvent(ImageEvent.LOADED, { image: image2 }));
    });
  }
  draw(ui2, offset, scale2, rotation) {
    const matrix3 = new Matrix(ui2.worldTransform).invert();
    const m2 = new Matrix();
    if (offset)
      m2.translate(offset.x, offset.y);
    if (scale2)
      typeof scale2 === "number" ? m2.scale(scale2) : m2.scale(scale2.x, scale2.y);
    if (rotation)
      m2.rotate(rotation);
    matrix3.multiplyParent(m2);
    ui2.__render(this.canvas, { matrix: matrix3.withScale() });
    this.paint();
  }
  paint() {
    this.forceRender();
  }
  __drawContent(canvas3, _options) {
    const { width, height } = this.__, { view } = this.canvas;
    canvas3.drawImage(view, 0, 0, view.width, view.height, 0, 0, width, height);
  }
  __updateSize() {
    const { canvas: canvas3 } = this;
    if (canvas3) {
      const { smooth } = this.__;
      if (canvas3.smooth !== smooth)
        canvas3.smooth = smooth;
      canvas3.resize(this.__);
    }
  }
  destroy() {
    if (this.canvas) {
      this.canvas.destroy();
      this.canvas = this.context = null;
    }
    super.destroy();
  }
};
__decorate2([
  dataProcessor(CanvasData)
], Canvas2.prototype, "__", void 0);
__decorate2([
  resizeType(100)
], Canvas2.prototype, "width", void 0);
__decorate2([
  resizeType(100)
], Canvas2.prototype, "height", void 0);
__decorate2([
  resizeType(1)
], Canvas2.prototype, "pixelRatio", void 0);
__decorate2([
  resizeType(true)
], Canvas2.prototype, "smooth", void 0);
__decorate2([
  resizeType()
], Canvas2.prototype, "contextSettings", void 0);
Canvas2 = __decorate2([
  registerUI()
], Canvas2);
var { copyAndSpread: copyAndSpread2, includes, isSame, spread, setList } = BoundsHelper;
var Text = class Text2 extends UI {
  get __tag() {
    return "Text";
  }
  get textDrawData() {
    this.__layout.update();
    return this.__.__textDrawData;
  }
  constructor(data) {
    super(data);
  }
  __drawHitPath(canvas3) {
    const { __lineHeight, fontSize, __baseLine, __textDrawData: data } = this.__;
    canvas3.beginPath();
    if (this.__.__letterSpacing < 0) {
      this.__drawPathByData(canvas3);
    } else {
      data.rows.forEach((row2) => canvas3.rect(row2.x, row2.y - __baseLine, row2.width, __lineHeight < fontSize ? fontSize : __lineHeight));
    }
  }
  __drawPathByData(drawer, _data) {
    const { x, y, width, height } = this.__layout.boxBounds;
    drawer.rect(x, y, width, height);
  }
  __drawRenderPath(canvas3) {
    canvas3.font = this.__.__font;
  }
  __updateTextDrawData() {
    const data = this.__;
    const { lineHeight, letterSpacing, fontFamily, fontSize, fontWeight, italic, textCase, textOverflow, padding } = data;
    data.__lineHeight = UnitConvert.number(lineHeight, fontSize);
    data.__letterSpacing = UnitConvert.number(letterSpacing, fontSize);
    data.__padding = padding ? MathHelper.fourNumber(padding) : void 0;
    data.__baseLine = data.__lineHeight - (data.__lineHeight - fontSize * 0.7) / 2;
    data.__font = `${italic ? "italic " : ""}${textCase === "small-caps" ? "small-caps " : ""}${fontWeight !== "normal" ? fontWeight + " " : ""}${fontSize}px ${fontFamily}`;
    data.__clipText = textOverflow !== "show" && !data.__autoSize;
    data.__textDrawData = TextConvert.getDrawData(data.text, this.__);
  }
  __updateBoxBounds() {
    const data = this.__;
    const layout = this.__layout;
    const { fontSize, italic, padding, __autoWidth: autoWidth, __autoHeight: autoHeight } = data;
    this.__updateTextDrawData();
    const { bounds: bounds2 } = data.__textDrawData;
    const b = layout.boxBounds;
    if (data.__lineHeight < fontSize)
      spread(bounds2, fontSize / 2);
    if (autoWidth || autoHeight) {
      b.x = autoWidth ? bounds2.x : 0;
      b.y = autoHeight ? bounds2.y : 0;
      b.width = autoWidth ? bounds2.width : data.width;
      b.height = autoHeight ? bounds2.height : data.height;
      if (padding) {
        const [top2, right3, bottom3, left2] = data.__padding;
        if (autoWidth)
          b.x -= left2, b.width += right3 + left2;
        if (autoHeight)
          b.y -= top2, b.height += bottom3 + top2;
      }
      this.__updateNaturalSize();
    } else
      super.__updateBoxBounds();
    if (italic)
      b.width += fontSize * 0.16;
    const contentBounds = includes(b, bounds2) ? b : bounds2;
    if (!isSame(contentBounds, layout.contentBounds)) {
      layout.contentBounds = contentBounds;
      layout.renderChanged = true;
      setList(data.__textBoxBounds = {}, [b, bounds2]);
    } else
      data.__textBoxBounds = contentBounds;
  }
  __updateRenderSpread() {
    let width = super.__updateRenderSpread();
    if (!width)
      width = this.__layout.boxBounds === this.__layout.contentBounds ? 0 : 1;
    return width;
  }
  __updateRenderBounds() {
    copyAndSpread2(this.__layout.renderBounds, this.__.__textBoxBounds, this.__layout.renderSpread);
  }
};
__decorate2([
  dataProcessor(TextData)
], Text.prototype, "__", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "width", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "height", void 0);
__decorate2([
  dataType(false)
], Text.prototype, "resizeFontSize", void 0);
__decorate2([
  surfaceType("#000000")
], Text.prototype, "fill", void 0);
__decorate2([
  affectStrokeBoundsType("outside")
], Text.prototype, "strokeAlign", void 0);
__decorate2([
  hitType("all")
], Text.prototype, "hitFill", void 0);
__decorate2([
  boundsType("")
], Text.prototype, "text", void 0);
__decorate2([
  boundsType("L")
], Text.prototype, "fontFamily", void 0);
__decorate2([
  boundsType(12)
], Text.prototype, "fontSize", void 0);
__decorate2([
  boundsType("normal")
], Text.prototype, "fontWeight", void 0);
__decorate2([
  boundsType(false)
], Text.prototype, "italic", void 0);
__decorate2([
  boundsType("none")
], Text.prototype, "textCase", void 0);
__decorate2([
  boundsType("none")
], Text.prototype, "textDecoration", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "letterSpacing", void 0);
__decorate2([
  boundsType({ type: "percent", value: 1.5 })
], Text.prototype, "lineHeight", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "paraIndent", void 0);
__decorate2([
  boundsType(0)
], Text.prototype, "paraSpacing", void 0);
__decorate2([
  boundsType("left")
], Text.prototype, "textAlign", void 0);
__decorate2([
  boundsType("top")
], Text.prototype, "verticalAlign", void 0);
__decorate2([
  boundsType(true)
], Text.prototype, "autoSizeAlign", void 0);
__decorate2([
  boundsType("normal")
], Text.prototype, "textWrap", void 0);
__decorate2([
  boundsType("show")
], Text.prototype, "textOverflow", void 0);
Text = __decorate2([
  registerUI()
], Text);
var Path = class Path2 extends UI {
  get __tag() {
    return "Path";
  }
  constructor(data) {
    super(data);
  }
};
__decorate2([
  dataProcessor(PathData)
], Path.prototype, "__", void 0);
__decorate2([
  affectStrokeBoundsType("center")
], Path.prototype, "strokeAlign", void 0);
Path = __decorate2([
  registerUI()
], Path);
var Pen = class Pen2 extends Group {
  get __tag() {
    return "Pen";
  }
  constructor(data) {
    super(data);
  }
  setStyle(data) {
    const path = this.pathElement = new Path(data);
    this.pathStyle = data;
    this.__path = path.path || (path.path = []);
    this.add(path);
    return this;
  }
  beginPath() {
    return this;
  }
  moveTo(_x, _y) {
    return this;
  }
  lineTo(_x, _y) {
    return this;
  }
  bezierCurveTo(_x1, _y1, _x2, _y2, _x, _y) {
    return this;
  }
  quadraticCurveTo(_x1, _y1, _x, _y) {
    return this;
  }
  closePath() {
    return this;
  }
  rect(_x, _y, _width, _height) {
    return this;
  }
  roundRect(_x, _y, _width, _height, _cornerRadius) {
    return this;
  }
  ellipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  arc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  arcTo(_x1, _y1, _x2, _y2, _radius) {
    return this;
  }
  drawEllipse(_x, _y, _radiusX, _radiusY, _rotation, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  drawArc(_x, _y, _radius, _startAngle, _endAngle, _anticlockwise) {
    return this;
  }
  drawPoints(_points, _curve, _close) {
    return this;
  }
  clearPath() {
    return this;
  }
  paint() {
    if (!this.pathElement.__layout.boxChanged)
      this.pathElement.forceUpdate("path");
  }
};
__decorate2([
  dataProcessor(PenData)
], Pen.prototype, "__", void 0);
__decorate2([
  penPathType()
], Pen.prototype, "path", void 0);
Pen = __decorate2([
  useModule(PathCreator, ["set", "path", "paint"]),
  registerUI()
], Pen);
function penPathType() {
  return (target, key) => {
    defineKey(target, key, {
      get() {
        return this.__path;
      }
    });
  };
}

// node_modules/@leafer-ui/core/lib/core.esm.js
function __decorate3(decorators, target, key, desc) {
  var c2 = arguments.length, r = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c2 < 3 ? d(r) : c2 > 3 ? d(target, key, r) : d(target, key)) || r;
  return c2 > 3 && r && Object.defineProperty(target, key, r), r;
}
var App = class App2 extends Leafer {
  get __tag() {
    return "App";
  }
  get isApp() {
    return true;
  }
  constructor(userConfig, data) {
    super(userConfig, data);
  }
  init(userConfig, parentApp) {
    super.init(userConfig, parentApp);
    if (userConfig) {
      const { ground, tree, sky, editor } = userConfig;
      if (ground)
        this.ground = this.addLeafer(ground);
      if (tree || editor)
        this.tree = this.addLeafer(tree);
      if (sky || editor)
        this.sky = this.addLeafer(sky || { type: "draw", usePartRender: false });
      if (editor)
        this.sky.add(this.editor = Creator.editor(editor));
    }
  }
  __setApp() {
    const { canvas: canvas3 } = this;
    const { realCanvas, view } = this.config;
    if (realCanvas || view === this.canvas.view || !canvas3.parentView)
      this.realCanvas = true;
    else
      canvas3.unrealCanvas();
    this.leafer = this;
    this.watcher.disable();
    this.layouter.disable();
    this.__eventIds.push(this.on_(PropertyEvent.CHANGE, this.__onPropertyChange, this));
  }
  start() {
    super.start();
    this.children.forEach((leafer2) => leafer2.start());
  }
  stop() {
    this.children.forEach((leafer2) => leafer2.stop());
    super.stop();
  }
  unlockLayout() {
    super.unlockLayout();
    this.children.forEach((leafer2) => leafer2.unlockLayout());
  }
  lockLayout() {
    super.lockLayout();
    this.children.forEach((leafer2) => leafer2.lockLayout());
  }
  forceRender(bounds2) {
    this.children.forEach((leafer2) => leafer2.forceRender(bounds2));
  }
  addLeafer(merge) {
    const leafer2 = new Leafer(merge);
    this.add(leafer2);
    return leafer2;
  }
  add(leafer2, index) {
    if (!leafer2.view) {
      if (this.realCanvas && !this.canvas.bounds) {
        setTimeout(() => this.add(leafer2, index), 10);
        return;
      }
      leafer2.init(this.__getChildConfig(leafer2.userConfig), this);
    }
    super.add(leafer2, index);
    if (index !== void 0)
      leafer2.canvas.childIndex = index;
    this.__listenChildEvents(leafer2);
  }
  __onPropertyChange() {
    if (Debug.showHitView)
      this.children.forEach((leafer2) => leafer2.forceUpdate("surface"));
  }
  __onCreated() {
    this.created = this.children.every((child) => child.created);
  }
  __onReady() {
    if (this.children.every((child) => child.ready))
      super.__onReady();
  }
  __onViewReady() {
    if (this.children.every((child) => child.viewReady))
      super.__onViewReady();
  }
  __onChildRenderEnd(e) {
    this.renderer.addBlock(e.renderBounds);
    if (this.viewReady)
      this.renderer.update();
  }
  __render(canvas3, options) {
    if (canvas3.context) {
      const m2 = options.matrix;
      if (m2)
        canvas3.setTransform(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f);
      this.children.forEach((leafer2) => canvas3.copyWorld(leafer2.canvas));
    }
  }
  __onResize(event) {
    this.children.forEach((leafer2) => leafer2.resize(event));
    super.__onResize(event);
  }
  __checkUpdateLayout() {
    this.children.forEach((leafer2) => leafer2.__layout.update());
  }
  __getChildConfig(userConfig) {
    let config2 = Object.assign({}, this.config);
    config2.hittable = config2.realCanvas = void 0;
    if (userConfig)
      DataHelper.assign(config2, userConfig);
    if (this.autoLayout)
      DataHelper.copyAttrs(config2, this, canvasSizeAttrs);
    config2.view = this.realCanvas ? void 0 : this.view;
    config2.fill = void 0;
    return config2;
  }
  __listenChildEvents(leafer2) {
    leafer2.once(LayoutEvent.END, () => this.__onReady());
    leafer2.once(RenderEvent.START, () => this.__onCreated());
    leafer2.once(RenderEvent.END, () => this.__onViewReady());
    if (this.realCanvas)
      this.__eventIds.push(leafer2.on_(RenderEvent.END, this.__onChildRenderEnd, this));
  }
};
App = __decorate3([
  registerUI()
], App);
var downKeyMap = {};
var Keyboard = {
  isHoldSpaceKey() {
    return Keyboard.isHold("Space");
  },
  isHold(code) {
    return downKeyMap[code];
  },
  setDownCode(code) {
    if (!downKeyMap[code])
      downKeyMap[code] = true;
  },
  setUpCode(code) {
    downKeyMap[code] = false;
  }
};
var PointerButton = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4,
  defaultLeft(event) {
    if (!event.buttons)
      event.buttons = 1;
  },
  left(event) {
    return event.buttons === 1;
  },
  right(event) {
    return event.buttons === 2;
  },
  middle(event) {
    return event.buttons === 4;
  }
};
var UIEvent = class extends Event {
  get spaceKey() {
    return Keyboard.isHoldSpaceKey();
  }
  get left() {
    return PointerButton.left(this);
  }
  get right() {
    return PointerButton.right(this);
  }
  get middle() {
    return PointerButton.middle(this);
  }
  constructor(params) {
    super(params.type);
    this.bubbles = true;
    Object.assign(this, params);
  }
  getBoxPoint(relative) {
    return (relative || this.current).getBoxPoint(this);
  }
  getInnerPoint(relative) {
    return (relative || this.current).getInnerPoint(this);
  }
  getLocalPoint(relative) {
    return (relative || this.current).getLocalPoint(this);
  }
  getPagePoint() {
    return this.current.getPagePoint(this);
  }
  getInner(relative) {
    return this.getInnerPoint(relative);
  }
  getLocal(relative) {
    return this.getLocalPoint(relative);
  }
  getPage() {
    return this.getPagePoint();
  }
  static changeName(oldName, newName) {
    EventCreator.changeName(oldName, newName);
  }
};
var PointerEvent = class PointerEvent2 extends UIEvent {
};
PointerEvent.POINTER = "pointer";
PointerEvent.BEFORE_DOWN = "pointer.before_down";
PointerEvent.BEFORE_MOVE = "pointer.before_move";
PointerEvent.BEFORE_UP = "pointer.before_up";
PointerEvent.DOWN = "pointer.down";
PointerEvent.MOVE = "pointer.move";
PointerEvent.UP = "pointer.up";
PointerEvent.OVER = "pointer.over";
PointerEvent.OUT = "pointer.out";
PointerEvent.ENTER = "pointer.enter";
PointerEvent.LEAVE = "pointer.leave";
PointerEvent.TAP = "tap";
PointerEvent.DOUBLE_TAP = "double_tap";
PointerEvent.CLICK = "click";
PointerEvent.DOUBLE_CLICK = "double_click";
PointerEvent.LONG_PRESS = "long_press";
PointerEvent.LONG_TAP = "long_tap";
PointerEvent.MENU = "pointer.menu";
PointerEvent.MENU_TAP = "pointer.menu_tap";
PointerEvent = __decorate3([
  registerUIEvent()
], PointerEvent);
var MyPointerEvent = PointerEvent;
var tempMove = {};
var DragEvent = class DragEvent2 extends PointerEvent {
  static setList(data) {
    this.list = data instanceof LeafList ? data : new LeafList(data);
  }
  static setData(data) {
    this.data = data;
  }
  static getValidMove(leaf2, start, total) {
    const { draggable, dragBounds } = leaf2, move2 = leaf2.getLocalPoint(total, null, true);
    PointHelper.move(move2, start.x - leaf2.x, start.y - leaf2.y);
    if (dragBounds)
      this.getMoveInDragBounds(leaf2.__local, dragBounds === "parent" ? leaf2.parent.boxBounds : dragBounds, move2, true);
    if (draggable === "x")
      move2.y = 0;
    if (draggable === "y")
      move2.x = 0;
    return move2;
  }
  static getMoveInDragBounds(childBox, dragBounds, move2, change) {
    const x = childBox.x + move2.x, y = childBox.y + move2.y, right3 = x + childBox.width, bottom3 = y + childBox.height;
    const boundsRight2 = dragBounds.x + dragBounds.width, boundsBottom2 = dragBounds.y + dragBounds.height;
    if (!change)
      move2 = Object.assign({}, move2);
    if (BoundsHelper.includes(childBox, dragBounds)) {
      if (x > dragBounds.x)
        move2.x += dragBounds.x - x;
      else if (right3 < boundsRight2)
        move2.x += boundsRight2 - right3;
      if (y > dragBounds.y)
        move2.y += dragBounds.y - y;
      else if (bottom3 < boundsBottom2)
        move2.y += boundsBottom2 - bottom3;
    } else {
      if (x < dragBounds.x)
        move2.x += dragBounds.x - x;
      else if (right3 > boundsRight2)
        move2.x += boundsRight2 - right3;
      if (y < dragBounds.y)
        move2.y += dragBounds.y - y;
      else if (bottom3 > boundsBottom2)
        move2.y += boundsBottom2 - bottom3;
    }
    return move2;
  }
  getPageMove(total) {
    this.assignMove(total);
    return this.current.getPagePoint(tempMove, null, true);
  }
  getInnerMove(relative, total) {
    if (!relative)
      relative = this.current;
    this.assignMove(total);
    return relative.getInnerPoint(tempMove, null, true);
  }
  getLocalMove(relative, total) {
    if (!relative)
      relative = this.current;
    this.assignMove(total);
    return relative.getLocalPoint(tempMove, null, true);
  }
  getPageTotal() {
    return this.getPageMove(true);
  }
  getInnerTotal(relative) {
    return this.getInnerMove(relative, true);
  }
  getLocalTotal(relative) {
    return this.getLocalMove(relative, true);
  }
  getPageBounds() {
    const total = this.getPageTotal(), start = this.getPagePoint(), bounds2 = {};
    BoundsHelper.set(bounds2, start.x - total.x, start.y - total.y, total.x, total.y);
    BoundsHelper.unsign(bounds2);
    return bounds2;
  }
  assignMove(total) {
    tempMove.x = total ? this.totalX : this.moveX;
    tempMove.y = total ? this.totalY : this.moveY;
  }
};
DragEvent.BEFORE_DRAG = "drag.before_drag";
DragEvent.START = "drag.start";
DragEvent.DRAG = "drag";
DragEvent.END = "drag.end";
DragEvent.OVER = "drag.over";
DragEvent.OUT = "drag.out";
DragEvent.ENTER = "drag.enter";
DragEvent.LEAVE = "drag.leave";
DragEvent = __decorate3([
  registerUIEvent()
], DragEvent);
var MyDragEvent = DragEvent;
var DropEvent = class DropEvent2 extends PointerEvent {
  static setList(data) {
    DragEvent.setList(data);
  }
  static setData(data) {
    DragEvent.setData(data);
  }
};
DropEvent.DROP = "drop";
DropEvent = __decorate3([
  registerUIEvent()
], DropEvent);
var MoveEvent = class MoveEvent2 extends DragEvent {
};
MoveEvent.BEFORE_MOVE = "move.before_move";
MoveEvent.START = "move.start";
MoveEvent.MOVE = "move";
MoveEvent.END = "move.end";
MoveEvent = __decorate3([
  registerUIEvent()
], MoveEvent);
var RotateEvent = class RotateEvent2 extends UIEvent {
};
RotateEvent.BEFORE_ROTATE = "rotate.before_rotate";
RotateEvent.START = "rotate.start";
RotateEvent.ROTATE = "rotate";
RotateEvent.END = "rotate.end";
RotateEvent = __decorate3([
  registerUIEvent()
], RotateEvent);
var SwipeEvent = class SwipeEvent2 extends DragEvent {
};
SwipeEvent.SWIPE = "swipe";
SwipeEvent.LEFT = "swipe.left";
SwipeEvent.RIGHT = "swipe.right";
SwipeEvent.UP = "swipe.up";
SwipeEvent.DOWN = "swipe.down";
SwipeEvent = __decorate3([
  registerUIEvent()
], SwipeEvent);
var ZoomEvent = class ZoomEvent2 extends UIEvent {
};
ZoomEvent.BEFORE_ZOOM = "zoom.before_zoom";
ZoomEvent.START = "zoom.start";
ZoomEvent.ZOOM = "zoom";
ZoomEvent.END = "zoom.end";
ZoomEvent = __decorate3([
  registerUIEvent()
], ZoomEvent);
var KeyEvent = class KeyEvent2 extends UIEvent {
};
KeyEvent.DOWN = "key.down";
KeyEvent.HOLD = "key.hold";
KeyEvent.UP = "key.up";
KeyEvent = __decorate3([
  registerUIEvent()
], KeyEvent);
function addInteractionWindow(leafer2) {
  if (leafer2.isApp)
    return;
  leafer2.__eventIds.push(leafer2.on_(MoveEvent.BEFORE_MOVE, (e) => {
    leafer2.zoomLayer.move(leafer2.getValidMove(e.moveX, e.moveY));
  }), leafer2.on_(ZoomEvent.BEFORE_ZOOM, (e) => {
    const { zoomLayer } = leafer2;
    const changeScale = leafer2.getValidScale(e.scale);
    if (changeScale !== 1) {
      PointHelper.scaleOf(zoomLayer, e, changeScale);
      zoomLayer.scale = zoomLayer.__.scaleX * changeScale;
    }
  }));
}
function document2(leafer2) {
  addInteractionWindow(leafer2);
  const { move: move2, zoom } = leafer2.config;
  move2.scroll = "limit";
  zoom.min = 1;
}
function block(leafer2) {
  const { config: config2 } = leafer2;
  (config2.wheel || (config2.wheel = {})).preventDefault = false;
  (config2.touch || (config2.touch = {})).preventDefault = "auto";
}
var debug$13 = Debug.get("LeaferTypeCreator");
var LeaferTypeCreator = {
  list: {},
  register(name, fn) {
    list2[name] && debug$13.repeat(name);
    list2[name] = fn;
  },
  run(name, leafer2) {
    const fn = list2[name];
    fn && fn(leafer2);
  }
};
var { list: list2, register } = LeaferTypeCreator;
register("design", addInteractionWindow);
register("document", document2);
register("block", block);
var leafer = Leafer.prototype;
leafer.initType = function(type) {
  LeaferTypeCreator.run(type, this);
};
leafer.getValidMove = function(moveX, moveY) {
  const { scroll, disabled } = this.app.config.move;
  if (scroll) {
    Math.abs(moveX) > Math.abs(moveY) ? moveY = 0 : moveX = 0;
    if (scroll === "limit") {
      const { x, y, width, height } = new Bounds(this.__world).addPoint(this.zoomLayer);
      const right3 = x + width - this.width, bottom3 = y + height - this.height;
      if (x >= 0 && right3 <= 0)
        moveX = 0;
      else if (moveX > 0) {
        if (x + moveX > 0)
          moveX = -x;
      } else if (moveX < 0 && right3 + moveX < 0)
        moveX = -right3;
      if (y >= 0 && bottom3 <= 0)
        moveY = 0;
      else if (moveY > 0) {
        if (y + moveY > 0)
          moveY = -y;
      } else if (moveY < 0 && bottom3 + moveY < 0)
        moveY = -bottom3;
    }
  }
  return { x: disabled ? 0 : moveX, y: disabled ? 0 : moveY };
};
leafer.getValidScale = function(changeScale) {
  const { scaleX } = this.zoomLayer.__, { min: min2, max, disabled } = this.app.config.zoom, absScale = Math.abs(scaleX * changeScale);
  if (absScale < min2)
    changeScale = min2 / scaleX;
  else if (absScale > max)
    changeScale = max / scaleX;
  return disabled ? 1 : changeScale;
};
var Transformer = class {
  get transforming() {
    return !!(this.moveData || this.zoomData || this.rotateData);
  }
  constructor(interaction) {
    this.interaction = interaction;
  }
  move(data) {
    const { interaction } = this;
    if (!data.moveType)
      data.moveType = "move";
    if (!this.moveData) {
      const { path } = interaction.selector.getByPoint(data, interaction.hitRadius);
      data.path = path;
      this.moveData = Object.assign(Object.assign({}, data), { moveX: 0, moveY: 0 });
      interaction.cancelHover();
      interaction.emit(MoveEvent.START, this.moveData);
    }
    data.path = this.moveData.path;
    interaction.emit(MoveEvent.BEFORE_MOVE, data);
    interaction.emit(MoveEvent.MOVE, data);
    this.transformEndWait();
  }
  zoom(data) {
    const { interaction } = this;
    if (!this.zoomData) {
      const { path } = interaction.selector.getByPoint(data, interaction.hitRadius);
      data.path = path;
      this.zoomData = Object.assign(Object.assign({}, data), { scale: 1 });
      interaction.cancelHover();
      interaction.emit(ZoomEvent.START, this.zoomData);
    }
    data.path = this.zoomData.path;
    interaction.emit(ZoomEvent.BEFORE_ZOOM, data);
    interaction.emit(ZoomEvent.ZOOM, data);
    this.transformEndWait();
  }
  rotate(data) {
    const { interaction } = this;
    if (!this.rotateData) {
      const { path } = interaction.selector.getByPoint(data, interaction.hitRadius);
      data.path = path;
      this.rotateData = Object.assign(Object.assign({}, data), { rotation: 0 });
      interaction.cancelHover();
      interaction.emit(RotateEvent.START, this.rotateData);
    }
    data.path = this.rotateData.path;
    interaction.emit(RotateEvent.BEFORE_ROTATE, data);
    interaction.emit(RotateEvent.ROTATE, data);
    this.transformEndWait();
  }
  transformEndWait() {
    clearTimeout(this.transformTimer);
    this.transformTimer = setTimeout(() => {
      this.transformEnd();
    }, this.interaction.config.pointer.transformTime);
  }
  transformEnd() {
    this.moveEnd();
    this.zoomEnd();
    this.rotateEnd();
  }
  moveEnd() {
    if (this.moveData) {
      this.interaction.emit(MoveEvent.END, this.moveData);
      this.moveData = null;
    }
  }
  zoomEnd() {
    if (this.zoomData) {
      this.interaction.emit(ZoomEvent.END, this.zoomData);
      this.zoomData = null;
    }
  }
  rotateEnd() {
    if (this.rotateData) {
      this.interaction.emit(RotateEvent.END, this.rotateData);
      this.rotateData = null;
    }
  }
  destroy() {
    this.zoomData = this.moveData = this.rotateData = null;
  }
};
var InteractionHelper = {
  getMoveEventData(center, move2, event) {
    return Object.assign(Object.assign({}, event), { x: center.x, y: center.y, moveX: move2.x, moveY: move2.y });
  },
  getRotateEventData(center, angle, event) {
    return Object.assign(Object.assign({}, event), { x: center.x, y: center.y, rotation: angle });
  },
  getZoomEventData(center, scale2, event) {
    return Object.assign(Object.assign({}, event), { x: center.x, y: center.y, scale: scale2 });
  },
  getDragEventData(startPoint2, lastPoint, event) {
    return Object.assign(Object.assign({}, event), { x: event.x, y: event.y, moveX: event.x - lastPoint.x, moveY: event.y - lastPoint.y, totalX: event.x - startPoint2.x, totalY: event.y - startPoint2.y });
  },
  getDropEventData(event, list3, data) {
    return Object.assign(Object.assign({}, event), {
      list: list3,
      data
    });
  },
  getSwipeDirection(angle) {
    if (angle < -45 && angle > -135) {
      return SwipeEvent.UP;
    } else if (angle > 45 && angle < 135) {
      return SwipeEvent.DOWN;
    } else if (angle <= 45 && angle >= -45) {
      return SwipeEvent.RIGHT;
    } else {
      return SwipeEvent.LEFT;
    }
  },
  getSwipeEventData(startPoint2, lastDragData, event) {
    return Object.assign(Object.assign({}, event), { moveX: lastDragData.moveX, moveY: lastDragData.moveY, totalX: event.x - startPoint2.x, totalY: event.y - startPoint2.y, type: I2.getSwipeDirection(PointHelper.getAngle(startPoint2, event)) });
  },
  getBase(e) {
    const pointerUpButtons = e.button === 1 ? 4 : e.button;
    return {
      altKey: e.altKey,
      ctrlKey: e.ctrlKey,
      shiftKey: e.shiftKey,
      metaKey: e.metaKey,
      buttons: e.buttons === void 0 ? 1 : e.buttons === 0 ? pointerUpButtons : e.buttons,
      origin: e
    };
  },
  pathHasEventType(path, type) {
    const { list: list3 } = path;
    for (let i = 0, len = list3.length; i < len; i++) {
      if (list3[i].hasEvent(type))
        return true;
    }
    return false;
  },
  filterPathByEventType(path, type) {
    const find = new LeafList();
    const { list: list3 } = path;
    for (let i = 0, len = list3.length; i < len; i++) {
      if (list3[i].hasEvent(type))
        find.add(list3[i]);
    }
    return find;
  },
  pathCanDrag(path) {
    return path && path.list.some((item) => item.draggable || item.editable || !item.isLeafer && item.hasEvent(DragEvent.DRAG));
  },
  pathHasOutside(path) {
    return path && path.list.some((item) => item.isOutside);
  }
};
var I2 = InteractionHelper;
var emptyList = new LeafList();
var { getDragEventData, getDropEventData, getSwipeEventData } = InteractionHelper;
var Dragger = class {
  constructor(interaction) {
    this.interaction = interaction;
  }
  setDragData(data) {
    if (this.animateWait)
      this.dragEndReal();
    this.downData = this.interaction.downData;
    this.dragData = getDragEventData(data, data, data);
    this.canAnimate = this.canDragOut = true;
  }
  getList(realDraggable, hover) {
    const { proxy } = this.interaction.selector;
    const hasProxyList = proxy && proxy.list.length, dragList = DragEvent.list || this.draggableList || emptyList;
    return this.dragging && (hasProxyList ? realDraggable ? emptyList : new LeafList(hover ? [...proxy.list, ...proxy.dragHoverExclude] : proxy.list) : dragList);
  }
  checkDrag(data, canDrag) {
    const { interaction } = this;
    if (this.moving && data.buttons < 1) {
      this.canAnimate = false;
      interaction.pointerCancel();
      return;
    }
    if (!this.moving && canDrag) {
      if (this.moving = interaction.canMove(this.downData) || interaction.isHoldRightKey || interaction.isMobileDragEmpty) {
        this.dragData.moveType = "drag";
        interaction.emit(MoveEvent.START, this.dragData);
      }
    }
    if (!this.moving) {
      this.dragStart(data, canDrag);
    }
    this.drag(data);
  }
  dragStart(data, canDrag) {
    if (!this.dragging) {
      this.dragging = canDrag && PointerButton.left(data);
      if (this.dragging) {
        this.interaction.emit(DragEvent.START, this.dragData);
        this.getDraggableList(this.dragData.path);
        this.setDragStartPoints(this.realDraggableList = this.getList(true));
      }
    }
  }
  setDragStartPoints(list3) {
    this.dragStartPoints = {};
    list3.forEach((leaf2) => this.dragStartPoints[leaf2.innerId] = { x: leaf2.x, y: leaf2.y });
  }
  getDraggableList(path) {
    let leaf2;
    for (let i = 0, len = path.length; i < len; i++) {
      leaf2 = path.list[i];
      if ((leaf2.draggable || leaf2.editable) && leaf2.hitSelf && !leaf2.locked) {
        this.draggableList = new LeafList(leaf2);
        break;
      }
    }
  }
  drag(data) {
    const { interaction, dragData, downData } = this;
    const { path, throughPath } = downData;
    this.dragData = getDragEventData(downData, dragData, data);
    if (throughPath)
      this.dragData.throughPath = throughPath;
    this.dragData.path = path;
    if (this.moving) {
      this.dragData.moveType = "drag";
      interaction.emit(MoveEvent.BEFORE_MOVE, this.dragData);
      interaction.emit(MoveEvent.MOVE, this.dragData);
    } else if (this.dragging) {
      this.dragReal();
      interaction.emit(DragEvent.BEFORE_DRAG, this.dragData);
      interaction.emit(DragEvent.DRAG, this.dragData);
    }
  }
  dragReal() {
    const { running } = this.interaction;
    const list3 = this.realDraggableList;
    if (list3.length && running) {
      const { totalX, totalY } = this.dragData;
      list3.forEach((leaf2) => leaf2.draggable && leaf2.move(DragEvent.getValidMove(leaf2, this.dragStartPoints[leaf2.innerId], { x: totalX, y: totalY })));
    }
  }
  dragOverOrOut(data) {
    const { interaction } = this;
    const { dragOverPath } = this;
    const { path } = data;
    this.dragOverPath = path;
    if (dragOverPath) {
      if (path.indexAt(0) !== dragOverPath.indexAt(0)) {
        interaction.emit(DragEvent.OUT, data, dragOverPath);
        interaction.emit(DragEvent.OVER, data, path);
      }
    } else
      interaction.emit(DragEvent.OVER, data, path);
  }
  dragEnterOrLeave(data) {
    const { interaction } = this;
    const { dragEnterPath } = this;
    const { path } = data;
    interaction.emit(DragEvent.LEAVE, data, dragEnterPath, path);
    interaction.emit(DragEvent.ENTER, data, path, dragEnterPath);
    this.dragEnterPath = path;
  }
  dragEnd(data, speed) {
    if (!this.dragging && !this.moving)
      return;
    const { moveX, moveY } = this.dragData;
    if (this.interaction.config.move.dragAnimate && this.canAnimate && this.moving && (Math.abs(moveX) > 1 || Math.abs(moveY) > 1)) {
      data = Object.assign({}, data);
      speed = (speed || (data.pointerType === "touch" ? 2 : 1)) * 0.9;
      PointHelper.move(data, moveX * speed, moveY * speed);
      this.drag(data);
      this.animate(() => {
        this.dragEnd(data, 1);
      });
    } else
      this.dragEndReal(data);
  }
  dragEndReal(data) {
    const { interaction, downData, dragData } = this;
    if (!data)
      data = dragData;
    const { path, throughPath } = downData;
    const endDragData = getDragEventData(downData, data, data);
    if (throughPath)
      endDragData.throughPath = throughPath;
    endDragData.path = path;
    if (this.moving) {
      this.moving = false;
      endDragData.moveType = "drag";
      interaction.emit(MoveEvent.END, endDragData);
    }
    if (this.dragging) {
      const dropList = this.getList();
      this.dragging = false;
      interaction.emit(DragEvent.END, endDragData);
      this.swipe(data, downData, dragData, endDragData);
      this.drop(data, dropList, this.dragEnterPath);
    }
    this.autoMoveCancel();
    this.dragReset();
    this.animate(null, "off");
  }
  animate(func, off2) {
    const animateWait = func || this.animateWait;
    if (animateWait)
      this.interaction.target.nextRender(animateWait, null, off2);
    this.animateWait = func;
  }
  swipe(data, downData, dragData, endDragData) {
    const { interaction } = this;
    if (PointHelper.getDistance(downData, data) > interaction.config.pointer.swipeDistance) {
      const swipeData = getSwipeEventData(downData, dragData, endDragData);
      this.interaction.emit(swipeData.type, swipeData);
    }
  }
  drop(data, dropList, dragEnterPath) {
    const dropData = getDropEventData(data, dropList, DragEvent.data);
    dropData.path = dragEnterPath;
    this.interaction.emit(DropEvent.DROP, dropData);
    this.interaction.emit(DragEvent.LEAVE, data, dragEnterPath);
  }
  dragReset() {
    DragEvent.list = DragEvent.data = this.draggableList = this.dragData = this.downData = this.dragOverPath = this.dragEnterPath = null;
  }
  checkDragOut(data) {
    const { interaction } = this;
    this.autoMoveCancel();
    if (this.dragging && !interaction.shrinkCanvasBounds.hitPoint(data))
      this.autoMoveOnDragOut(data);
  }
  autoMoveOnDragOut(data) {
    const { interaction, downData, canDragOut } = this;
    const { autoDistance, dragOut } = interaction.config.move;
    if (!dragOut || !canDragOut || !autoDistance)
      return;
    const bounds2 = interaction.shrinkCanvasBounds;
    const { x, y } = bounds2;
    const right3 = BoundsHelper.maxX(bounds2);
    const bottom3 = BoundsHelper.maxY(bounds2);
    const moveX = data.x < x ? autoDistance : right3 < data.x ? -autoDistance : 0;
    const moveY = data.y < y ? autoDistance : bottom3 < data.y ? -autoDistance : 0;
    let totalX = 0, totalY = 0;
    this.autoMoveTimer = setInterval(() => {
      totalX += moveX;
      totalY += moveY;
      PointHelper.move(downData, moveX, moveY);
      PointHelper.move(this.dragData, moveX, moveY);
      interaction.move(Object.assign(Object.assign({}, data), { moveX, moveY, totalX, totalY, moveType: "drag" }));
      interaction.pointerMoveReal(data);
    }, 10);
  }
  autoMoveCancel() {
    if (this.autoMoveTimer) {
      clearInterval(this.autoMoveTimer);
      this.autoMoveTimer = 0;
    }
  }
  destroy() {
    this.dragReset();
  }
};
var debug3 = Debug.get("emit");
function emit2(type, data, path, excludePath) {
  if (!path && !data.path)
    return;
  let leaf2;
  data.type = type;
  if (path) {
    data = Object.assign(Object.assign({}, data), { path });
  } else {
    path = data.path;
  }
  data.target = path.indexAt(0);
  try {
    for (let i = path.length - 1; i > -1; i--) {
      leaf2 = path.list[i];
      if (emitEvent2(leaf2, type, data, true, excludePath))
        return;
      if (leaf2.isApp)
        emitAppChildren(leaf2, type, data, true, excludePath);
    }
    for (let i = 0, len = path.length; i < len; i++) {
      leaf2 = path.list[i];
      if (leaf2.isApp)
        emitAppChildren(leaf2, type, data, false, excludePath);
      if (emitEvent2(leaf2, type, data, false, excludePath))
        return;
    }
  } catch (e) {
    debug3.error(e);
  }
}
var allowTypes = ["move", "zoom", "rotate", "key"];
function emitAppChildren(leaf2, type, data, capture, excludePath) {
  if (allowTypes.some((name) => type.startsWith(name)) && leaf2.__.hitChildren && !exclude(leaf2, excludePath)) {
    let child;
    for (let i = 0, len = leaf2.children.length; i < len; i++) {
      child = leaf2.children[i];
      if (!data.path.has(child) && child.__.hittable)
        emitEvent2(child, type, data, capture, excludePath);
    }
  }
}
function emitEvent2(leaf2, type, data, capture, excludePath) {
  if (leaf2.destroyed)
    return false;
  if (leaf2.__.hitSelf && !exclude(leaf2, excludePath)) {
    if (State.updateEventStyle && !capture)
      State.updateEventStyle(leaf2, type);
    if (leaf2.hasEvent(type, capture)) {
      data.phase = capture ? 1 : leaf2 === data.target ? 2 : 3;
      const event = EventCreator.get(type, data);
      leaf2.emitEvent(event, capture);
      if (event.isStop)
        return true;
    }
  }
  return false;
}
function exclude(leaf2, excludePath) {
  return excludePath && excludePath.has(leaf2);
}
var MultiTouchHelper = {
  getData(list3) {
    const a2 = list3[0];
    const b = list3[1];
    const lastCenter = PointHelper.getCenter(a2.from, b.from);
    const center = PointHelper.getCenter(a2.to, b.to);
    const move2 = { x: center.x - lastCenter.x, y: center.y - lastCenter.y };
    const lastDistance = PointHelper.getDistance(a2.from, b.from);
    const distance = PointHelper.getDistance(a2.to, b.to);
    const scale2 = distance / lastDistance;
    const angle = PointHelper.getRotation(a2.from, b.from, a2.to, b.to);
    return { move: move2, scale: scale2, angle, center };
  }
};
var config = {
  wheel: {
    zoomSpeed: 0.5,
    moveSpeed: 0.5,
    rotateSpeed: 0.5,
    delta: { x: 80 / 4, y: 8 },
    preventDefault: true
  },
  pointer: {
    hitRadius: 5,
    tapTime: 120,
    longPressTime: 800,
    transformTime: 500,
    hover: true,
    dragHover: true,
    dragDistance: 2,
    swipeDistance: 20,
    preventDefaultMenu: true
  },
  touch: {
    preventDefault: true
  },
  multiTouch: {},
  cursor: true,
  keyEvent: true
};
var { pathHasEventType, getMoveEventData, getZoomEventData, getRotateEventData, pathCanDrag, pathHasOutside } = InteractionHelper;
var InteractionBase = class {
  get dragging() {
    return this.dragger.dragging;
  }
  get transforming() {
    return this.transformer.transforming;
  }
  get moveMode() {
    return this.m.drag === true || this.isHoldSpaceKey || this.isHoldMiddleKey || this.isHoldRightKey && this.dragger.moving || this.isDragEmpty;
  }
  get canHover() {
    return this.p.hover && !this.config.mobile;
  }
  get isDragEmpty() {
    return this.m.dragEmpty && this.isRootPath(this.hoverData) && (!this.downData || this.isRootPath(this.downData));
  }
  get isMobileDragEmpty() {
    return this.m.dragEmpty && !this.canHover && this.downData && this.isTreePath(this.downData);
  }
  get isHoldMiddleKey() {
    return this.m.holdMiddleKey && this.downData && PointerButton.middle(this.downData);
  }
  get isHoldRightKey() {
    return this.m.holdRightKey && this.downData && PointerButton.right(this.downData);
  }
  get isHoldSpaceKey() {
    return this.m.holdSpaceKey && Keyboard.isHoldSpaceKey();
  }
  get m() {
    return this.config.move;
  }
  get p() {
    return this.config.pointer;
  }
  get hitRadius() {
    return this.p.hitRadius;
  }
  constructor(target, canvas3, selector, userConfig) {
    this.config = DataHelper.clone(config);
    this.tapCount = 0;
    this.downKeyMap = {};
    this.target = target;
    this.canvas = canvas3;
    this.selector = selector;
    this.defaultPath = new LeafList(target);
    this.transformer = new Transformer(this);
    this.dragger = new Dragger(this);
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
  }
  start() {
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  receive(_event) {
  }
  pointerDown(data, useDefaultPath) {
    if (!data)
      data = this.hoverData;
    if (!data)
      return;
    PointerButton.defaultLeft(data);
    this.updateDownData(data);
    this.checkPath(data, useDefaultPath);
    this.downTime = Date.now();
    this.emit(PointerEvent.BEFORE_DOWN, data);
    this.emit(PointerEvent.DOWN, data);
    if (PointerButton.left(data)) {
      this.tapWait();
      this.longPressWait(data);
    }
    this.waitRightTap = PointerButton.right(data);
    this.dragger.setDragData(data);
    if (!this.isHoldRightKey)
      this.updateCursor(data);
  }
  pointerMove(data) {
    if (!data)
      data = this.hoverData;
    if (!data)
      return;
    const { downData } = this;
    if (downData)
      PointerButton.defaultLeft(data);
    const hit = this.canvas.bounds.hitPoint(data);
    if (hit || downData) {
      this.pointerMoveReal(data);
      if (downData)
        this.dragger.checkDragOut(data);
    }
  }
  pointerMoveReal(data) {
    const { dragHover, dragDistance } = this.p;
    this.emit(PointerEvent.BEFORE_MOVE, data, this.defaultPath);
    if (this.downData) {
      const canDrag = PointHelper.getDistance(this.downData, data) > dragDistance;
      if (canDrag) {
        if (this.waitTap)
          this.pointerWaitCancel();
        this.waitRightTap = false;
      }
      this.dragger.checkDrag(data, canDrag);
    }
    if (!this.dragger.moving) {
      this.updateHoverData(data);
      this.checkPath(data);
      this.emit(PointerEvent.MOVE, data);
      if (!(this.dragging && !dragHover))
        this.pointerHover(data);
      if (this.dragger.dragging) {
        this.dragger.dragOverOrOut(data);
        this.dragger.dragEnterOrLeave(data);
      }
    }
    this.updateCursor(this.downData || data);
  }
  pointerUp(data) {
    const { downData } = this;
    if (!data)
      data = downData;
    if (!downData)
      return;
    PointerButton.defaultLeft(data);
    data.multiTouch = downData.multiTouch;
    this.findPath(data);
    const upData = Object.assign(Object.assign({}, data), { path: data.path.clone() });
    data.path.addList(downData.path.list);
    this.checkPath(data);
    this.downData = null;
    this.emit(PointerEvent.BEFORE_UP, data);
    this.emit(PointerEvent.UP, data);
    this.touchLeave(data);
    if (!data.isCancel) {
      this.tap(data);
      this.menuTap(data);
    }
    this.dragger.dragEnd(data);
    this.updateCursor(upData);
  }
  pointerCancel() {
    const data = Object.assign({}, this.dragger.dragData);
    data.isCancel = true;
    this.pointerUp(data);
  }
  multiTouch(data, list3) {
    if (this.config.multiTouch.disabled)
      return;
    const { move: move2, angle, scale: scale2, center } = MultiTouchHelper.getData(list3);
    this.rotate(getRotateEventData(center, angle, data));
    this.zoom(getZoomEventData(center, scale2, data));
    this.move(getMoveEventData(center, move2, data));
  }
  menu(data) {
    this.findPath(data);
    this.emit(PointerEvent.MENU, data);
    this.waitMenuTap = true;
    if (!this.downData && this.waitRightTap)
      this.menuTap(data);
  }
  menuTap(data) {
    if (this.waitRightTap && this.waitMenuTap) {
      this.emit(PointerEvent.MENU_TAP, data);
      this.waitRightTap = this.waitMenuTap = false;
    }
  }
  move(data) {
    this.transformer.move(data);
  }
  zoom(data) {
    this.transformer.zoom(data);
  }
  rotate(data) {
    this.transformer.rotate(data);
  }
  transformEnd() {
    this.transformer.transformEnd();
  }
  keyDown(data) {
    if (!this.config.keyEvent)
      return;
    const { code } = data;
    if (!this.downKeyMap[code]) {
      this.downKeyMap[code] = true;
      Keyboard.setDownCode(code);
      this.emit(KeyEvent.HOLD, data, this.defaultPath);
      if (this.moveMode) {
        this.cancelHover();
        this.updateCursor();
      }
    }
    this.emit(KeyEvent.DOWN, data, this.defaultPath);
  }
  keyUp(data) {
    if (!this.config.keyEvent)
      return;
    const { code } = data;
    this.downKeyMap[code] = false;
    Keyboard.setUpCode(code);
    this.emit(KeyEvent.UP, data, this.defaultPath);
    if (this.cursor === "grab")
      this.updateCursor();
  }
  pointerHover(data) {
    if (this.canHover) {
      this.pointerOverOrOut(data);
      this.pointerEnterOrLeave(data);
    }
  }
  pointerOverOrOut(data) {
    const { path } = data;
    const { overPath } = this;
    this.overPath = path;
    if (overPath) {
      if (path.indexAt(0) !== overPath.indexAt(0)) {
        this.emit(PointerEvent.OUT, data, overPath);
        this.emit(PointerEvent.OVER, data, path);
      }
    } else {
      this.emit(PointerEvent.OVER, data, path);
    }
  }
  pointerEnterOrLeave(data) {
    let { path } = data;
    if (this.downData && !this.moveMode) {
      path = path.clone();
      this.downData.path.forEach((leaf2) => path.add(leaf2));
    }
    const { enterPath } = this;
    this.enterPath = path;
    this.emit(PointerEvent.LEAVE, data, enterPath, path);
    this.emit(PointerEvent.ENTER, data, path, enterPath);
  }
  touchLeave(data) {
    if (data.pointerType === "touch") {
      if (this.enterPath) {
        this.emit(PointerEvent.LEAVE, data);
        if (this.dragger.dragging)
          this.emit(DropEvent.LEAVE, data);
      }
    }
  }
  tap(data) {
    const { pointer } = this.config;
    const hasLong = this.longTap(data);
    if (!pointer.tapMore && hasLong)
      return;
    if (!this.waitTap)
      return;
    if (pointer.tapMore)
      this.emitTap(data);
    const useTime = Date.now() - this.downTime;
    const hasDouble = [PointerEvent.DOUBLE_TAP, PointerEvent.DOUBLE_CLICK].some((type) => pathHasEventType(data.path, type));
    if (useTime < pointer.tapTime + 50 && hasDouble) {
      this.tapCount++;
      if (this.tapCount === 2) {
        this.tapWaitCancel();
        this.emitDoubleTap(data);
      } else {
        clearTimeout(this.tapTimer);
        this.tapTimer = setTimeout(() => {
          if (!pointer.tapMore) {
            this.tapWaitCancel();
            this.emitTap(data);
          }
        }, pointer.tapTime);
      }
    } else {
      if (!pointer.tapMore) {
        this.tapWaitCancel();
        this.emitTap(data);
      }
    }
  }
  findPath(data, options) {
    const { hitRadius, through } = this.p;
    const { bottomList } = this;
    const find = this.selector.getByPoint(data, hitRadius, Object.assign({ bottomList, name: data.type }, options || { through }));
    if (find.throughPath)
      data.throughPath = find.throughPath;
    data.path = find.path;
    return find.path;
  }
  isRootPath(data) {
    return data && data.path.list[0].isLeafer;
  }
  isTreePath(data) {
    const app = this.target.app;
    if (!app || !app.isApp)
      return false;
    return app.editor && (!data.path.has(app.editor) && data.path.has(app.tree) && !data.target.syncEventer);
  }
  checkPath(data, useDefaultPath) {
    if (useDefaultPath || this.moveMode && !pathHasOutside(data.path))
      data.path = this.defaultPath;
  }
  canMove(data) {
    return data && (this.moveMode || this.m.drag === "auto" && !pathCanDrag(data.path)) && !pathHasOutside(data.path);
  }
  isDrag(leaf2) {
    return this.dragger.getList().has(leaf2);
  }
  isPress(leaf2) {
    return this.downData && this.downData.path.has(leaf2);
  }
  isHover(leaf2) {
    return this.enterPath && this.enterPath.has(leaf2);
  }
  isFocus(leaf2) {
    return this.focusData === leaf2;
  }
  cancelHover() {
    const { hoverData } = this;
    if (hoverData) {
      hoverData.path = this.defaultPath;
      this.pointerHover(hoverData);
    }
  }
  updateDownData(data, options, merge) {
    const { downData } = this;
    if (!data && downData)
      data = downData;
    if (!data)
      return;
    this.findPath(data, options);
    if (merge && downData)
      data.path.addList(downData.path.list);
    this.downData = data;
  }
  updateHoverData(data) {
    if (!data)
      data = this.hoverData;
    if (!data)
      return;
    this.findPath(data, { exclude: this.dragger.getList(false, true), name: PointerEvent.MOVE });
    this.hoverData = data;
  }
  updateCursor(data) {
    if (!this.config.cursor || !this.canHover)
      return;
    if (!data) {
      this.updateHoverData();
      data = this.downData || this.hoverData;
    }
    if (this.dragger.moving) {
      return this.setCursor("grabbing");
    } else if (this.canMove(data)) {
      return this.setCursor(this.downData ? "grabbing" : "grab");
    } else if (!data)
      return;
    let leaf2, cursor;
    const { path } = data;
    for (let i = 0, len = path.length; i < len; i++) {
      leaf2 = path.list[i];
      cursor = leaf2.syncEventer && leaf2.syncEventer.cursor || leaf2.cursor;
      if (cursor)
        break;
    }
    this.setCursor(cursor);
  }
  setCursor(cursor) {
    this.cursor = cursor;
  }
  getLocal(clientPoint, updateClient) {
    const clientBounds = this.canvas.getClientBounds(updateClient);
    return { x: clientPoint.clientX - clientBounds.x, y: clientPoint.clientY - clientBounds.y };
  }
  emitTap(data) {
    this.emit(PointerEvent.TAP, data);
    this.emit(PointerEvent.CLICK, data);
  }
  emitDoubleTap(data) {
    this.emit(PointerEvent.DOUBLE_TAP, data);
    this.emit(PointerEvent.DOUBLE_CLICK, data);
  }
  pointerWaitCancel() {
    this.tapWaitCancel();
    this.longPressWaitCancel();
  }
  tapWait() {
    clearTimeout(this.tapTimer);
    this.waitTap = true;
  }
  tapWaitCancel() {
    clearTimeout(this.tapTimer);
    this.waitTap = false;
    this.tapCount = 0;
  }
  longPressWait(data) {
    clearTimeout(this.longPressTimer);
    this.longPressTimer = setTimeout(() => {
      this.longPressed = true;
      this.emit(PointerEvent.LONG_PRESS, data);
    }, this.p.longPressTime);
  }
  longTap(data) {
    let hasLong;
    if (this.longPressed) {
      this.emit(PointerEvent.LONG_TAP, data);
      if (pathHasEventType(data.path, PointerEvent.LONG_TAP) || pathHasEventType(data.path, PointerEvent.LONG_PRESS))
        hasLong = true;
    }
    this.longPressWaitCancel();
    return hasLong;
  }
  longPressWaitCancel() {
    clearTimeout(this.longPressTimer);
    this.longPressed = false;
  }
  __onResize() {
    this.shrinkCanvasBounds = new Bounds(this.canvas.bounds);
    this.shrinkCanvasBounds.spread(-2);
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [target.on_(ResizeEvent.RESIZE, this.__onResize, this)];
    target.once(LeaferEvent.READY, () => this.__onResize());
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
    this.__eventIds.length = 0;
  }
  emit(type, data, path, excludePath) {
    if (this.running)
      emit2(type, data, path, excludePath);
  }
  destroy() {
    if (this.__eventIds.length) {
      this.stop();
      this.__removeListenEvents();
      this.dragger.destroy();
      this.transformer.destroy();
      this.downData = this.overPath = this.enterPath = null;
    }
  }
};
var Cursor = class {
  static set(name, value) {
    this.custom[name] = value;
  }
  static get(name) {
    return this.custom[name];
  }
};
Cursor.custom = {};
var HitCanvasManager = class extends CanvasManager {
  constructor() {
    super(...arguments);
    this.maxTotal = 1e3;
    this.pathList = new LeafList();
    this.pixelList = new LeafList();
  }
  getPixelType(leaf2, config2) {
    this.__autoClear();
    this.pixelList.add(leaf2);
    return Creator.hitCanvas(config2);
  }
  getPathType(leaf2) {
    this.__autoClear();
    this.pathList.add(leaf2);
    return Creator.hitCanvas();
  }
  clearImageType() {
    this.__clearLeafList(this.pixelList);
  }
  clearPathType() {
    this.__clearLeafList(this.pathList);
  }
  __clearLeafList(leafList) {
    if (leafList.length) {
      leafList.forEach((leaf2) => {
        if (leaf2.__hitCanvas) {
          leaf2.__hitCanvas.destroy();
          leaf2.__hitCanvas = null;
        }
      });
      leafList.reset();
    }
  }
  __autoClear() {
    if (this.pathList.length + this.pixelList.length > this.maxTotal)
      this.clear();
  }
  clear() {
    this.clearPathType();
    this.clearImageType();
  }
};
var { toInnerRadiusPointOf, copy: copy3, setRadius } = PointHelper;
var inner = {};
var leaf = Leaf.prototype;
leaf.__hitWorld = function(point2) {
  if (!this.__.hitSelf)
    return false;
  if (this.__.hitRadius) {
    copy3(inner, point2), point2 = inner;
    setRadius(point2, this.__.hitRadius);
  }
  toInnerRadiusPointOf(point2, this.__world, inner);
  const { width, height } = this.__world;
  const isSmall = width < 10 && height < 10;
  if (this.__.hitBox || isSmall) {
    if (BoundsHelper.hitRadiusPoint(this.__layout.boxBounds, inner))
      return true;
    if (isSmall)
      return false;
  }
  if (this.__layout.hitCanvasChanged || !this.__hitCanvas) {
    this.__updateHitCanvas();
    if (!this.__layout.boundsChanged)
      this.__layout.hitCanvasChanged = false;
  }
  return this.__hit(inner);
};
leaf.__hitFill = function(inner2) {
  var _a;
  return (_a = this.__hitCanvas) === null || _a === void 0 ? void 0 : _a.hitFill(inner2, this.__.windingRule);
};
leaf.__hitStroke = function(inner2, strokeWidth) {
  var _a;
  return (_a = this.__hitCanvas) === null || _a === void 0 ? void 0 : _a.hitStroke(inner2, strokeWidth);
};
leaf.__hitPixel = function(inner2) {
  var _a;
  return (_a = this.__hitCanvas) === null || _a === void 0 ? void 0 : _a.hitPixel(inner2, this.__layout.renderBounds, this.__hitCanvas.hitScale);
};
leaf.__drawHitPath = function(canvas3) {
  if (canvas3)
    this.__drawRenderPath(canvas3);
};
var matrix2 = new Matrix();
var ui$2 = UI.prototype;
ui$2.__updateHitCanvas = function() {
  const data = this.__, { hitCanvasManager } = this.leafer;
  const isHitPixelFill = (data.__pixelFill || data.__isCanvas) && data.hitFill === "pixel";
  const isHitPixelStroke = data.__pixelStroke && data.hitStroke === "pixel";
  const isHitPixel = isHitPixelFill || isHitPixelStroke;
  if (!this.__hitCanvas)
    this.__hitCanvas = isHitPixel ? hitCanvasManager.getPixelType(this, { contextSettings: { willReadFrequently: true } }) : hitCanvasManager.getPathType(this);
  const h2 = this.__hitCanvas;
  if (isHitPixel) {
    const { renderBounds } = this.__layout;
    const size = Platform.image.hitCanvasSize;
    const scale2 = h2.hitScale = tempBounds.set(0, 0, size, size).getFitMatrix(renderBounds).a;
    const { x, y, width, height } = tempBounds.set(renderBounds).scale(scale2);
    h2.resize({ width, height, pixelRatio: 1 });
    h2.clear();
    ImageManager.patternLocked = true;
    this.__renderShape(h2, { matrix: matrix2.setWith(this.__world).scaleWith(1 / scale2).invertWith().translate(-x, -y) }, !isHitPixelFill, !isHitPixelStroke);
    ImageManager.patternLocked = false;
    h2.resetTransform();
    data.__isHitPixel = true;
  } else {
    data.__isHitPixel && (data.__isHitPixel = false);
  }
  this.__drawHitPath(h2);
  h2.setStrokeOptions(data);
};
ui$2.__hit = function(inner2) {
  if (Platform.name === "miniapp")
    this.__drawHitPath(this.__hitCanvas);
  const data = this.__;
  if (data.__isHitPixel && this.__hitPixel(inner2))
    return true;
  const { hitFill } = data;
  const needHitFillPath = (data.fill || data.__isCanvas) && (hitFill === "path" || hitFill === "pixel" && !(data.__pixelFill || data.__isCanvas)) || hitFill === "all";
  if (needHitFillPath && this.__hitFill(inner2))
    return true;
  const { hitStroke, __strokeWidth } = data;
  const needHitStrokePath = data.stroke && (hitStroke === "path" || hitStroke === "pixel" && !data.__pixelStroke) || hitStroke === "all";
  if (!needHitFillPath && !needHitStrokePath)
    return false;
  const radiusWidth = inner2.radiusX * 2;
  let hitWidth = radiusWidth;
  if (needHitStrokePath) {
    switch (data.strokeAlign) {
      case "inside":
        hitWidth += __strokeWidth * 2;
        if (!needHitFillPath && this.__hitFill(inner2) && this.__hitStroke(inner2, hitWidth))
          return true;
        hitWidth = radiusWidth;
        break;
      case "center":
        hitWidth += __strokeWidth;
        break;
      case "outside":
        hitWidth += __strokeWidth * 2;
        if (!needHitFillPath) {
          if (!this.__hitFill(inner2) && this.__hitStroke(inner2, hitWidth))
            return true;
          hitWidth = radiusWidth;
        }
        break;
    }
  }
  return hitWidth ? this.__hitStroke(inner2, hitWidth) : false;
};
var ui$1 = UI.prototype;
var rect3 = Rect.prototype;
var box = Box.prototype;
rect3.__updateHitCanvas = box.__updateHitCanvas = function() {
  if (this.stroke || this.cornerRadius || (this.fill || this.__.__isCanvas) && this.hitFill === "pixel" || this.hitStroke === "all")
    ui$1.__updateHitCanvas.call(this);
  else if (this.__hitCanvas)
    this.__hitCanvas = null;
};
rect3.__hitFill = box.__hitFill = function(inner2) {
  return this.__hitCanvas ? ui$1.__hitFill.call(this, inner2) : BoundsHelper.hitRadiusPoint(this.__layout.boxBounds, inner2);
};
var ui = UI.prototype;
var group2 = Group.prototype;
function getSelector(ui2) {
  return ui2.leafer ? ui2.leafer.selector : Platform.selector || (Platform.selector = Creator.selector());
}
ui.find = function(condition, options) {
  return getSelector(this).getBy(condition, this, false, options);
};
ui.findOne = function(condition, options) {
  return getSelector(this).getBy(condition, this, true, options);
};
group2.pick = function(hitPoint, options) {
  this.__layout.update();
  if (!options)
    options = {};
  return getSelector(this).getByPoint(hitPoint, options.hitRadius || 0, Object.assign(Object.assign({}, options), { target: this }));
};
var canvas = LeaferCanvasBase.prototype;
canvas.hitFill = function(point2, fillRule) {
  return fillRule ? this.context.isPointInPath(point2.x, point2.y, fillRule) : this.context.isPointInPath(point2.x, point2.y);
};
canvas.hitStroke = function(point2, strokeWidth) {
  this.strokeWidth = strokeWidth;
  return this.context.isPointInStroke(point2.x, point2.y);
};
canvas.hitPixel = function(radiusPoint, offset, scale2 = 1) {
  let { x, y, radiusX: radiusX2, radiusY: radiusY2 } = radiusPoint;
  if (offset)
    x -= offset.x, y -= offset.y;
  tempBounds.set(x - radiusX2, y - radiusY2, radiusX2 * 2, radiusY2 * 2).scale(scale2).ceil();
  const { data } = this.context.getImageData(tempBounds.x, tempBounds.y, tempBounds.width || 1, tempBounds.height || 1);
  for (let i = 0, len = data.length; i < len; i += 4) {
    if (data[i + 3] > 0)
      return true;
  }
  return data[3] > 0;
};

// node_modules/leafer-ui/dist/web.esm.js
var debug$32 = Debug.get("LeaferCanvas");
var LeaferCanvas = class extends LeaferCanvasBase {
  set zIndex(zIndex) {
    const { style } = this.view;
    style.zIndex = zIndex;
    this.setAbsolute(this.view);
  }
  set childIndex(index) {
    const { view, parentView } = this;
    if (view && parentView) {
      const beforeNode = parentView.children[index];
      if (beforeNode) {
        this.setAbsolute(beforeNode);
        parentView.insertBefore(view, beforeNode);
      } else {
        parentView.appendChild(beforeNode);
      }
    }
  }
  init() {
    const { config: config2 } = this;
    const view = config2.view || config2.canvas;
    view ? this.__createViewFrom(view) : this.__createView();
    const { style } = this.view;
    style.display || (style.display = "block");
    this.parentView = this.view.parentElement;
    if (this.parentView) {
      const pStyle = this.parentView.style;
      pStyle.webkitUserSelect = pStyle.userSelect = "none";
    }
    if (Platform.syncDomFont && !this.parentView) {
      style.display = "none";
      document.body.appendChild(this.view);
    }
    this.__createContext();
    if (!this.autoLayout)
      this.resize(config2);
  }
  set backgroundColor(color) {
    this.view.style.backgroundColor = color;
  }
  get backgroundColor() {
    return this.view.style.backgroundColor;
  }
  set hittable(hittable) {
    this.view.style.pointerEvents = hittable ? "auto" : "none";
  }
  get hittable() {
    return this.view.style.pointerEvents !== "none";
  }
  __createView() {
    this.view = document.createElement("canvas");
  }
  __createViewFrom(inputView) {
    let find = typeof inputView === "string" ? document.getElementById(inputView) : inputView;
    if (find) {
      if (find instanceof HTMLCanvasElement) {
        this.view = find;
      } else {
        let parent = find;
        if (find === window || find === document) {
          const div = document.createElement("div");
          const { style } = div;
          style.position = "absolute";
          style.top = style.bottom = style.left = style.right = "0px";
          document.body.appendChild(div);
          parent = div;
        }
        this.__createView();
        const view = this.view;
        if (parent.hasChildNodes()) {
          this.setAbsolute(view);
          parent.style.position || (parent.style.position = "relative");
        }
        parent.appendChild(view);
      }
    } else {
      debug$32.error(`no id: ${inputView}`);
      this.__createView();
    }
  }
  setAbsolute(view) {
    const { style } = view;
    style.position = "absolute";
    style.top = style.left = "0px";
  }
  updateViewSize() {
    const { width, height, pixelRatio } = this;
    const { style } = this.view;
    style.width = width + "px";
    style.height = height + "px";
    this.view.width = Math.ceil(width * pixelRatio);
    this.view.height = Math.ceil(height * pixelRatio);
  }
  updateClientBounds() {
    this.clientBounds = this.view.getBoundingClientRect();
  }
  startAutoLayout(autoBounds, listener) {
    this.resizeListener = listener;
    if (autoBounds) {
      this.autoBounds = autoBounds;
      try {
        this.resizeObserver = new ResizeObserver((entries) => {
          this.updateClientBounds();
          for (const entry of entries)
            this.checkAutoBounds(entry.contentRect);
        });
        const parent = this.parentView;
        if (parent) {
          this.resizeObserver.observe(parent);
          this.checkAutoBounds(parent.getBoundingClientRect());
        } else {
          this.checkAutoBounds(this.view);
          debug$32.warn("no parent");
        }
      } catch (_a) {
        this.imitateResizeObserver();
      }
    } else {
      window.addEventListener("resize", () => {
        const pixelRatio = Platform.devicePixelRatio;
        if (this.pixelRatio !== pixelRatio) {
          const { width, height } = this;
          this.emitResize({ width, height, pixelRatio });
        }
      });
    }
  }
  imitateResizeObserver() {
    if (this.autoLayout) {
      if (this.parentView)
        this.checkAutoBounds(this.parentView.getBoundingClientRect());
      Platform.requestRender(this.imitateResizeObserver.bind(this));
    }
  }
  checkAutoBounds(parentSize) {
    const view = this.view;
    const { x, y, width, height } = this.autoBounds.getBoundsFrom(parentSize);
    const size = { width, height, pixelRatio: Platform.devicePixelRatio };
    if (!this.isSameSize(size)) {
      const { style } = view;
      style.marginLeft = x + "px";
      style.marginTop = y + "px";
      this.emitResize(size);
    }
  }
  stopAutoLayout() {
    this.autoLayout = false;
    this.resizeListener = null;
    if (this.resizeObserver) {
      this.resizeObserver.disconnect();
      this.resizeObserver = null;
    }
  }
  emitResize(size) {
    const oldSize = {};
    DataHelper.copyAttrs(oldSize, this, canvasSizeAttrs);
    this.resize(size);
    if (this.resizeListener && this.width !== void 0)
      this.resizeListener(new ResizeEvent(size, oldSize));
  }
  unrealCanvas() {
    if (!this.unreal && this.parentView) {
      const view = this.view;
      if (view)
        view.remove();
      this.view = this.parentView;
      this.unreal = true;
    }
  }
  destroy() {
    if (this.view) {
      this.stopAutoLayout();
      if (!this.unreal) {
        const view = this.view;
        if (view.parentElement)
          view.remove();
      }
      super.destroy();
    }
  }
};
canvasPatch(CanvasRenderingContext2D.prototype);
canvasPatch(Path2D.prototype);
var { mineType, fileType } = FileHelper;
Object.assign(Creator, {
  canvas: (options, manager) => new LeaferCanvas(options, manager),
  image: (options) => new LeaferImage(options)
});
function useCanvas(_canvasType, _power) {
  Platform.origin = {
    createCanvas(width, height) {
      const canvas3 = document.createElement("canvas");
      canvas3.width = width;
      canvas3.height = height;
      return canvas3;
    },
    canvasToDataURL: (canvas3, type, quality) => canvas3.toDataURL(mineType(type), quality),
    canvasToBolb: (canvas3, type, quality) => new Promise((resolve) => canvas3.toBlob(resolve, mineType(type), quality)),
    canvasSaveAs: (canvas3, filename, quality) => {
      const url = canvas3.toDataURL(mineType(fileType(filename)), quality);
      return Platform.origin.download(url, filename);
    },
    download(url, filename) {
      return new Promise((resolve) => {
        let el = document.createElement("a");
        el.href = url;
        el.download = filename;
        document.body.appendChild(el);
        el.click();
        document.body.removeChild(el);
        resolve();
      });
    },
    loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        const { crossOrigin } = Platform.image;
        if (crossOrigin) {
          img.setAttribute("crossOrigin", crossOrigin);
          img.crossOrigin = crossOrigin;
        }
        img.onload = () => {
          resolve(img);
        };
        img.onerror = (e) => {
          reject(e);
        };
        img.src = Platform.image.getRealURL(src);
      });
    }
  };
  Platform.event = {
    stopDefault(origin2) {
      origin2.preventDefault();
    },
    stopNow(origin2) {
      origin2.stopImmediatePropagation();
    },
    stop(origin2) {
      origin2.stopPropagation();
    }
  };
  Platform.canvas = Creator.canvas();
  Platform.conicGradientSupport = !!Platform.canvas.context.createConicGradient;
}
Platform.name = "web";
Platform.isMobile = "ontouchstart" in window;
Platform.requestRender = function(render) {
  window.requestAnimationFrame(render);
};
defineKey(Platform, "devicePixelRatio", { get() {
  return Math.max(1, devicePixelRatio);
} });
var { userAgent } = navigator;
if (userAgent.indexOf("Firefox") > -1) {
  Platform.conicGradientRotate90 = true;
  Platform.intWheelDeltaY = true;
  Platform.syncDomFont = true;
} else if (userAgent.indexOf("Safari") > -1 && userAgent.indexOf("Chrome") === -1) {
  Platform.fullImageShadow = true;
}
if (userAgent.indexOf("Windows") > -1) {
  Platform.os = "Windows";
  Platform.intWheelDeltaY = true;
} else if (userAgent.indexOf("Mac") > -1) {
  Platform.os = "Mac";
} else if (userAgent.indexOf("Linux") > -1) {
  Platform.os = "Linux";
}
var Watcher = class {
  get childrenChanged() {
    return this.hasAdd || this.hasRemove || this.hasVisible;
  }
  get updatedList() {
    if (this.hasRemove) {
      const updatedList = new LeafList();
      this.__updatedList.list.forEach((item) => {
        if (item.leafer)
          updatedList.add(item);
      });
      return updatedList;
    } else {
      return this.__updatedList;
    }
  }
  constructor(target, userConfig) {
    this.totalTimes = 0;
    this.config = {};
    this.__updatedList = new LeafList();
    this.target = target;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
  }
  start() {
    if (this.disabled)
      return;
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  disable() {
    this.stop();
    this.__removeListenEvents();
    this.disabled = true;
  }
  update() {
    this.changed = true;
    if (this.running)
      this.target.emit(RenderEvent.REQUEST);
  }
  __onAttrChange(event) {
    this.__updatedList.add(event.target);
    this.update();
  }
  __onChildEvent(event) {
    if (event.type === ChildEvent.ADD) {
      this.hasAdd = true;
      this.__pushChild(event.child);
    } else {
      this.hasRemove = true;
      this.__updatedList.add(event.parent);
    }
    this.update();
  }
  __pushChild(child) {
    this.__updatedList.add(child);
    if (child.isBranch)
      this.__loopChildren(child);
  }
  __loopChildren(parent) {
    const { children } = parent;
    for (let i = 0, len = children.length; i < len; i++)
      this.__pushChild(children[i]);
  }
  __onRquestData() {
    this.target.emitEvent(new WatchEvent(WatchEvent.DATA, { updatedList: this.updatedList }));
    this.__updatedList = new LeafList();
    this.totalTimes++;
    this.changed = false;
    this.hasVisible = false;
    this.hasRemove = false;
    this.hasAdd = false;
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [
      target.on_(PropertyEvent.CHANGE, this.__onAttrChange, this),
      target.on_([ChildEvent.ADD, ChildEvent.REMOVE], this.__onChildEvent, this),
      target.on_(WatchEvent.REQUEST, this.__onRquestData, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    if (this.target) {
      this.stop();
      this.__removeListenEvents();
      this.target = null;
      this.__updatedList = null;
    }
  }
};
var { updateAllMatrix: updateAllMatrix$12, updateBounds: updateOneBounds, updateAllWorldOpacity: updateAllWorldOpacity2 } = LeafHelper;
var { pushAllChildBranch: pushAllChildBranch2, pushAllParent } = BranchHelper;
function updateMatrix2(updateList, levelList) {
  let layout;
  updateList.list.forEach((leaf2) => {
    layout = leaf2.__layout;
    if (levelList.without(leaf2) && !layout.proxyZoom) {
      if (layout.matrixChanged) {
        updateAllMatrix$12(leaf2, true);
        levelList.add(leaf2);
        if (leaf2.isBranch)
          pushAllChildBranch2(leaf2, levelList);
        pushAllParent(leaf2, levelList);
      } else if (layout.boundsChanged) {
        levelList.add(leaf2);
        if (leaf2.isBranch)
          leaf2.__tempNumber = 0;
        pushAllParent(leaf2, levelList);
      }
    }
  });
}
function updateBounds2(boundsList) {
  let list3, branch, children;
  boundsList.sort(true);
  boundsList.levels.forEach((level) => {
    list3 = boundsList.levelMap[level];
    for (let i = 0, len = list3.length; i < len; i++) {
      branch = list3[i];
      if (branch.isBranch && branch.__tempNumber) {
        children = branch.children;
        for (let j = 0, jLen = children.length; j < jLen; j++) {
          if (!children[j].isBranch) {
            updateOneBounds(children[j]);
          }
        }
      }
      updateOneBounds(branch);
    }
  });
}
function updateChange(updateList) {
  let layout;
  updateList.list.forEach((leaf2) => {
    layout = leaf2.__layout;
    if (layout.opacityChanged)
      updateAllWorldOpacity2(leaf2);
    if (layout.stateStyleChanged)
      setTimeout(() => layout.stateStyleChanged && leaf2.updateState());
    leaf2.__updateChange();
  });
}
var { worldBounds } = LeafBoundsHelper;
var bigBounds = { x: 0, y: 0, width: 1e5, height: 1e5 };
var LayoutBlockData = class {
  constructor(list3) {
    this.updatedBounds = new Bounds();
    this.beforeBounds = new Bounds();
    this.afterBounds = new Bounds();
    if (list3 instanceof Array)
      list3 = new LeafList(list3);
    this.updatedList = list3;
  }
  setBefore() {
    this.beforeBounds.setListWithFn(this.updatedList.list, worldBounds);
  }
  setAfter() {
    const { list: list3 } = this.updatedList;
    if (list3.some((leaf2) => leaf2.noBounds)) {
      this.afterBounds.set(bigBounds);
    } else {
      this.afterBounds.setListWithFn(list3, worldBounds);
    }
    this.updatedBounds.setList([this.beforeBounds, this.afterBounds]);
  }
  merge(data) {
    this.updatedList.addList(data.updatedList.list);
    this.beforeBounds.add(data.beforeBounds);
    this.afterBounds.add(data.afterBounds);
    this.updatedBounds.add(data.updatedBounds);
  }
  destroy() {
    this.updatedList = null;
  }
};
var { updateAllMatrix: updateAllMatrix2, updateAllChange: updateAllChange2 } = LeafHelper;
var debug$22 = Debug.get("Layouter");
var Layouter = class _Layouter {
  constructor(target, userConfig) {
    this.totalTimes = 0;
    this.config = {};
    this.__levelList = new LeafLevelList();
    this.target = target;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
  }
  start() {
    if (this.disabled)
      return;
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  disable() {
    this.stop();
    this.__removeListenEvents();
    this.disabled = true;
  }
  layout() {
    if (!this.running)
      return;
    const { target } = this;
    this.times = 0;
    try {
      target.emit(LayoutEvent.START);
      this.layoutOnce();
      target.emitEvent(new LayoutEvent(LayoutEvent.END, this.layoutedBlocks, this.times));
    } catch (e) {
      debug$22.error(e);
    }
    this.layoutedBlocks = null;
  }
  layoutAgain() {
    if (this.layouting) {
      this.waitAgain = true;
    } else {
      this.layoutOnce();
    }
  }
  layoutOnce() {
    if (this.layouting)
      return debug$22.warn("layouting");
    if (this.times > 3)
      return debug$22.warn("layout max times");
    this.times++;
    this.totalTimes++;
    this.layouting = true;
    this.target.emit(WatchEvent.REQUEST);
    if (this.totalTimes > 1) {
      this.partLayout();
    } else {
      this.fullLayout();
    }
    this.layouting = false;
    if (this.waitAgain) {
      this.waitAgain = false;
      this.layoutOnce();
    }
  }
  partLayout() {
    var _a;
    if (!((_a = this.__updatedList) === null || _a === void 0 ? void 0 : _a.length))
      return;
    const t2 = Run.start("PartLayout");
    const { target, __updatedList: updateList } = this;
    const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
    const blocks = this.getBlocks(updateList);
    blocks.forEach((item) => item.setBefore());
    target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
    this.extraBlock = null;
    updateList.sort();
    updateMatrix2(updateList, this.__levelList);
    updateBounds2(this.__levelList);
    updateChange(updateList);
    if (this.extraBlock)
      blocks.push(this.extraBlock);
    blocks.forEach((item) => item.setAfter());
    target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
    target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
    this.addBlocks(blocks);
    this.__levelList.reset();
    this.__updatedList = null;
    Run.end(t2);
  }
  fullLayout() {
    const t2 = Run.start("FullLayout");
    const { target } = this;
    const { BEFORE, LAYOUT, AFTER } = LayoutEvent;
    const blocks = this.getBlocks(new LeafList(target));
    target.emitEvent(new LayoutEvent(BEFORE, blocks, this.times));
    _Layouter.fullLayout(target);
    blocks.forEach((item) => {
      item.setAfter();
    });
    target.emitEvent(new LayoutEvent(LAYOUT, blocks, this.times));
    target.emitEvent(new LayoutEvent(AFTER, blocks, this.times));
    this.addBlocks(blocks);
    Run.end(t2);
  }
  static fullLayout(target) {
    updateAllMatrix2(target, true);
    if (target.isBranch) {
      BranchHelper.updateBounds(target);
    } else {
      LeafHelper.updateBounds(target);
    }
    updateAllChange2(target);
  }
  addExtra(leaf2) {
    if (!this.__updatedList.has(leaf2)) {
      const { updatedList, beforeBounds } = this.extraBlock || (this.extraBlock = new LayoutBlockData([]));
      updatedList.length ? beforeBounds.add(leaf2.__world) : beforeBounds.set(leaf2.__world);
      updatedList.add(leaf2);
    }
  }
  createBlock(data) {
    return new LayoutBlockData(data);
  }
  getBlocks(list3) {
    return [this.createBlock(list3)];
  }
  addBlocks(current2) {
    this.layoutedBlocks ? this.layoutedBlocks.push(...current2) : this.layoutedBlocks = current2;
  }
  __onReceiveWatchData(event) {
    this.__updatedList = event.data.updatedList;
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [
      target.on_(LayoutEvent.REQUEST, this.layout, this),
      target.on_(LayoutEvent.AGAIN, this.layoutAgain, this),
      target.on_(WatchEvent.DATA, this.__onReceiveWatchData, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    if (this.target) {
      this.stop();
      this.__removeListenEvents();
      this.target = this.config = null;
    }
  }
};
var debug$14 = Debug.get("Renderer");
var Renderer = class {
  get needFill() {
    return !!(!this.canvas.allowBackgroundColor && this.config.fill);
  }
  constructor(target, canvas3, userConfig) {
    this.FPS = 60;
    this.totalTimes = 0;
    this.times = 0;
    this.config = {
      usePartRender: true,
      maxFPS: 60
    };
    this.target = target;
    this.canvas = canvas3;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.__listenEvents();
    this.__requestRender();
  }
  start() {
    this.running = true;
  }
  stop() {
    this.running = false;
  }
  update() {
    this.changed = true;
  }
  requestLayout() {
    this.target.emit(LayoutEvent.REQUEST);
  }
  render(callback) {
    if (!(this.running && this.canvas.view)) {
      this.changed = true;
      return;
    }
    const { target } = this;
    this.times = 0;
    this.totalBounds = new Bounds();
    debug$14.log(target.innerName, "--->");
    try {
      if (!target.isApp)
        target.app.emit(RenderEvent.CHILD_START, target);
      this.emitRender(RenderEvent.START);
      this.renderOnce(callback);
      this.emitRender(RenderEvent.END, this.totalBounds);
      ImageManager.clearRecycled();
    } catch (e) {
      this.rendering = false;
      debug$14.error(e);
    }
    debug$14.log("-------------|");
  }
  renderAgain() {
    if (this.rendering) {
      this.waitAgain = true;
    } else {
      this.renderOnce();
    }
  }
  renderOnce(callback) {
    if (this.rendering)
      return debug$14.warn("rendering");
    if (this.times > 3)
      return debug$14.warn("render max times");
    this.times++;
    this.totalTimes++;
    this.rendering = true;
    this.changed = false;
    this.renderBounds = new Bounds();
    this.renderOptions = {};
    if (callback) {
      this.emitRender(RenderEvent.BEFORE);
      callback();
    } else {
      this.requestLayout();
      if (this.ignore) {
        this.ignore = this.rendering = false;
        return;
      }
      this.emitRender(RenderEvent.BEFORE);
      if (this.config.usePartRender && this.totalTimes > 1) {
        this.partRender();
      } else {
        this.fullRender();
      }
    }
    this.emitRender(RenderEvent.RENDER, this.renderBounds, this.renderOptions);
    this.emitRender(RenderEvent.AFTER, this.renderBounds, this.renderOptions);
    this.updateBlocks = null;
    this.rendering = false;
    if (this.waitAgain) {
      this.waitAgain = false;
      this.renderOnce();
    }
  }
  partRender() {
    const { canvas: canvas3, updateBlocks: list3 } = this;
    if (!list3)
      return debug$14.warn("PartRender: need update attr");
    this.mergeBlocks();
    list3.forEach((block2) => {
      if (canvas3.bounds.hit(block2) && !block2.isEmpty())
        this.clipRender(block2);
    });
  }
  clipRender(block2) {
    const t2 = Run.start("PartRender");
    const { canvas: canvas3 } = this;
    const bounds2 = block2.getIntersect(canvas3.bounds);
    const includes2 = block2.includes(this.target.__world);
    const realBounds = new Bounds(bounds2);
    canvas3.save();
    if (includes2 && !Debug.showRepaint) {
      canvas3.clear();
    } else {
      bounds2.spread(10 + 1 / this.canvas.pixelRatio).ceil();
      canvas3.clearWorld(bounds2, true);
      canvas3.clipWorld(bounds2, true);
    }
    this.__render(bounds2, includes2, realBounds);
    canvas3.restore();
    Run.end(t2);
  }
  fullRender() {
    const t2 = Run.start("FullRender");
    const { canvas: canvas3 } = this;
    canvas3.save();
    canvas3.clear();
    this.__render(canvas3.bounds, true);
    canvas3.restore();
    Run.end(t2);
  }
  __render(bounds2, includes2, realBounds) {
    const options = bounds2.includes(this.target.__world) ? { includes: includes2 } : { bounds: bounds2, includes: includes2 };
    if (this.needFill)
      this.canvas.fillWorld(bounds2, this.config.fill);
    if (Debug.showRepaint)
      this.canvas.strokeWorld(bounds2, "red");
    this.target.__render(this.canvas, options);
    this.renderBounds = realBounds = realBounds || bounds2;
    this.renderOptions = options;
    this.totalBounds.isEmpty() ? this.totalBounds = realBounds : this.totalBounds.add(realBounds);
    if (Debug.showHitView)
      this.renderHitView(options);
    if (Debug.showBoundsView)
      this.renderBoundsView(options);
    this.canvas.updateRender(realBounds);
  }
  renderHitView(_options) {
  }
  renderBoundsView(_options) {
  }
  addBlock(block2) {
    if (!this.updateBlocks)
      this.updateBlocks = [];
    this.updateBlocks.push(block2);
  }
  mergeBlocks() {
    const { updateBlocks: list3 } = this;
    if (list3) {
      const bounds2 = new Bounds();
      bounds2.setList(list3);
      list3.length = 0;
      list3.push(bounds2);
    }
  }
  __requestRender() {
    const startTime = Date.now();
    Platform.requestRender(() => {
      this.FPS = Math.min(60, Math.ceil(1e3 / (Date.now() - startTime)));
      if (this.running) {
        if (this.changed && this.canvas.view)
          this.render();
        this.target.emit(RenderEvent.NEXT);
      }
      if (this.target)
        this.__requestRender();
    });
  }
  __onResize(e) {
    if (this.canvas.unreal)
      return;
    if (e.bigger || !e.samePixelRatio) {
      const { width, height } = e.old;
      const bounds2 = new Bounds(0, 0, width, height);
      if (!bounds2.includes(this.target.__world) || this.needFill || !e.samePixelRatio) {
        this.addBlock(this.canvas.bounds);
        this.target.forceUpdate("surface");
        return;
      }
    }
    this.addBlock(new Bounds(0, 0, 1, 1));
    this.changed = true;
  }
  __onLayoutEnd(event) {
    if (event.data)
      event.data.map((item) => {
        let empty2;
        if (item.updatedList)
          item.updatedList.list.some((leaf2) => {
            empty2 = !leaf2.__world.width || !leaf2.__world.height;
            if (empty2) {
              if (!leaf2.isLeafer)
                debug$14.tip(leaf2.innerName, ": empty");
              empty2 = !leaf2.isBranch || leaf2.isBranchLeaf;
            }
            return empty2;
          });
        this.addBlock(empty2 ? this.canvas.bounds : item.updatedBounds);
      });
  }
  emitRender(type, bounds2, options) {
    this.target.emitEvent(new RenderEvent(type, this.times, bounds2, options));
  }
  __listenEvents() {
    const { target } = this;
    this.__eventIds = [
      target.on_(RenderEvent.REQUEST, this.update, this),
      target.on_(LayoutEvent.END, this.__onLayoutEnd, this),
      target.on_(RenderEvent.AGAIN, this.renderAgain, this),
      target.on_(ResizeEvent.RESIZE, this.__onResize, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
  }
  destroy() {
    if (this.target) {
      this.stop();
      this.__removeListenEvents();
      this.target = this.canvas = this.config = null;
    }
  }
};
var { hitRadiusPoint } = BoundsHelper;
var Picker = class {
  constructor(target, selector) {
    this.target = target;
    this.selector = selector;
  }
  getByPoint(hitPoint, hitRadius, options) {
    if (!hitRadius)
      hitRadius = 0;
    if (!options)
      options = {};
    const through = options.through || false;
    const ignoreHittable = options.ignoreHittable || false;
    const target = options.target || this.target;
    this.exclude = options.exclude || null;
    this.point = { x: hitPoint.x, y: hitPoint.y, radiusX: hitRadius, radiusY: hitRadius };
    this.findList = new LeafList(options.findList);
    if (!options.findList)
      this.hitBranch(target);
    const { list: list3 } = this.findList;
    const leaf2 = this.getBestMatchLeaf(list3, options.bottomList, ignoreHittable);
    const path = ignoreHittable ? this.getPath(leaf2) : this.getHitablePath(leaf2);
    this.clear();
    return through ? { path, target: leaf2, throughPath: list3.length ? this.getThroughPath(list3) : path } : { path, target: leaf2 };
  }
  getBestMatchLeaf(list3, bottomList, ignoreHittable) {
    if (list3.length) {
      let find;
      this.findList = new LeafList();
      const { x, y } = this.point;
      const point2 = { x, y, radiusX: 0, radiusY: 0 };
      for (let i = 0, len = list3.length; i < len; i++) {
        find = list3[i];
        if (ignoreHittable || LeafHelper.worldHittable(find)) {
          this.hitChild(find, point2);
          if (this.findList.length)
            return this.findList.list[0];
        }
      }
    }
    if (bottomList) {
      for (let i = 0, len = bottomList.length; i < len; i++) {
        this.hitChild(bottomList[i].target, this.point, bottomList[i].proxy);
        if (this.findList.length)
          return this.findList.list[0];
      }
    }
    return list3[0];
  }
  getPath(leaf2) {
    const path = new LeafList();
    while (leaf2) {
      path.add(leaf2);
      leaf2 = leaf2.parent;
    }
    if (this.target)
      path.add(this.target);
    return path;
  }
  getHitablePath(leaf2) {
    const path = this.getPath(leaf2 && leaf2.hittable ? leaf2 : null);
    let item, hittablePath = new LeafList();
    for (let i = path.list.length - 1; i > -1; i--) {
      item = path.list[i];
      if (!item.__.hittable)
        break;
      hittablePath.addAt(item, 0);
      if (!item.__.hitChildren)
        break;
    }
    return hittablePath;
  }
  getThroughPath(list3) {
    const throughPath = new LeafList();
    const pathList = [];
    for (let i = list3.length - 1; i > -1; i--) {
      pathList.push(this.getPath(list3[i]));
    }
    let path, nextPath, leaf2;
    for (let i = 0, len = pathList.length; i < len; i++) {
      path = pathList[i], nextPath = pathList[i + 1];
      for (let j = 0, jLen = path.length; j < jLen; j++) {
        leaf2 = path.list[j];
        if (nextPath && nextPath.has(leaf2))
          break;
        throughPath.add(leaf2);
      }
    }
    return throughPath;
  }
  hitBranch(branch) {
    this.eachFind(branch.children, branch.__onlyHitMask);
  }
  eachFind(children, hitMask) {
    let child, hit;
    const { point: point2 } = this, len = children.length;
    for (let i = len - 1; i > -1; i--) {
      child = children[i];
      if (!child.__.visible || hitMask && !child.__.mask)
        continue;
      hit = child.__.hitRadius ? true : hitRadiusPoint(child.__world, point2);
      if (child.isBranch) {
        if (hit || child.__ignoreHitWorld) {
          this.eachFind(child.children, child.__onlyHitMask);
          if (child.isBranchLeaf)
            this.hitChild(child, point2);
        }
      } else {
        if (hit)
          this.hitChild(child, point2);
      }
    }
  }
  hitChild(child, point2, proxy) {
    if (this.exclude && this.exclude.has(child))
      return;
    if (child.__hitWorld(point2)) {
      const { parent } = child;
      if (parent && parent.__hasMask && !child.__.mask && !parent.children.some((item) => item.__.mask && item.__hitWorld(point2)))
        return;
      this.findList.add(proxy || child);
    }
  }
  clear() {
    this.point = null;
    this.findList = null;
    this.exclude = null;
  }
  destroy() {
    this.clear();
  }
};
var { Yes, NoAndSkip, YesAndSkip } = Answer;
var idCondition = {};
var classNameCondition = {};
var tagCondition = {};
var Selector = class {
  constructor(target, userConfig) {
    this.config = {};
    this.innerIdMap = {};
    this.idMap = {};
    this.methods = {
      id: (leaf2, name) => leaf2.id === name ? (this.target && (this.idMap[name] = leaf2), 1) : 0,
      innerId: (leaf2, innerId) => leaf2.innerId === innerId ? (this.target && (this.innerIdMap[innerId] = leaf2), 1) : 0,
      className: (leaf2, name) => leaf2.className === name ? 1 : 0,
      tag: (leaf2, name) => leaf2.__tag === name ? 1 : 0,
      tags: (leaf2, nameMap) => nameMap[leaf2.__tag] ? 1 : 0
    };
    this.target = target;
    if (userConfig)
      this.config = DataHelper.default(userConfig, this.config);
    this.picker = new Picker(target, this);
    if (target)
      this.__listenEvents();
  }
  getBy(condition, branch, one, options) {
    switch (typeof condition) {
      case "number":
        const leaf2 = this.getByInnerId(condition, branch);
        return one ? leaf2 : leaf2 ? [leaf2] : [];
      case "string":
        switch (condition[0]) {
          case "#":
            idCondition.id = condition.substring(1), condition = idCondition;
            break;
          case ".":
            classNameCondition.className = condition.substring(1), condition = classNameCondition;
            break;
          default:
            tagCondition.tag = condition, condition = tagCondition;
        }
      case "object":
        if (condition.id !== void 0) {
          const leaf3 = this.getById(condition.id, branch);
          return one ? leaf3 : leaf3 ? [leaf3] : [];
        } else if (condition.tag) {
          const { tag } = condition, isArray = tag instanceof Array;
          return this.getByMethod(isArray ? this.methods.tags : this.methods.tag, branch, one, isArray ? DataHelper.toMap(tag) : tag);
        } else {
          return this.getByMethod(this.methods.className, branch, one, condition.className);
        }
      case "function":
        return this.getByMethod(condition, branch, one, options);
    }
  }
  getByPoint(hitPoint, hitRadius, options) {
    if (Platform.name === "node" && this.target)
      this.target.emit(LayoutEvent.CHECK_UPDATE);
    return this.picker.getByPoint(hitPoint, hitRadius, options);
  }
  getByInnerId(innerId, branch) {
    const cache2 = this.innerIdMap[innerId];
    if (cache2)
      return cache2;
    this.eachFind(this.toChildren(branch), this.methods.innerId, null, innerId);
    return this.findLeaf;
  }
  getById(id, branch) {
    const cache2 = this.idMap[id];
    if (cache2 && LeafHelper.hasParent(cache2, branch || this.target))
      return cache2;
    this.eachFind(this.toChildren(branch), this.methods.id, null, id);
    return this.findLeaf;
  }
  getByClassName(className, branch) {
    return this.getByMethod(this.methods.className, branch, false, className);
  }
  getByTag(tag, branch) {
    return this.getByMethod(this.methods.tag, branch, false, tag);
  }
  getByMethod(method, branch, one, options) {
    const list3 = one ? null : [];
    this.eachFind(this.toChildren(branch), method, list3, options);
    return list3 || this.findLeaf;
  }
  eachFind(children, method, list3, options) {
    let child, result;
    for (let i = 0, len = children.length; i < len; i++) {
      child = children[i];
      result = method(child, options);
      if (result === Yes || result === YesAndSkip) {
        if (list3) {
          list3.push(child);
        } else {
          this.findLeaf = child;
          return;
        }
      }
      if (child.isBranch && result < NoAndSkip)
        this.eachFind(child.children, method, list3, options);
    }
  }
  toChildren(branch) {
    this.findLeaf = null;
    return [branch || this.target];
  }
  __onRemoveChild(event) {
    const { id, innerId } = event.child;
    if (this.idMap[id])
      delete this.idMap[id];
    if (this.innerIdMap[innerId])
      delete this.innerIdMap[innerId];
  }
  __checkIdChange(event) {
    if (event.attrName === "id") {
      const id = event.oldValue;
      if (this.idMap[id])
        delete this.idMap[id];
    }
  }
  __listenEvents() {
    this.__eventIds = [
      this.target.on_(ChildEvent.REMOVE, this.__onRemoveChild, this),
      this.target.on_(PropertyEvent.CHANGE, this.__checkIdChange, this)
    ];
  }
  __removeListenEvents() {
    this.target.off_(this.__eventIds);
    this.__eventIds.length = 0;
  }
  destroy() {
    if (this.__eventIds.length) {
      this.__removeListenEvents();
      this.picker.destroy();
      this.findLeaf = null;
      this.innerIdMap = {};
      this.idMap = {};
    }
  }
};
Object.assign(Creator, {
  watcher: (target, options) => new Watcher(target, options),
  layouter: (target, options) => new Layouter(target, options),
  renderer: (target, canvas3, options) => new Renderer(target, canvas3, options),
  selector: (target, options) => new Selector(target, options)
});
Platform.layout = Layouter.fullLayout;
var PointerEventHelper = {
  convert(e, local) {
    const base = InteractionHelper.getBase(e);
    const data = Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: e.width, height: e.height, pointerType: e.pointerType, pressure: e.pressure });
    if (data.pointerType === "pen") {
      data.tangentialPressure = e.tangentialPressure;
      data.tiltX = e.tiltX;
      data.tiltY = e.tiltY;
      data.twist = e.twist;
    }
    return data;
  },
  convertMouse(e, local) {
    const base = InteractionHelper.getBase(e);
    return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: "mouse", pressure: 0.5 });
  },
  convertTouch(e, local) {
    const touch = PointerEventHelper.getTouch(e);
    const base = InteractionHelper.getBase(e);
    return Object.assign(Object.assign({}, base), { x: local.x, y: local.y, width: 1, height: 1, pointerType: "touch", multiTouch: e.touches.length > 1, pressure: touch.force });
  },
  getTouch(e) {
    return e.targetTouches[0] || e.changedTouches[0];
  }
};
var WheelEventHelper = {
  getMove(e, config2) {
    let { moveSpeed } = config2;
    let { deltaX, deltaY } = e;
    if (e.shiftKey && !deltaX) {
      deltaX = deltaY;
      deltaY = 0;
    }
    if (deltaX > 50)
      deltaX = Math.max(50, deltaX / 3);
    if (deltaY > 50)
      deltaY = Math.max(50, deltaY / 3);
    return { x: -deltaX * moveSpeed * 2, y: -deltaY * moveSpeed * 2 };
  },
  getScale(e, config2) {
    let zoom;
    let scale2 = 1;
    let { zoomMode, zoomSpeed } = config2;
    const delta = e.deltaY || e.deltaX;
    if (zoomMode) {
      zoom = zoomMode === "mouse" ? true : !e.deltaX && (Platform.intWheelDeltaY ? Math.abs(delta) > 17 : Math.ceil(delta) !== delta);
      if (e.shiftKey || e.metaKey || e.ctrlKey)
        zoom = true;
    } else {
      zoom = !e.shiftKey && (e.metaKey || e.ctrlKey);
    }
    if (zoom) {
      zoomSpeed = MathHelper.within(zoomSpeed, 0, 1);
      const min2 = e.deltaY ? config2.delta.y : config2.delta.x;
      scale2 = 1 - delta / (min2 * 4) * zoomSpeed;
      if (scale2 < 0.5)
        scale2 = 0.5;
      if (scale2 >= 1.5)
        scale2 = 1.5;
    }
    return scale2;
  }
};
var KeyEventHelper = {
  convert(e) {
    const base = InteractionHelper.getBase(e);
    const data = Object.assign(Object.assign({}, base), { code: e.code, key: e.key });
    return data;
  }
};
var { getMoveEventData: getMoveEventData2, getZoomEventData: getZoomEventData2, getRotateEventData: getRotateEventData2, pathCanDrag: pathCanDrag2 } = InteractionHelper;
var Interaction = class extends InteractionBase {
  __listenEvents() {
    super.__listenEvents();
    const view = this.view = this.canvas.view;
    this.viewEvents = {
      "pointerdown": this.onPointerDown,
      "mousedown": this.onMouseDown,
      "touchstart": this.onTouchStart,
      "contextmenu": this.onContextMenu,
      "wheel": this.onWheel,
      "gesturestart": this.onGesturestart,
      "gesturechange": this.onGesturechange,
      "gestureend": this.onGestureend
    };
    this.windowEvents = {
      "pointermove": this.onPointerMove,
      "pointerup": this.onPointerUp,
      "pointercancel": this.onPointerCancel,
      "mousemove": this.onMouseMove,
      "mouseup": this.onMouseUp,
      "touchmove": this.onTouchMove,
      "touchend": this.onTouchEnd,
      "touchcancel": this.onTouchCancel,
      "keydown": this.onKeyDown,
      "keyup": this.onKeyUp,
      "scroll": this.onScroll
    };
    const { viewEvents, windowEvents } = this;
    for (let name in viewEvents) {
      viewEvents[name] = viewEvents[name].bind(this);
      view.addEventListener(name, viewEvents[name]);
    }
    for (let name in windowEvents) {
      windowEvents[name] = windowEvents[name].bind(this);
      window.addEventListener(name, windowEvents[name]);
    }
  }
  __removeListenEvents() {
    super.__removeListenEvents();
    const { viewEvents, windowEvents } = this;
    for (let name in viewEvents) {
      this.view.removeEventListener(name, viewEvents[name]);
      this.viewEvents = {};
    }
    for (let name in windowEvents) {
      window.removeEventListener(name, windowEvents[name]);
      this.windowEvents = {};
    }
  }
  getTouches(touches) {
    const list3 = [];
    for (let i = 0, len = touches.length; i < len; i++) {
      list3.push(touches[i]);
    }
    return list3;
  }
  preventDefaultPointer(e) {
    const { pointer } = this.config;
    if (pointer.preventDefault)
      e.preventDefault();
  }
  preventDefaultWheel(e) {
    const { wheel } = this.config;
    if (wheel.preventDefault)
      e.preventDefault();
  }
  preventWindowPointer(e) {
    return !this.downData && e.target !== this.view;
  }
  onKeyDown(e) {
    this.keyDown(KeyEventHelper.convert(e));
  }
  onKeyUp(e) {
    this.keyUp(KeyEventHelper.convert(e));
  }
  onContextMenu(e) {
    if (this.config.pointer.preventDefaultMenu)
      e.preventDefault();
    this.menu(PointerEventHelper.convert(e, this.getLocal(e)));
  }
  onScroll() {
    this.canvas.updateClientBounds();
  }
  onPointerDown(e) {
    this.preventDefaultPointer(e);
    if (this.config.pointer.touch || this.useMultiTouch)
      return;
    this.usePointer || (this.usePointer = true);
    this.pointerDown(PointerEventHelper.convert(e, this.getLocal(e)));
  }
  onPointerMove(e) {
    if (this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(e))
      return;
    this.usePointer || (this.usePointer = true);
    this.pointerMove(PointerEventHelper.convert(e, this.getLocal(e, true)));
  }
  onPointerUp(e) {
    if (this.downData)
      this.preventDefaultPointer(e);
    if (this.config.pointer.touch || this.useMultiTouch || this.preventWindowPointer(e))
      return;
    this.pointerUp(PointerEventHelper.convert(e, this.getLocal(e)));
  }
  onPointerCancel() {
    if (this.useMultiTouch)
      return;
    this.pointerCancel();
  }
  onMouseDown(e) {
    this.preventDefaultPointer(e);
    if (this.useTouch || this.usePointer)
      return;
    this.pointerDown(PointerEventHelper.convertMouse(e, this.getLocal(e)));
  }
  onMouseMove(e) {
    if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
      return;
    this.pointerMove(PointerEventHelper.convertMouse(e, this.getLocal(e, true)));
  }
  onMouseUp(e) {
    if (this.downData)
      this.preventDefaultPointer(e);
    if (this.useTouch || this.usePointer || this.preventWindowPointer(e))
      return;
    this.pointerUp(PointerEventHelper.convertMouse(e, this.getLocal(e)));
  }
  onMouseCancel() {
    if (this.useTouch || this.usePointer)
      return;
    this.pointerCancel();
  }
  onTouchStart(e) {
    const touch = PointerEventHelper.getTouch(e);
    const local = this.getLocal(touch, true);
    const { preventDefault } = this.config.touch;
    if (preventDefault === true || preventDefault === "auto" && pathCanDrag2(this.findPath(local)))
      e.preventDefault();
    this.multiTouchStart(e);
    if (this.usePointer)
      return;
    if (this.touchTimer) {
      window.clearTimeout(this.touchTimer);
      this.touchTimer = 0;
    }
    this.useTouch = true;
    this.pointerDown(PointerEventHelper.convertTouch(e, local));
  }
  onTouchMove(e) {
    this.multiTouchMove(e);
    if (this.usePointer || this.preventWindowPointer(e))
      return;
    const touch = PointerEventHelper.getTouch(e);
    this.pointerMove(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
  }
  onTouchEnd(e) {
    this.multiTouchEnd();
    if (this.usePointer || this.preventWindowPointer(e))
      return;
    if (this.touchTimer)
      clearTimeout(this.touchTimer);
    this.touchTimer = setTimeout(() => {
      this.useTouch = false;
    }, 500);
    const touch = PointerEventHelper.getTouch(e);
    this.pointerUp(PointerEventHelper.convertTouch(e, this.getLocal(touch)));
  }
  onTouchCancel() {
    if (this.usePointer)
      return;
    this.pointerCancel();
  }
  multiTouchStart(e) {
    this.useMultiTouch = e.touches.length > 1;
    this.touches = this.useMultiTouch ? this.getTouches(e.touches) : void 0;
    if (this.useMultiTouch)
      this.pointerCancel();
  }
  multiTouchMove(e) {
    if (!this.useMultiTouch)
      return;
    if (e.touches.length > 1) {
      const touches = this.getTouches(e.touches);
      const list3 = this.getKeepTouchList(this.touches, touches);
      if (list3.length > 1) {
        this.multiTouch(InteractionHelper.getBase(e), list3);
        this.touches = touches;
      }
    }
  }
  multiTouchEnd() {
    this.touches = null;
    this.useMultiTouch = false;
    this.transformEnd();
  }
  getKeepTouchList(old, touches) {
    let to;
    const list3 = [];
    old.forEach((from) => {
      to = touches.find((touch) => touch.identifier === from.identifier);
      if (to)
        list3.push({ from: this.getLocal(from), to: this.getLocal(to) });
    });
    return list3;
  }
  getLocalTouchs(points) {
    return points.map((point2) => this.getLocal(point2));
  }
  onWheel(e) {
    this.preventDefaultWheel(e);
    const { wheel } = this.config;
    if (wheel.disabled)
      return;
    const scale2 = wheel.getScale ? wheel.getScale(e, wheel) : WheelEventHelper.getScale(e, wheel);
    const local = this.getLocal(e);
    const eventBase = InteractionHelper.getBase(e);
    scale2 !== 1 ? this.zoom(getZoomEventData2(local, scale2, eventBase)) : this.move(getMoveEventData2(local, wheel.getMove ? wheel.getMove(e, wheel) : WheelEventHelper.getMove(e, wheel), eventBase));
  }
  onGesturestart(e) {
    if (this.useMultiTouch)
      return;
    this.preventDefaultWheel(e);
    this.lastGestureScale = 1;
    this.lastGestureRotation = 0;
  }
  onGesturechange(e) {
    if (this.useMultiTouch)
      return;
    this.preventDefaultWheel(e);
    const local = this.getLocal(e);
    const eventBase = InteractionHelper.getBase(e);
    const changeScale = e.scale / this.lastGestureScale;
    const changeAngle = e.rotation - this.lastGestureRotation;
    let { rotateSpeed } = this.config.wheel;
    rotateSpeed = MathHelper.within(rotateSpeed, 0, 1);
    this.zoom(getZoomEventData2(local, changeScale * changeScale, eventBase));
    this.rotate(getRotateEventData2(local, changeAngle / Math.PI * 180 * (rotateSpeed / 4 + 0.1), eventBase));
    this.lastGestureScale = e.scale;
    this.lastGestureRotation = e.rotation;
  }
  onGestureend(e) {
    if (this.useMultiTouch)
      return;
    this.preventDefaultWheel(e);
    this.transformEnd();
  }
  setCursor(cursor) {
    super.setCursor(cursor);
    const list3 = [];
    this.eachCursor(cursor, list3);
    if (typeof list3[list3.length - 1] === "object")
      list3.push("default");
    this.canvas.view.style.cursor = list3.map((item) => typeof item === "object" ? `url(${item.url}) ${item.x || 0} ${item.y || 0}` : item).join(",");
  }
  eachCursor(cursor, list3, level = 0) {
    level++;
    if (cursor instanceof Array) {
      cursor.forEach((item) => this.eachCursor(item, list3, level));
    } else {
      const custom = typeof cursor === "string" && Cursor.get(cursor);
      if (custom && level < 2) {
        this.eachCursor(custom, list3, level);
      } else {
        list3.push(cursor);
      }
    }
  }
  destroy() {
    if (this.view) {
      super.destroy();
      this.view = null;
      this.touches = null;
    }
  }
};
function fillText(ui2, canvas3) {
  let row2;
  const { rows: rows2, decorationY, decorationHeight } = ui2.__.__textDrawData;
  for (let i = 0, len = rows2.length; i < len; i++) {
    row2 = rows2[i];
    if (row2.text)
      canvas3.fillText(row2.text, row2.x, row2.y);
    else if (row2.data)
      row2.data.forEach((charData) => {
        canvas3.fillText(charData.char, charData.x, row2.y);
      });
    if (decorationY)
      canvas3.fillRect(row2.x, row2.y + decorationY, row2.width, decorationHeight);
  }
}
function fill(fill2, ui2, canvas3) {
  canvas3.fillStyle = fill2;
  ui2.__.__font ? fillText(ui2, canvas3) : ui2.__.windingRule ? canvas3.fill(ui2.__.windingRule) : canvas3.fill();
}
function fills(fills2, ui2, canvas3) {
  let item;
  const { windingRule, __font } = ui2.__;
  for (let i = 0, len = fills2.length; i < len; i++) {
    item = fills2[i];
    if (item.image && PaintImage.checkImage(ui2, canvas3, item, !__font))
      continue;
    if (item.style) {
      canvas3.fillStyle = item.style;
      if (item.transform) {
        canvas3.save();
        canvas3.transform(item.transform);
        if (item.blendMode)
          canvas3.blendMode = item.blendMode;
        __font ? fillText(ui2, canvas3) : windingRule ? canvas3.fill(windingRule) : canvas3.fill();
        canvas3.restore();
      } else {
        if (item.blendMode) {
          canvas3.saveBlendMode(item.blendMode);
          __font ? fillText(ui2, canvas3) : windingRule ? canvas3.fill(windingRule) : canvas3.fill();
          canvas3.restoreBlendMode();
        } else {
          __font ? fillText(ui2, canvas3) : windingRule ? canvas3.fill(windingRule) : canvas3.fill();
        }
      }
    }
  }
}
function strokeText(stroke2, ui2, canvas3) {
  const { strokeAlign } = ui2.__;
  const isStrokes = typeof stroke2 !== "string";
  switch (strokeAlign) {
    case "center":
      canvas3.setStroke(isStrokes ? void 0 : stroke2, ui2.__.strokeWidth, ui2.__);
      isStrokes ? drawStrokesStyle(stroke2, true, ui2, canvas3) : drawTextStroke(ui2, canvas3);
      break;
    case "inside":
      drawAlignStroke("inside", stroke2, isStrokes, ui2, canvas3);
      break;
    case "outside":
      drawAlignStroke("outside", stroke2, isStrokes, ui2, canvas3);
      break;
  }
}
function drawAlignStroke(align, stroke2, isStrokes, ui2, canvas3) {
  const { __strokeWidth, __font } = ui2.__;
  const out = canvas3.getSameCanvas(true, true);
  out.setStroke(isStrokes ? void 0 : stroke2, __strokeWidth * 2, ui2.__);
  out.font = __font;
  isStrokes ? drawStrokesStyle(stroke2, true, ui2, out) : drawTextStroke(ui2, out);
  out.blendMode = align === "outside" ? "destination-out" : "destination-in";
  fillText(ui2, out);
  out.blendMode = "normal";
  if (ui2.__worldFlipped)
    canvas3.copyWorldByReset(out, ui2.__nowWorld);
  else
    canvas3.copyWorldToInner(out, ui2.__nowWorld, ui2.__layout.renderBounds);
  out.recycle(ui2.__nowWorld);
}
function drawTextStroke(ui2, canvas3) {
  let row2;
  const { rows: rows2, decorationY, decorationHeight } = ui2.__.__textDrawData;
  for (let i = 0, len = rows2.length; i < len; i++) {
    row2 = rows2[i];
    if (row2.text)
      canvas3.strokeText(row2.text, row2.x, row2.y);
    else if (row2.data)
      row2.data.forEach((charData) => {
        canvas3.strokeText(charData.char, charData.x, row2.y);
      });
    if (decorationY)
      canvas3.strokeRect(row2.x, row2.y + decorationY, row2.width, decorationHeight);
  }
}
function drawStrokesStyle(strokes2, isText, ui2, canvas3) {
  let item;
  for (let i = 0, len = strokes2.length; i < len; i++) {
    item = strokes2[i];
    if (item.image && PaintImage.checkImage(ui2, canvas3, item, false))
      continue;
    if (item.style) {
      canvas3.strokeStyle = item.style;
      if (item.blendMode) {
        canvas3.saveBlendMode(item.blendMode);
        isText ? drawTextStroke(ui2, canvas3) : canvas3.stroke();
        canvas3.restoreBlendMode();
      } else {
        isText ? drawTextStroke(ui2, canvas3) : canvas3.stroke();
      }
    }
  }
}
function stroke(stroke2, ui2, canvas3) {
  const options = ui2.__;
  const { __strokeWidth, strokeAlign, __font } = options;
  if (!__strokeWidth)
    return;
  if (__font) {
    strokeText(stroke2, ui2, canvas3);
  } else {
    switch (strokeAlign) {
      case "center":
        canvas3.setStroke(stroke2, __strokeWidth, options);
        canvas3.stroke();
        if (options.__useArrow)
          strokeArrow(ui2, canvas3);
        break;
      case "inside":
        canvas3.save();
        canvas3.setStroke(stroke2, __strokeWidth * 2, options);
        options.windingRule ? canvas3.clip(options.windingRule) : canvas3.clip();
        canvas3.stroke();
        canvas3.restore();
        break;
      case "outside":
        const out = canvas3.getSameCanvas(true, true);
        out.setStroke(stroke2, __strokeWidth * 2, options);
        ui2.__drawRenderPath(out);
        out.stroke();
        options.windingRule ? out.clip(options.windingRule) : out.clip();
        out.clearWorld(ui2.__layout.renderBounds);
        if (ui2.__worldFlipped)
          canvas3.copyWorldByReset(out, ui2.__nowWorld);
        else
          canvas3.copyWorldToInner(out, ui2.__nowWorld, ui2.__layout.renderBounds);
        out.recycle(ui2.__nowWorld);
        break;
    }
  }
}
function strokes(strokes2, ui2, canvas3) {
  const options = ui2.__;
  const { __strokeWidth, strokeAlign, __font } = options;
  if (!__strokeWidth)
    return;
  if (__font) {
    strokeText(strokes2, ui2, canvas3);
  } else {
    switch (strokeAlign) {
      case "center":
        canvas3.setStroke(void 0, __strokeWidth, options);
        drawStrokesStyle(strokes2, false, ui2, canvas3);
        if (options.__useArrow)
          strokeArrow(ui2, canvas3);
        break;
      case "inside":
        canvas3.save();
        canvas3.setStroke(void 0, __strokeWidth * 2, options);
        options.windingRule ? canvas3.clip(options.windingRule) : canvas3.clip();
        drawStrokesStyle(strokes2, false, ui2, canvas3);
        canvas3.restore();
        break;
      case "outside":
        const { renderBounds } = ui2.__layout;
        const out = canvas3.getSameCanvas(true, true);
        ui2.__drawRenderPath(out);
        out.setStroke(void 0, __strokeWidth * 2, options);
        drawStrokesStyle(strokes2, false, ui2, out);
        options.windingRule ? out.clip(options.windingRule) : out.clip();
        out.clearWorld(renderBounds);
        if (ui2.__worldFlipped)
          canvas3.copyWorldByReset(out, ui2.__nowWorld);
        else
          canvas3.copyWorldToInner(out, ui2.__nowWorld, renderBounds);
        out.recycle(ui2.__nowWorld);
        break;
    }
  }
}
function strokeArrow(ui2, canvas3) {
  if (ui2.__.dashPattern) {
    canvas3.beginPath();
    ui2.__drawPathByData(canvas3, ui2.__.__pathForArrow);
    canvas3.dashPattern = null;
    canvas3.stroke();
  }
}
var { getSpread, getOuterOf, getByMove, getIntersectData } = BoundsHelper;
function shape(ui2, current2, options) {
  const canvas3 = current2.getSameCanvas();
  const nowWorld = ui2.__nowWorld;
  let bounds2, fitMatrix, shapeBounds, worldCanvas;
  let { scaleX, scaleY } = nowWorld;
  if (scaleX < 0)
    scaleX = -scaleX;
  if (scaleY < 0)
    scaleY = -scaleY;
  if (current2.bounds.includes(nowWorld)) {
    worldCanvas = canvas3;
    bounds2 = shapeBounds = nowWorld;
  } else {
    const { renderShapeSpread: spread2 } = ui2.__layout;
    const worldClipBounds = getIntersectData(spread2 ? getSpread(current2.bounds, scaleX === scaleY ? spread2 * scaleX : [spread2 * scaleY, spread2 * scaleX]) : current2.bounds, nowWorld);
    fitMatrix = current2.bounds.getFitMatrix(worldClipBounds);
    let { a: fitScaleX, d: fitScaleY } = fitMatrix;
    if (fitMatrix.a < 1) {
      worldCanvas = current2.getSameCanvas();
      ui2.__renderShape(worldCanvas, options);
      scaleX *= fitScaleX;
      scaleY *= fitScaleY;
    }
    shapeBounds = getOuterOf(nowWorld, fitMatrix);
    bounds2 = getByMove(shapeBounds, -fitMatrix.e, -fitMatrix.f);
    if (options.matrix) {
      const { matrix: matrix3 } = options;
      fitMatrix.multiply(matrix3);
      fitScaleX *= matrix3.scaleX;
      fitScaleY *= matrix3.scaleY;
    }
    options = Object.assign(Object.assign({}, options), { matrix: fitMatrix.withScale(fitScaleX, fitScaleY) });
  }
  ui2.__renderShape(canvas3, options);
  return {
    canvas: canvas3,
    matrix: fitMatrix,
    bounds: bounds2,
    worldCanvas,
    shapeBounds,
    scaleX,
    scaleY
  };
}
var recycleMap;
function compute(attrName, ui2) {
  const data = ui2.__, leafPaints = [];
  let paints = data.__input[attrName], hasOpacityPixel;
  if (!(paints instanceof Array))
    paints = [paints];
  recycleMap = PaintImage.recycleImage(attrName, data);
  for (let i = 0, len = paints.length, item; i < len; i++) {
    item = getLeafPaint(attrName, paints[i], ui2);
    if (item)
      leafPaints.push(item);
  }
  data["_" + attrName] = leafPaints.length ? leafPaints : void 0;
  if (leafPaints.length && leafPaints[0].image)
    hasOpacityPixel = leafPaints[0].image.hasOpacityPixel;
  attrName === "fill" ? data.__pixelFill = hasOpacityPixel : data.__pixelStroke = hasOpacityPixel;
}
function getLeafPaint(attrName, paint, ui2) {
  if (typeof paint !== "object" || paint.visible === false || paint.opacity === 0)
    return void 0;
  const { boxBounds } = ui2.__layout;
  switch (paint.type) {
    case "solid":
      let { type, blendMode, color, opacity } = paint;
      return { type, blendMode, style: ColorConvert.string(color, opacity) };
    case "image":
      return PaintImage.image(ui2, attrName, paint, boxBounds, !recycleMap || !recycleMap[paint.url]);
    case "linear":
      return PaintGradient.linearGradient(paint, boxBounds);
    case "radial":
      return PaintGradient.radialGradient(paint, boxBounds);
    case "angular":
      return PaintGradient.conicGradient(paint, boxBounds);
    default:
      return paint.r !== void 0 ? { type: "solid", style: ColorConvert.string(paint) } : void 0;
  }
}
var PaintModule = {
  compute,
  fill,
  fills,
  fillText,
  stroke,
  strokes,
  strokeText,
  drawTextStroke,
  shape
};
var origin = {};
var { get: get$3, rotateOfOuter: rotateOfOuter$1, translate: translate$1, scaleOfOuter: scaleOfOuter$1, scale: scaleHelper, rotate: rotate2 } = MatrixHelper;
function fillOrFitMode(data, box3, x, y, scaleX, scaleY, rotation) {
  const transform2 = get$3();
  translate$1(transform2, box3.x + x, box3.y + y);
  scaleHelper(transform2, scaleX, scaleY);
  if (rotation)
    rotateOfOuter$1(transform2, { x: box3.x + box3.width / 2, y: box3.y + box3.height / 2 }, rotation);
  data.transform = transform2;
}
function clipMode(data, box3, x, y, scaleX, scaleY, rotation) {
  const transform2 = get$3();
  translate$1(transform2, box3.x + x, box3.y + y);
  if (scaleX)
    scaleHelper(transform2, scaleX, scaleY);
  if (rotation)
    rotate2(transform2, rotation);
  data.transform = transform2;
}
function repeatMode(data, box3, width, height, x, y, scaleX, scaleY, rotation, align) {
  const transform2 = get$3();
  if (rotation) {
    if (align === "center") {
      rotateOfOuter$1(transform2, { x: width / 2, y: height / 2 }, rotation);
    } else {
      rotate2(transform2, rotation);
      switch (rotation) {
        case 90:
          translate$1(transform2, height, 0);
          break;
        case 180:
          translate$1(transform2, width, height);
          break;
        case 270:
          translate$1(transform2, 0, width);
          break;
      }
    }
  }
  origin.x = box3.x + x;
  origin.y = box3.y + y;
  translate$1(transform2, origin.x, origin.y);
  if (scaleX)
    scaleOfOuter$1(transform2, origin, scaleX, scaleY);
  data.transform = transform2;
}
var { get: get$2, translate } = MatrixHelper;
var tempBox = new Bounds();
var tempPoint2 = {};
var tempScaleData = {};
function createData(leafPaint, image2, paint, box3) {
  const { blendMode, sync } = paint;
  if (blendMode)
    leafPaint.blendMode = blendMode;
  if (sync)
    leafPaint.sync = sync;
  leafPaint.data = getPatternData(paint, box3, image2);
}
function getPatternData(paint, box3, image2) {
  let { width, height } = image2;
  if (paint.padding)
    box3 = tempBox.set(box3).shrink(paint.padding);
  if (paint.mode === "strench")
    paint.mode = "stretch";
  const { opacity, mode, align, offset, scale: scale2, size, rotation, repeat } = paint;
  const sameBox = box3.width === width && box3.height === height;
  const data = { mode };
  const swapSize = align !== "center" && (rotation || 0) % 180 === 90;
  const swapWidth = swapSize ? height : width, swapHeight = swapSize ? width : height;
  let x = 0, y = 0, scaleX, scaleY;
  if (!mode || mode === "cover" || mode === "fit") {
    if (!sameBox || rotation) {
      const sw = box3.width / swapWidth, sh = box3.height / swapHeight;
      scaleX = scaleY = mode === "fit" ? Math.min(sw, sh) : Math.max(sw, sh);
      x += (box3.width - width * scaleX) / 2, y += (box3.height - height * scaleY) / 2;
    }
  } else if (scale2 || size) {
    MathHelper.getScaleData(scale2, size, image2, tempScaleData);
    scaleX = tempScaleData.scaleX;
    scaleY = tempScaleData.scaleY;
  }
  if (align) {
    const imageBounds = { x, y, width: swapWidth, height: swapHeight };
    if (scaleX)
      imageBounds.width *= scaleX, imageBounds.height *= scaleY;
    AlignHelper.toPoint(align, imageBounds, box3, tempPoint2, true);
    x += tempPoint2.x, y += tempPoint2.y;
  }
  if (offset)
    x += offset.x, y += offset.y;
  switch (mode) {
    case "stretch":
      if (!sameBox)
        width = box3.width, height = box3.height;
      break;
    case "normal":
    case "clip":
      if (x || y || scaleX || rotation)
        clipMode(data, box3, x, y, scaleX, scaleY, rotation);
      break;
    case "repeat":
      if (!sameBox || scaleX || rotation)
        repeatMode(data, box3, width, height, x, y, scaleX, scaleY, rotation, align);
      if (!repeat)
        data.repeat = "repeat";
      break;
    case "fit":
    case "cover":
    default:
      if (scaleX)
        fillOrFitMode(data, box3, x, y, scaleX, scaleY, rotation);
  }
  if (!data.transform) {
    if (box3.x || box3.y) {
      data.transform = get$2();
      translate(data.transform, box3.x, box3.y);
    }
  }
  if (scaleX && mode !== "stretch") {
    data.scaleX = scaleX;
    data.scaleY = scaleY;
  }
  data.width = width;
  data.height = height;
  if (opacity)
    data.opacity = opacity;
  if (repeat)
    data.repeat = typeof repeat === "string" ? repeat === "x" ? "repeat-x" : "repeat-y" : "repeat";
  return data;
}
var cache;
var box2 = new Bounds();
var { isSame: isSame2 } = BoundsHelper;
function image(ui2, attrName, paint, boxBounds, firstUse) {
  let leafPaint, event;
  const image2 = ImageManager.get(paint);
  if (cache && paint === cache.paint && isSame2(boxBounds, cache.boxBounds)) {
    leafPaint = cache.leafPaint;
  } else {
    leafPaint = { type: paint.type, image: image2 };
    cache = image2.use > 1 ? { leafPaint, paint, boxBounds: box2.set(boxBounds) } : null;
  }
  if (firstUse || image2.loading)
    event = { image: image2, attrName, attrValue: paint };
  if (image2.ready) {
    checkSizeAndCreateData(ui2, attrName, paint, image2, leafPaint, boxBounds);
    if (firstUse) {
      onLoad(ui2, event);
      onLoadSuccess(ui2, event);
    }
  } else if (image2.error) {
    if (firstUse)
      onLoadError(ui2, event, image2.error);
  } else {
    if (firstUse) {
      ignoreRender(ui2, true);
      onLoad(ui2, event);
    }
    leafPaint.loadId = image2.load(() => {
      ignoreRender(ui2, false);
      if (!ui2.destroyed) {
        if (checkSizeAndCreateData(ui2, attrName, paint, image2, leafPaint, boxBounds)) {
          if (image2.hasOpacityPixel)
            ui2.__layout.hitCanvasChanged = true;
          ui2.forceUpdate("surface");
        }
        onLoadSuccess(ui2, event);
      }
      leafPaint.loadId = null;
    }, (error) => {
      ignoreRender(ui2, false);
      onLoadError(ui2, event, error);
      leafPaint.loadId = null;
    });
  }
  return leafPaint;
}
function checkSizeAndCreateData(ui2, attrName, paint, image2, leafPaint, boxBounds) {
  if (attrName === "fill" && !ui2.__.__naturalWidth) {
    const data = ui2.__;
    data.__naturalWidth = image2.width / data.pixelRatio;
    data.__naturalHeight = image2.height / data.pixelRatio;
    if (data.__autoSide) {
      ui2.forceUpdate("width");
      if (ui2.__proxyData) {
        ui2.setProxyAttr("width", data.width);
        ui2.setProxyAttr("height", data.height);
      }
      return false;
    }
  }
  if (!leafPaint.data)
    createData(leafPaint, image2, paint, boxBounds);
  return true;
}
function onLoad(ui2, event) {
  emit3(ui2, ImageEvent.LOAD, event);
}
function onLoadSuccess(ui2, event) {
  emit3(ui2, ImageEvent.LOADED, event);
}
function onLoadError(ui2, event, error) {
  event.error = error;
  ui2.forceUpdate("surface");
  emit3(ui2, ImageEvent.ERROR, event);
}
function emit3(ui2, type, data) {
  if (ui2.hasEvent(type))
    ui2.emitEvent(new ImageEvent(type, data));
}
function ignoreRender(ui2, value) {
  const { leafer: leafer2 } = ui2;
  if (leafer2 && leafer2.viewReady)
    leafer2.renderer.ignore = value;
}
var { get: get$1, scale, copy: copy$12 } = MatrixHelper;
var { ceil: ceil2, abs: abs$12 } = Math;
function createPattern(ui2, paint, pixelRatio) {
  let { scaleX, scaleY } = ImageManager.patternLocked ? ui2.__world : ui2.__nowWorld;
  const id = scaleX + "-" + scaleY + "-" + pixelRatio;
  if (paint.patternId !== id && !ui2.destroyed) {
    scaleX = abs$12(scaleX);
    scaleY = abs$12(scaleY);
    const { image: image2, data } = paint;
    let imageScale, imageMatrix, { width, height, scaleX: sx, scaleY: sy, opacity, transform: transform2, repeat } = data;
    if (sx) {
      imageMatrix = get$1();
      copy$12(imageMatrix, transform2);
      scale(imageMatrix, 1 / sx, 1 / sy);
      scaleX *= sx;
      scaleY *= sy;
    }
    scaleX *= pixelRatio;
    scaleY *= pixelRatio;
    width *= scaleX;
    height *= scaleY;
    const size = width * height;
    if (!repeat) {
      if (size > Platform.image.maxCacheSize)
        return false;
    }
    let maxSize = Platform.image.maxPatternSize;
    if (!image2.isSVG) {
      const imageSize = image2.width * image2.height;
      if (maxSize > imageSize)
        maxSize = imageSize;
    }
    if (size > maxSize)
      imageScale = Math.sqrt(size / maxSize);
    if (imageScale) {
      scaleX /= imageScale;
      scaleY /= imageScale;
      width /= imageScale;
      height /= imageScale;
    }
    if (sx) {
      scaleX /= sx;
      scaleY /= sy;
    }
    if (transform2 || scaleX !== 1 || scaleY !== 1) {
      if (!imageMatrix) {
        imageMatrix = get$1();
        if (transform2)
          copy$12(imageMatrix, transform2);
      }
      scale(imageMatrix, 1 / scaleX, 1 / scaleY);
    }
    const canvas3 = image2.getCanvas(ceil2(width) || 1, ceil2(height) || 1, opacity);
    const pattern = image2.getPattern(canvas3, repeat || (Platform.origin.noRepeat || "no-repeat"), imageMatrix, paint);
    paint.style = pattern;
    paint.patternId = id;
    return true;
  } else {
    return false;
  }
}
function __awaiter2(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
var { abs: abs2 } = Math;
function checkImage(ui2, canvas3, paint, allowPaint) {
  const { scaleX, scaleY } = ImageManager.patternLocked ? ui2.__world : ui2.__nowWorld;
  const { pixelRatio } = canvas3;
  if (!paint.data || paint.patternId === scaleX + "-" + scaleY + "-" + pixelRatio && !Export.running) {
    return false;
  } else {
    const { data } = paint;
    if (allowPaint) {
      if (!data.repeat) {
        let { width, height } = data;
        width *= abs2(scaleX) * pixelRatio;
        height *= abs2(scaleY) * pixelRatio;
        if (data.scaleX) {
          width *= data.scaleX;
          height *= data.scaleY;
        }
        allowPaint = width * height > Platform.image.maxCacheSize || Export.running;
      } else {
        allowPaint = false;
      }
    }
    if (allowPaint) {
      canvas3.save();
      ui2.windingRule ? canvas3.clip(ui2.windingRule) : canvas3.clip();
      if (paint.blendMode)
        canvas3.blendMode = paint.blendMode;
      if (data.opacity)
        canvas3.opacity *= data.opacity;
      if (data.transform)
        canvas3.transform(data.transform);
      canvas3.drawImage(paint.image.view, 0, 0, data.width, data.height);
      canvas3.restore();
      return true;
    } else {
      if (!paint.style || paint.sync || Export.running) {
        createPattern(ui2, paint, pixelRatio);
      } else {
        if (!paint.patternTask) {
          paint.patternTask = ImageManager.patternTasker.add(() => __awaiter2(this, void 0, void 0, function* () {
            paint.patternTask = null;
            if (canvas3.bounds.hit(ui2.__nowWorld))
              createPattern(ui2, paint, pixelRatio);
            ui2.forceUpdate("surface");
          }), 300);
        }
      }
      return false;
    }
  }
}
function recycleImage(attrName, data) {
  const paints = data["_" + attrName];
  if (paints instanceof Array) {
    let image2, recycleMap2, input, url;
    for (let i = 0, len = paints.length; i < len; i++) {
      image2 = paints[i].image;
      url = image2 && image2.url;
      if (url) {
        if (!recycleMap2)
          recycleMap2 = {};
        recycleMap2[url] = true;
        ImageManager.recycle(image2);
        if (image2.loading) {
          if (!input) {
            input = data.__input && data.__input[attrName] || [];
            if (!(input instanceof Array))
              input = [input];
          }
          image2.unload(paints[i].loadId, !input.some((item) => item.url === url));
        }
      }
    }
    return recycleMap2;
  }
  return null;
}
var PaintImageModule = {
  image,
  checkImage,
  createPattern,
  recycleImage,
  createData,
  getPatternData,
  fillOrFitMode,
  clipMode,
  repeatMode
};
var { toPoint: toPoint$22 } = AroundHelper;
var realFrom$2 = {};
var realTo$2 = {};
function linearGradient(paint, box3) {
  let { from, to, type, blendMode, opacity } = paint;
  toPoint$22(from || "top", box3, realFrom$2);
  toPoint$22(to || "bottom", box3, realTo$2);
  const style = Platform.canvas.createLinearGradient(realFrom$2.x, realFrom$2.y, realTo$2.x, realTo$2.y);
  applyStops(style, paint.stops, opacity);
  const data = { type, style };
  if (blendMode)
    data.blendMode = blendMode;
  return data;
}
function applyStops(gradient, stops, opacity) {
  if (stops) {
    let stop;
    for (let i = 0, len = stops.length; i < len; i++) {
      stop = stops[i];
      if (typeof stop === "string") {
        gradient.addColorStop(i / (len - 1), ColorConvert.string(stop, opacity));
      } else {
        gradient.addColorStop(stop.offset, ColorConvert.string(stop.color, opacity));
      }
    }
  }
}
var { getAngle: getAngle2, getDistance: getDistance$1 } = PointHelper;
var { get: get2, rotateOfOuter: rotateOfOuter2, scaleOfOuter: scaleOfOuter2 } = MatrixHelper;
var { toPoint: toPoint$12 } = AroundHelper;
var realFrom$1 = {};
var realTo$1 = {};
function radialGradient(paint, box3) {
  let { from, to, type, opacity, blendMode, stretch } = paint;
  toPoint$12(from || "center", box3, realFrom$1);
  toPoint$12(to || "bottom", box3, realTo$1);
  const style = Platform.canvas.createRadialGradient(realFrom$1.x, realFrom$1.y, 0, realFrom$1.x, realFrom$1.y, getDistance$1(realFrom$1, realTo$1));
  applyStops(style, paint.stops, opacity);
  const data = { type, style };
  const transform2 = getTransform(box3, realFrom$1, realTo$1, stretch, true);
  if (transform2)
    data.transform = transform2;
  if (blendMode)
    data.blendMode = blendMode;
  return data;
}
function getTransform(box3, from, to, stretch, rotate90) {
  let transform2;
  const { width, height } = box3;
  if (width !== height || stretch) {
    const angle = getAngle2(from, to);
    transform2 = get2();
    if (rotate90) {
      scaleOfOuter2(transform2, from, width / height * (stretch || 1), 1);
      rotateOfOuter2(transform2, from, angle + 90);
    } else {
      scaleOfOuter2(transform2, from, 1, width / height * (stretch || 1));
      rotateOfOuter2(transform2, from, angle);
    }
  }
  return transform2;
}
var { getDistance: getDistance2 } = PointHelper;
var { toPoint: toPoint2 } = AroundHelper;
var realFrom = {};
var realTo = {};
function conicGradient(paint, box3) {
  let { from, to, type, opacity, blendMode, stretch } = paint;
  toPoint2(from || "center", box3, realFrom);
  toPoint2(to || "bottom", box3, realTo);
  const style = Platform.conicGradientSupport ? Platform.canvas.createConicGradient(0, realFrom.x, realFrom.y) : Platform.canvas.createRadialGradient(realFrom.x, realFrom.y, 0, realFrom.x, realFrom.y, getDistance2(realFrom, realTo));
  applyStops(style, paint.stops, opacity);
  const data = { type, style };
  const transform2 = getTransform(box3, realFrom, realTo, stretch || 1, Platform.conicGradientRotate90);
  if (transform2)
    data.transform = transform2;
  if (blendMode)
    data.blendMode = blendMode;
  return data;
}
var PaintGradientModule = {
  linearGradient,
  radialGradient,
  conicGradient,
  getTransform
};
var { copy: copy4, toOffsetOutBounds: toOffsetOutBounds$1 } = BoundsHelper;
var tempBounds2 = {};
var offsetOutBounds$1 = {};
function shadow(ui2, current2, shape2) {
  let copyBounds, spreadScale;
  const { __nowWorld: nowWorld, __layout } = ui2;
  const { shadow: shadow2 } = ui2.__;
  const { worldCanvas, bounds: bounds2, shapeBounds, scaleX, scaleY } = shape2;
  const other = current2.getSameCanvas();
  const end = shadow2.length - 1;
  toOffsetOutBounds$1(bounds2, offsetOutBounds$1);
  shadow2.forEach((item, index) => {
    other.setWorldShadow(offsetOutBounds$1.offsetX + item.x * scaleX, offsetOutBounds$1.offsetY + item.y * scaleY, item.blur * scaleX, item.color);
    spreadScale = item.spread ? 1 + item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
    drawWorldShadow(other, offsetOutBounds$1, spreadScale, shape2);
    copyBounds = bounds2;
    if (item.box) {
      other.restore();
      other.save();
      if (worldCanvas) {
        other.copyWorld(other, bounds2, nowWorld, "copy");
        copyBounds = nowWorld;
      }
      worldCanvas ? other.copyWorld(worldCanvas, nowWorld, nowWorld, "destination-out") : other.copyWorld(shape2.canvas, shapeBounds, bounds2, "destination-out");
    }
    if (ui2.__worldFlipped) {
      current2.copyWorldByReset(other, copyBounds, nowWorld, item.blendMode);
    } else {
      current2.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
    }
    if (end && index < end)
      other.clearWorld(copyBounds, true);
  });
  other.recycle(copyBounds);
}
function drawWorldShadow(canvas3, outBounds, spreadScale, shape2) {
  const { bounds: bounds2, shapeBounds } = shape2;
  if (Platform.fullImageShadow) {
    copy4(tempBounds2, canvas3.bounds);
    tempBounds2.x += outBounds.x - shapeBounds.x;
    tempBounds2.y += outBounds.y - shapeBounds.y;
    if (spreadScale) {
      const { matrix: matrix3 } = shape2;
      tempBounds2.x -= (bounds2.x + (matrix3 ? matrix3.e : 0) + bounds2.width / 2) * (spreadScale - 1);
      tempBounds2.y -= (bounds2.y + (matrix3 ? matrix3.f : 0) + bounds2.height / 2) * (spreadScale - 1);
      tempBounds2.width *= spreadScale;
      tempBounds2.height *= spreadScale;
    }
    canvas3.copyWorld(shape2.canvas, canvas3.bounds, tempBounds2);
  } else {
    if (spreadScale) {
      copy4(tempBounds2, outBounds);
      tempBounds2.x -= outBounds.width / 2 * (spreadScale - 1);
      tempBounds2.y -= outBounds.height / 2 * (spreadScale - 1);
      tempBounds2.width *= spreadScale;
      tempBounds2.height *= spreadScale;
    }
    canvas3.copyWorld(shape2.canvas, shapeBounds, spreadScale ? tempBounds2 : outBounds);
  }
}
var { toOffsetOutBounds } = BoundsHelper;
var offsetOutBounds = {};
function innerShadow(ui2, current2, shape2) {
  let copyBounds, spreadScale;
  const { __nowWorld: nowWorld, __layout } = ui2;
  const { innerShadow: innerShadow2 } = ui2.__;
  const { worldCanvas, bounds: bounds2, shapeBounds, scaleX, scaleY } = shape2;
  const other = current2.getSameCanvas();
  const end = innerShadow2.length - 1;
  toOffsetOutBounds(bounds2, offsetOutBounds);
  innerShadow2.forEach((item, index) => {
    other.save();
    other.setWorldShadow(offsetOutBounds.offsetX + item.x * scaleX, offsetOutBounds.offsetY + item.y * scaleY, item.blur * scaleX);
    spreadScale = item.spread ? 1 - item.spread * 2 / (__layout.boxBounds.width + (__layout.strokeBoxSpread || 0) * 2) : 0;
    drawWorldShadow(other, offsetOutBounds, spreadScale, shape2);
    other.restore();
    if (worldCanvas) {
      other.copyWorld(other, bounds2, nowWorld, "copy");
      other.copyWorld(worldCanvas, nowWorld, nowWorld, "source-out");
      copyBounds = nowWorld;
    } else {
      other.copyWorld(shape2.canvas, shapeBounds, bounds2, "source-out");
      copyBounds = bounds2;
    }
    other.fillWorld(copyBounds, item.color, "source-in");
    if (ui2.__worldFlipped) {
      current2.copyWorldByReset(other, copyBounds, nowWorld, item.blendMode);
    } else {
      current2.copyWorldToInner(other, copyBounds, __layout.renderBounds, item.blendMode);
    }
    if (end && index < end)
      other.clearWorld(copyBounds, true);
  });
  other.recycle(copyBounds);
}
function blur(ui2, current2, origin2) {
  const { blur: blur2 } = ui2.__;
  origin2.setWorldBlur(blur2 * ui2.__nowWorld.a);
  origin2.copyWorldToInner(current2, ui2.__nowWorld, ui2.__layout.renderBounds);
  origin2.filter = "none";
}
function backgroundBlur(_ui, _current, _shape) {
}
var EffectModule = {
  shadow,
  innerShadow,
  blur,
  backgroundBlur
};
var { excludeRenderBounds: excludeRenderBounds2 } = LeafBoundsHelper;
Group.prototype.__renderMask = function(canvas3, options) {
  let child, maskCanvas, contentCanvas, maskOpacity, currentMask, mask;
  const { children } = this;
  for (let i = 0, len = children.length; i < len; i++) {
    child = children[i], mask = child.__.mask;
    if (mask) {
      if (currentMask) {
        maskEnd(this, currentMask, canvas3, contentCanvas, maskCanvas, maskOpacity);
        maskCanvas = contentCanvas = null;
      }
      if (mask === "path" || mask === "clipping-path") {
        if (child.opacity < 1) {
          currentMask = "opacity-path";
          maskOpacity = child.opacity;
          if (!contentCanvas)
            contentCanvas = getCanvas(canvas3);
        } else {
          currentMask = "path";
          canvas3.save();
        }
        child.__clip(contentCanvas || canvas3, options);
      } else {
        currentMask = mask === "grayscale" ? "grayscale" : "alpha";
        if (!maskCanvas)
          maskCanvas = getCanvas(canvas3);
        if (!contentCanvas)
          contentCanvas = getCanvas(canvas3);
        child.__render(maskCanvas, options);
      }
      if (!(mask === "clipping" || mask === "clipping-path"))
        continue;
    }
    if (excludeRenderBounds2(child, options))
      continue;
    child.__render(contentCanvas || canvas3, options);
  }
  maskEnd(this, currentMask, canvas3, contentCanvas, maskCanvas, maskOpacity);
};
function maskEnd(leaf2, maskMode, canvas3, contentCanvas, maskCanvas, maskOpacity) {
  switch (maskMode) {
    case "grayscale":
      maskCanvas.useGrayscaleAlpha(leaf2.__nowWorld);
    case "alpha":
      usePixelMask(leaf2, canvas3, contentCanvas, maskCanvas);
      break;
    case "opacity-path":
      copyContent(leaf2, canvas3, contentCanvas, maskOpacity);
      break;
    case "path":
      canvas3.restore();
  }
}
function getCanvas(canvas3) {
  return canvas3.getSameCanvas(false, true);
}
function usePixelMask(leaf2, canvas3, content, mask) {
  const realBounds = leaf2.__nowWorld;
  content.resetTransform();
  content.opacity = 1;
  content.useMask(mask, realBounds);
  mask.recycle(realBounds);
  copyContent(leaf2, canvas3, content, 1);
}
function copyContent(leaf2, canvas3, content, maskOpacity) {
  const realBounds = leaf2.__nowWorld;
  canvas3.resetTransform();
  canvas3.opacity = maskOpacity;
  canvas3.copyWorld(content, realBounds);
  content.recycle(realBounds);
}
var money = "¥￥＄€£￡¢￠";
var letter = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz";
var langBefore = "《（「〈『〖【〔｛┌＜‘“＝" + money;
var langAfter = "》）」〉』〗】〕｝┐＞’”！？，、。：；‰";
var langSymbol = "≮≯≈≠＝…";
var langBreak$1 = "—／～｜┆·";
var beforeChar = `{[(<'"` + langBefore;
var afterChar = `>)]}%!?,.:;'"` + langAfter;
var symbolChar = afterChar + "_#~&*+\\=|" + langSymbol;
var breakChar = "- " + langBreak$1;
var cjkRangeList = [
  [19968, 40959],
  [13312, 19903],
  [131072, 173791],
  [173824, 177983],
  [177984, 178207],
  [178208, 183983],
  [183984, 191471],
  [196608, 201551],
  [201552, 205743],
  [11904, 12031],
  [12032, 12255],
  [12272, 12287],
  [12288, 12351],
  [12736, 12783],
  [12800, 13055],
  [13056, 13311],
  [63744, 64255],
  [65072, 65103],
  [127488, 127743],
  [194560, 195103]
];
var cjkReg = new RegExp(cjkRangeList.map(([start, end]) => `[\\u${start.toString(16)}-\\u${end.toString(16)}]`).join("|"));
function mapChar(str) {
  const map = {};
  str.split("").forEach((char2) => map[char2] = true);
  return map;
}
var letterMap = mapChar(letter);
var beforeMap = mapChar(beforeChar);
var afterMap = mapChar(afterChar);
var symbolMap = mapChar(symbolChar);
var breakMap = mapChar(breakChar);
var CharType;
(function(CharType2) {
  CharType2[CharType2["Letter"] = 0] = "Letter";
  CharType2[CharType2["Single"] = 1] = "Single";
  CharType2[CharType2["Before"] = 2] = "Before";
  CharType2[CharType2["After"] = 3] = "After";
  CharType2[CharType2["Symbol"] = 4] = "Symbol";
  CharType2[CharType2["Break"] = 5] = "Break";
})(CharType || (CharType = {}));
var { Letter: Letter$1, Single: Single$1, Before: Before$1, After: After$1, Symbol: Symbol$1, Break: Break$1 } = CharType;
function getCharType(char2) {
  if (letterMap[char2]) {
    return Letter$1;
  } else if (breakMap[char2]) {
    return Break$1;
  } else if (beforeMap[char2]) {
    return Before$1;
  } else if (afterMap[char2]) {
    return After$1;
  } else if (symbolMap[char2]) {
    return Symbol$1;
  } else if (cjkReg.test(char2)) {
    return Single$1;
  } else {
    return Letter$1;
  }
}
var TextRowHelper = {
  trimRight(row2) {
    const { words } = row2;
    let trimRight2 = 0, len = words.length, char2;
    for (let i = len - 1; i > -1; i--) {
      char2 = words[i].data[0];
      if (char2.char === " ") {
        trimRight2++;
        row2.width -= char2.width;
      } else {
        break;
      }
    }
    if (trimRight2)
      words.splice(len - trimRight2, trimRight2);
  }
};
function getTextCase(char2, textCase, firstChar) {
  switch (textCase) {
    case "title":
      return firstChar ? char2.toUpperCase() : char2;
    case "upper":
      return char2.toUpperCase();
    case "lower":
      return char2.toLowerCase();
    default:
      return char2;
  }
}
var { trimRight } = TextRowHelper;
var { Letter, Single, Before, After, Symbol, Break } = CharType;
var word;
var row;
var wordWidth;
var rowWidth;
var realWidth;
var char;
var charWidth;
var startCharSize;
var charSize;
var charType;
var lastCharType;
var langBreak;
var afterBreak;
var paraStart;
var textDrawData;
var rows = [];
var bounds;
var findMaxWidth;
function createRows(drawData, content, style) {
  textDrawData = drawData;
  rows = drawData.rows;
  bounds = drawData.bounds;
  findMaxWidth = !bounds.width && !style.autoSizeAlign;
  const { __letterSpacing, paraIndent, textCase } = style;
  const { canvas: canvas3 } = Platform;
  const { width, height } = bounds;
  const charMode = width || height || __letterSpacing || textCase !== "none";
  if (charMode) {
    const wrap = style.textWrap !== "none";
    const breakAll = style.textWrap === "break";
    paraStart = true;
    lastCharType = null;
    startCharSize = charWidth = charSize = wordWidth = rowWidth = 0;
    word = { data: [] }, row = { words: [] };
    for (let i = 0, len = content.length; i < len; i++) {
      char = content[i];
      if (char === "\n") {
        if (wordWidth)
          addWord();
        row.paraEnd = true;
        addRow();
        paraStart = true;
      } else {
        charType = getCharType(char);
        if (charType === Letter && textCase !== "none")
          char = getTextCase(char, textCase, !wordWidth);
        charWidth = canvas3.measureText(char).width;
        if (__letterSpacing) {
          if (__letterSpacing < 0)
            charSize = charWidth;
          charWidth += __letterSpacing;
        }
        langBreak = charType === Single && (lastCharType === Single || lastCharType === Letter) || lastCharType === Single && charType !== After;
        afterBreak = (charType === Before || charType === Single) && (lastCharType === Symbol || lastCharType === After);
        realWidth = paraStart && paraIndent ? width - paraIndent : width;
        if (wrap && (width && rowWidth + wordWidth + charWidth > realWidth)) {
          if (breakAll) {
            if (wordWidth)
              addWord();
            if (rowWidth)
              addRow();
          } else {
            if (!afterBreak)
              afterBreak = charType === Letter && lastCharType == After;
            if (langBreak || afterBreak || charType === Break || charType === Before || charType === Single || wordWidth + charWidth > realWidth) {
              if (wordWidth)
                addWord();
              if (rowWidth)
                addRow();
            } else {
              if (rowWidth)
                addRow();
            }
          }
        }
        if (char === " " && paraStart !== true && rowWidth + wordWidth === 0) ;
        else {
          if (charType === Break) {
            if (char === " " && wordWidth)
              addWord();
            addChar(char, charWidth);
            addWord();
          } else if (langBreak || afterBreak) {
            if (wordWidth)
              addWord();
            addChar(char, charWidth);
          } else {
            addChar(char, charWidth);
          }
        }
        lastCharType = charType;
      }
    }
    if (wordWidth)
      addWord();
    if (rowWidth)
      addRow();
    rows.length > 0 && (rows[rows.length - 1].paraEnd = true);
  } else {
    content.split("\n").forEach((content2) => {
      textDrawData.paraNumber++;
      rowWidth = canvas3.measureText(content2).width;
      rows.push({ x: paraIndent || 0, text: content2, width: rowWidth, paraStart: true });
      if (findMaxWidth)
        setMaxWidth();
    });
  }
}
function addChar(char2, width) {
  if (charSize && !startCharSize)
    startCharSize = charSize;
  word.data.push({ char: char2, width });
  wordWidth += width;
}
function addWord() {
  rowWidth += wordWidth;
  word.width = wordWidth;
  row.words.push(word);
  word = { data: [] };
  wordWidth = 0;
}
function addRow() {
  if (paraStart) {
    textDrawData.paraNumber++;
    row.paraStart = true;
    paraStart = false;
  }
  if (charSize) {
    row.startCharSize = startCharSize;
    row.endCharSize = charSize;
    startCharSize = 0;
  }
  row.width = rowWidth;
  if (bounds.width)
    trimRight(row);
  else if (findMaxWidth)
    setMaxWidth();
  rows.push(row);
  row = { words: [] };
  rowWidth = 0;
}
function setMaxWidth() {
  if (rowWidth > (textDrawData.maxWidth || 0))
    textDrawData.maxWidth = rowWidth;
}
var CharMode = 0;
var WordMode = 1;
var TextMode = 2;
function layoutChar(drawData, style, width, _height) {
  const { rows: rows2 } = drawData;
  const { textAlign, paraIndent, letterSpacing } = style;
  let charX, addWordWidth, indentWidth, mode, wordChar;
  rows2.forEach((row2) => {
    if (row2.words) {
      indentWidth = paraIndent && row2.paraStart ? paraIndent : 0;
      addWordWidth = width && textAlign === "justify" && row2.words.length > 1 ? (width - row2.width - indentWidth) / (row2.words.length - 1) : 0;
      mode = letterSpacing || row2.isOverflow ? CharMode : addWordWidth > 0.01 ? WordMode : TextMode;
      if (row2.isOverflow && !letterSpacing)
        row2.textMode = true;
      if (mode === TextMode) {
        row2.x += indentWidth;
        toTextChar$1(row2);
      } else {
        row2.x += indentWidth;
        charX = row2.x;
        row2.data = [];
        row2.words.forEach((word2) => {
          if (mode === WordMode) {
            wordChar = { char: "", x: charX };
            charX = toWordChar(word2.data, charX, wordChar);
            if (row2.isOverflow || wordChar.char !== " ")
              row2.data.push(wordChar);
          } else {
            charX = toChar(word2.data, charX, row2.data, row2.isOverflow);
          }
          if (!row2.paraEnd && addWordWidth) {
            charX += addWordWidth;
            row2.width += addWordWidth;
          }
        });
      }
      row2.words = null;
    }
  });
}
function toTextChar$1(row2) {
  row2.text = "";
  row2.words.forEach((word2) => {
    word2.data.forEach((char2) => {
      row2.text += char2.char;
    });
  });
}
function toWordChar(data, charX, wordChar) {
  data.forEach((char2) => {
    wordChar.char += char2.char;
    charX += char2.width;
  });
  return charX;
}
function toChar(data, charX, rowData, isOverflow) {
  data.forEach((char2) => {
    if (isOverflow || char2.char !== " ") {
      char2.x = charX;
      rowData.push(char2);
    }
    charX += char2.width;
  });
  return charX;
}
function layoutText(drawData, style) {
  const { rows: rows2, bounds: bounds2 } = drawData;
  const { __lineHeight, __baseLine, __letterSpacing, __clipText, textAlign, verticalAlign, paraSpacing, autoSizeAlign } = style;
  let { x, y, width, height } = bounds2, realHeight = __lineHeight * rows2.length + (paraSpacing ? paraSpacing * (drawData.paraNumber - 1) : 0);
  let starY = __baseLine;
  if (__clipText && realHeight > height) {
    realHeight = Math.max(height, __lineHeight);
    drawData.overflow = rows2.length;
  } else if (height || autoSizeAlign) {
    switch (verticalAlign) {
      case "middle":
        y += (height - realHeight) / 2;
        break;
      case "bottom":
        y += height - realHeight;
    }
  }
  starY += y;
  let row2, rowX, rowWidth2, layoutWidth = width || autoSizeAlign ? width : drawData.maxWidth;
  for (let i = 0, len = rows2.length; i < len; i++) {
    row2 = rows2[i];
    row2.x = x;
    if (row2.width < width || row2.width > width && !__clipText) {
      switch (textAlign) {
        case "center":
          row2.x += (layoutWidth - row2.width) / 2;
          break;
        case "right":
          row2.x += layoutWidth - row2.width;
      }
    }
    if (row2.paraStart && paraSpacing && i > 0)
      starY += paraSpacing;
    row2.y = starY;
    starY += __lineHeight;
    if (drawData.overflow > i && starY > realHeight) {
      row2.isOverflow = true;
      drawData.overflow = i + 1;
    }
    rowX = row2.x;
    rowWidth2 = row2.width;
    if (__letterSpacing < 0) {
      if (row2.width < 0) {
        rowWidth2 = -row2.width + style.fontSize + __letterSpacing;
        rowX -= rowWidth2;
        rowWidth2 += style.fontSize;
      } else {
        rowWidth2 -= __letterSpacing;
      }
    }
    if (rowX < bounds2.x)
      bounds2.x = rowX;
    if (rowWidth2 > bounds2.width)
      bounds2.width = rowWidth2;
    if (__clipText && width && width < rowWidth2) {
      row2.isOverflow = true;
      if (!drawData.overflow)
        drawData.overflow = rows2.length;
    }
  }
  bounds2.y = y;
  bounds2.height = realHeight;
}
function clipText(drawData, style, x, width) {
  if (!width)
    return;
  const { rows: rows2, overflow } = drawData;
  let { textOverflow } = style;
  rows2.splice(overflow);
  if (textOverflow && textOverflow !== "show") {
    if (textOverflow === "hide")
      textOverflow = "";
    else if (textOverflow === "ellipsis")
      textOverflow = "...";
    let char2, charRight;
    const ellipsisWidth = textOverflow ? Platform.canvas.measureText(textOverflow).width : 0;
    const right3 = x + width - ellipsisWidth;
    const list3 = style.textWrap === "none" ? rows2 : [rows2[overflow - 1]];
    list3.forEach((row2) => {
      if (row2.isOverflow && row2.data) {
        let end = row2.data.length - 1;
        for (let i = end; i > -1; i--) {
          char2 = row2.data[i];
          charRight = char2.x + char2.width;
          if (i === end && charRight < right3) {
            break;
          } else if (charRight < right3 && char2.char !== " ") {
            row2.data.splice(i + 1);
            row2.width -= char2.width;
            break;
          }
          row2.width -= char2.width;
        }
        row2.width += ellipsisWidth;
        row2.data.push({ char: textOverflow, x: charRight });
        if (row2.textMode)
          toTextChar(row2);
      }
    });
  }
}
function toTextChar(row2) {
  row2.text = "";
  row2.data.forEach((char2) => {
    row2.text += char2.char;
  });
  row2.data = null;
}
function decorationText(drawData, style) {
  const { fontSize } = style;
  drawData.decorationHeight = fontSize / 11;
  switch (style.textDecoration) {
    case "under":
      drawData.decorationY = fontSize * 0.15;
      break;
    case "delete":
      drawData.decorationY = -fontSize * 0.35;
  }
}
var { top, right: right2, bottom: bottom2, left } = Direction4;
function getDrawData(content, style) {
  if (typeof content !== "string")
    content = String(content);
  let x = 0, y = 0;
  let width = style.__getInput("width") || 0;
  let height = style.__getInput("height") || 0;
  const { textDecoration, __font, __padding: padding } = style;
  if (padding) {
    if (width)
      x = padding[left], width -= padding[right2] + padding[left];
    else if (!style.autoSizeAlign)
      x = padding[left];
    if (height)
      y = padding[top], height -= padding[top] + padding[bottom2];
    else if (!style.autoSizeAlign)
      y = padding[top];
  }
  const drawData = {
    bounds: { x, y, width, height },
    rows: [],
    paraNumber: 0,
    font: Platform.canvas.font = __font
  };
  createRows(drawData, content, style);
  if (padding)
    padAutoText(padding, drawData, style, width, height);
  layoutText(drawData, style);
  layoutChar(drawData, style, width);
  if (drawData.overflow)
    clipText(drawData, style, x, width);
  if (textDecoration !== "none")
    decorationText(drawData, style);
  return drawData;
}
function padAutoText(padding, drawData, style, width, height) {
  if (!width && style.autoSizeAlign) {
    switch (style.textAlign) {
      case "left":
        offsetText(drawData, "x", padding[left]);
        break;
      case "right":
        offsetText(drawData, "x", -padding[right2]);
    }
  }
  if (!height && style.autoSizeAlign) {
    switch (style.verticalAlign) {
      case "top":
        offsetText(drawData, "y", padding[top]);
        break;
      case "bottom":
        offsetText(drawData, "y", -padding[bottom2]);
    }
  }
}
function offsetText(drawData, attrName, value) {
  const { bounds: bounds2, rows: rows2 } = drawData;
  bounds2[attrName] += value;
  for (let i = 0; i < rows2.length; i++)
    rows2[i][attrName] += value;
}
var TextConvertModule = {
  getDrawData
};
function string(color, opacity) {
  const doOpacity = typeof opacity === "number" && opacity !== 1;
  if (typeof color === "string") {
    if (doOpacity && ColorConvert.object)
      color = ColorConvert.object(color);
    else
      return color;
  }
  let a2 = color.a === void 0 ? 1 : color.a;
  if (doOpacity)
    a2 *= opacity;
  const rgb = color.r + "," + color.g + "," + color.b;
  return a2 === 1 ? "rgb(" + rgb + ")" : "rgba(" + rgb + "," + a2 + ")";
}
var ColorConvertModule = {
  string
};
var { setPoint: setPoint2, addPoint: addPoint2, toBounds: toBounds3 } = TwoPointBoundsHelper;
function getTrimBounds(canvas3) {
  const { width, height } = canvas3.view;
  const { data } = canvas3.context.getImageData(0, 0, width, height);
  let x, y, pointBounds, index = 0;
  for (let i = 0; i < data.length; i += 4) {
    if (data[i + 3] !== 0) {
      x = index % width;
      y = (index - x) / width;
      pointBounds ? addPoint2(pointBounds, x, y) : setPoint2(pointBounds = {}, x, y);
    }
    index++;
  }
  const bounds2 = new Bounds();
  toBounds3(pointBounds, bounds2);
  return bounds2.scale(1 / canvas3.pixelRatio).ceil();
}
var ExportModule = {
  export(leaf2, filename, options) {
    this.running = true;
    const fileType2 = FileHelper.fileType(filename);
    const isDownload = filename.includes(".");
    options = FileHelper.getExportOptions(options);
    return addTask((success) => new Promise((resolve) => {
      const over = (result) => {
        success(result);
        resolve();
        this.running = false;
      };
      const { toURL } = Platform;
      const { download } = Platform.origin;
      if (fileType2 === "json") {
        isDownload && download(toURL(JSON.stringify(leaf2.toJSON(options.json)), "text"), filename);
        return over({ data: isDownload ? true : leaf2.toJSON(options.json) });
      }
      if (fileType2 === "svg") {
        isDownload && download(toURL(leaf2.toSVG(), "svg"), filename);
        return over({ data: isDownload ? true : leaf2.toSVG() });
      }
      const { leafer: leafer2 } = leaf2;
      if (leafer2) {
        checkLazy(leaf2);
        leafer2.waitViewCompleted(() => __awaiter2(this, void 0, void 0, function* () {
          let renderBounds, trimBounds, scaleX = 1, scaleY = 1;
          const { worldTransform, isLeafer, isFrame } = leaf2;
          const { slice, trim, onCanvas } = options;
          const smooth = options.smooth === void 0 ? leafer2.config.smooth : options.smooth;
          const contextSettings = options.contextSettings || leafer2.config.contextSettings;
          const screenshot = options.screenshot || leaf2.isApp;
          const fill2 = isLeafer && screenshot ? options.fill === void 0 ? leaf2.fill : options.fill : options.fill;
          const needFill = FileHelper.isOpaqueImage(filename) || fill2, matrix3 = new Matrix();
          if (screenshot) {
            renderBounds = screenshot === true ? isLeafer ? leafer2.canvas.bounds : leaf2.worldRenderBounds : screenshot;
          } else {
            let relative = options.relative || (isLeafer ? "inner" : "local");
            scaleX = worldTransform.scaleX;
            scaleY = worldTransform.scaleY;
            switch (relative) {
              case "inner":
                matrix3.set(worldTransform);
                break;
              case "local":
                matrix3.set(worldTransform).divide(leaf2.localTransform);
                scaleX /= leaf2.scaleX;
                scaleY /= leaf2.scaleY;
                break;
              case "world":
                scaleX = 1;
                scaleY = 1;
                break;
              case "page":
                relative = leaf2.leafer;
              default:
                matrix3.set(worldTransform).divide(leaf2.getTransform(relative));
                const l2 = relative.worldTransform;
                scaleX /= scaleX / l2.scaleX;
                scaleY /= scaleY / l2.scaleY;
            }
            renderBounds = leaf2.getBounds("render", relative);
          }
          const scaleData = { scaleX: 1, scaleY: 1 };
          MathHelper.getScaleData(options.scale, options.size, renderBounds, scaleData);
          let pixelRatio = options.pixelRatio || 1;
          if (leaf2.isApp) {
            scaleData.scaleX *= pixelRatio;
            scaleData.scaleY *= pixelRatio;
            pixelRatio = leaf2.app.pixelRatio;
          }
          const { x, y, width, height } = new Bounds(renderBounds).scale(scaleData.scaleX, scaleData.scaleY);
          const renderOptions = { matrix: matrix3.scale(1 / scaleData.scaleX, 1 / scaleData.scaleY).invert().translate(-x, -y).withScale(1 / scaleX * scaleData.scaleX, 1 / scaleY * scaleData.scaleY) };
          let canvas3 = Creator.canvas({ width: Math.round(width), height: Math.round(height), pixelRatio, smooth, contextSettings });
          let sliceLeaf;
          if (slice) {
            sliceLeaf = leaf2;
            sliceLeaf.__worldOpacity = 0;
            leaf2 = leafer2;
            renderOptions.bounds = canvas3.bounds;
          }
          canvas3.save();
          if (isFrame && fill2 !== void 0) {
            const oldFill = leaf2.get("fill");
            leaf2.fill = "";
            leaf2.__render(canvas3, renderOptions);
            leaf2.fill = oldFill;
          } else {
            leaf2.__render(canvas3, renderOptions);
          }
          canvas3.restore();
          if (sliceLeaf)
            sliceLeaf.__updateWorldOpacity();
          if (trim) {
            trimBounds = getTrimBounds(canvas3);
            const old = canvas3, { width: width2, height: height2 } = trimBounds;
            const config2 = { x: 0, y: 0, width: width2, height: height2, pixelRatio };
            canvas3 = Creator.canvas(config2);
            canvas3.copyWorld(old, trimBounds, config2);
          }
          if (needFill)
            canvas3.fillWorld(canvas3.bounds, fill2 || "#FFFFFF", "destination-over");
          if (onCanvas)
            onCanvas(canvas3);
          const data = filename === "canvas" ? canvas3 : yield canvas3.export(filename, options);
          over({ data, width: canvas3.pixelWidth, height: canvas3.pixelHeight, renderBounds, trimBounds });
        }));
      } else {
        over({ data: false });
      }
    }));
  }
};
var tasker;
function addTask(task) {
  if (!tasker)
    tasker = new TaskProcessor();
  return new Promise((resolve) => {
    tasker.add(() => __awaiter2(this, void 0, void 0, function* () {
      return yield task(resolve);
    }), { parallel: false });
  });
}
function checkLazy(leaf2) {
  if (leaf2.__.__needComputePaint)
    leaf2.__.__computePaint();
  if (leaf2.isBranch)
    leaf2.children.forEach((child) => checkLazy(child));
}
var canvas2 = LeaferCanvasBase.prototype;
var debug4 = Debug.get("@leafer-ui/export");
canvas2.export = function(filename, options) {
  const { quality, blob } = FileHelper.getExportOptions(options);
  if (filename.includes("."))
    return this.saveAs(filename, quality);
  else if (blob)
    return this.toBlob(filename, quality);
  else
    return this.toDataURL(filename, quality);
};
canvas2.toBlob = function(type, quality) {
  return new Promise((resolve) => {
    Platform.origin.canvasToBolb(this.view, type, quality).then((blob) => {
      resolve(blob);
    }).catch((e) => {
      debug4.error(e);
      resolve(null);
    });
  });
};
canvas2.toDataURL = function(type, quality) {
  return Platform.origin.canvasToDataURL(this.view, type, quality);
};
canvas2.saveAs = function(filename, quality) {
  return new Promise((resolve) => {
    Platform.origin.canvasSaveAs(this.view, filename, quality).then(() => {
      resolve(true);
    }).catch((e) => {
      debug4.error(e);
      resolve(false);
    });
  });
};
Object.assign(TextConvert, TextConvertModule);
Object.assign(ColorConvert, ColorConvertModule);
Object.assign(Paint, PaintModule);
Object.assign(PaintImage, PaintImageModule);
Object.assign(PaintGradient, PaintGradientModule);
Object.assign(Effect, EffectModule);
Object.assign(Export, ExportModule);
Object.assign(Creator, {
  interaction: (target, canvas3, selector, options) => new Interaction(target, canvas3, selector, options),
  hitCanvas: (options, manager) => new LeaferCanvas(options, manager),
  hitCanvasManager: () => new HitCanvasManager()
});
useCanvas();
export {
  AlignHelper,
  Answer,
  App,
  AroundHelper,
  AutoBounds,
  BezierHelper,
  Bounds,
  BoundsHelper,
  Box,
  BoxData,
  Branch,
  BranchHelper,
  BranchRender,
  Canvas2 as Canvas,
  CanvasData,
  CanvasManager,
  ChildEvent,
  ColorConvert,
  Creator,
  Cursor,
  DataHelper,
  Debug,
  Direction4,
  Direction9,
  DragEvent,
  DropEvent,
  Effect,
  Ellipse,
  EllipseData,
  EllipseHelper,
  Event,
  EventCreator,
  Eventer,
  Export,
  FileHelper,
  Frame,
  FrameData,
  Group,
  GroupData,
  HitCanvasManager,
  Image2 as Image,
  ImageData,
  ImageEvent,
  ImageManager,
  IncrementId,
  Interaction,
  InteractionBase,
  InteractionHelper,
  KeyEvent,
  Keyboard,
  LayoutEvent,
  Layouter,
  Leaf,
  LeafBounds,
  LeafBoundsHelper,
  LeafData,
  LeafDataProxy,
  LeafEventer,
  LeafHelper,
  LeafLayout,
  LeafLevelList,
  LeafList,
  LeafMatrix,
  LeafRender,
  Leafer,
  LeaferCanvas,
  LeaferCanvasBase,
  LeaferData,
  LeaferEvent,
  LeaferImage,
  LeaferTypeCreator,
  Line,
  LineData,
  MathHelper,
  Matrix,
  MatrixHelper,
  MoveEvent,
  MultiTouchHelper,
  MyDragEvent,
  MyImage,
  MyPointerEvent,
  NeedConvertToCanvasCommandMap,
  OneRadian,
  PI2,
  PI_2,
  Paint,
  PaintGradient,
  PaintImage,
  Path,
  PathArrow,
  PathBounds,
  PathCommandDataHelper,
  PathCommandMap,
  PathConvert,
  PathCorner,
  PathCreator,
  PathData,
  PathDrawer,
  PathHelper,
  PathNumberCommandLengthMap,
  PathNumberCommandMap,
  Pen,
  PenData,
  Platform,
  Point,
  PointHelper,
  PointerButton,
  PointerEvent,
  Polygon,
  PolygonData,
  PropertyEvent,
  Rect,
  RectData,
  RectHelper,
  RectRender,
  RenderEvent,
  Renderer,
  ResizeEvent,
  RotateEvent,
  Run,
  Selector,
  Star,
  StarData,
  State,
  StringNumberMap,
  SwipeEvent,
  TaskItem,
  TaskProcessor,
  Text,
  TextConvert,
  TextData,
  Transition,
  TwoPointBoundsHelper,
  UI,
  UIBounds,
  UICreator,
  UIData,
  UIEvent,
  UIRender,
  UnitConvert,
  WaitHelper,
  WatchEvent,
  Watcher,
  ZoomEvent,
  addInteractionWindow,
  affectRenderBoundsType,
  affectStrokeBoundsType,
  attr,
  autoLayoutType,
  boundsType,
  canvasPatch,
  canvasSizeAttrs,
  cursorType,
  dataProcessor,
  dataType,
  decorateLeafAttr,
  defineDataProcessor,
  defineKey,
  defineLeafAttr,
  doBoundsType,
  doStrokeType,
  effectType,
  emptyData,
  eraserType,
  getBoundsData,
  getDescriptor,
  getMatrixData,
  getPointData,
  hitType,
  isNull,
  layoutProcessor,
  maskType,
  naturalBoundsType,
  needPlugin,
  opacityType,
  pathInputType,
  pathType,
  pen,
  positionType,
  registerUI,
  registerUIEvent,
  resizeType,
  rewrite,
  rewriteAble,
  rotationType,
  scaleType,
  sortType,
  strokeType,
  surfaceType,
  tempBounds,
  tempMatrix,
  tempPoint$2 as tempPoint,
  useCanvas,
  useModule,
  version,
  visibleType,
  zoomLayerType
};
//# sourceMappingURL=leafer-ui.js.map
